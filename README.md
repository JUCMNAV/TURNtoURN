# TURNtoURN

## Transformation from TURN to URN using ATL
  
**ATL -** Phase 1 of transformation. Turn2Urn.atl is the primary transformation file and **uses** ConnectNodes.atl using Module Superimposition  
  
**Input -** TURN model saved in .xml format (sample file provided)  
  
**Output -** .jucm output generated by transformation  
  
**Metamodels -** Turn.ecore    
  
**Expected Outputs -** expected output .jucm files for all test cases  
  
**Turn2UrnPhase2.java -** Phase 2 of transformation 

## TODO
* Replace "conns" for "connections" where relevant (if conns does indeed stand for connections)
	* Helpers:
		* orForkNodeConnCounter
		* andForkNodeConnCounter
	* Rules:
		* createNodeConns
		* createOrForkNodeConns
		* createAndForkNodeConns
* Decide on a naming convention for source and target model elements. Either stick to s and t or have the names be descriptive.
* Start returning code from ConnectNodesTemporarilyRemovedCode to ConnectNodes.atl. Refactor it and improve its efficiency as you go.
* Continue returning code from Turn2UrnTemporarilyRemovedCode.txt to Turn2URN.atl. Refactor it and improve its efficiency as you go.
	* Remaining rules to add are shown in Turn2Urn.atl
	* To revisit:
		* From/to blocks of all rules
		* All helper rules created
		* createOrForkNodeConns(ref: Turn!RegularOrFork,  tUCMmap: Urn!UCMmap)
		* URNspec2URNspec
		* Belief2Belief
	* Do blocks processed:
		* createMetadata(name: String, value: String)
		* createNodeConns()
		* createComponent(s: Turn!ComponentRef)
		* createKpiEvalValueSet(s: Turn!LinearConversion)
		* createQMapKpiEvalValueSet(conv: Turn!QualToQMappings)
		* createOrJoin(tUCMmap: Urn!UCMmap)
		* createAndJoin(tUCMmap: Urn!UCMmap)
		* createConnect(tUCMmap: Urn!UCMmap)
		* createCondition(sourceExpression: String)
		* Metadata2Metadata
		* createAndForkNodeConns(ref: Turn!PathBodyNodes,  tUCMmap: Urn!UCMmap)
		* Actor2Actor
		* Decomposition2Decomposition
		* Dependency2Dependency
* Potential patterns to generalize into methods:
	* x -> collect(y|y.someProperty) -> flatten() -> collect(z|thisModule.resolveTemp(z, 'someString'))
	* if(not s.longName.longname.oclIsUndefined())... else...
* Change names of variables that are single letters (in particular, haven't handled this in the case of parameters for called rules)
* Rearrange methods so that their order feels more natural.