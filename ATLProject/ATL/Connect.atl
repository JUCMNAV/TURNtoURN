module Connect;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- At present, this is behavior is also partially performed by
-- rules in the "Process.atl" file. Ideally, this behavior should
-- be limited to only rules in this file.


rule connectPath(sPath: Turn!Path){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;	
	}
	do{
		thisModule.processPathBody(sPath.pathBody);
			
		if(sPath.startPoint.oclIsUndefined()){
			tStartPoint <- thisModule.createStartPoint();
		}
		else{
			tStartPoint <- thisModule.retrieveNode(sPath.startPoint);
		}
		
		if(sPath.pathBody.pathNodes -> isEmpty()){
			thisModule.connectStartPointToPathEnd(sPath.startPoint, tStartPoint, thisModule.getPathEnd(sPath.pathBody));
		}
		else{
			thisModule.connectPathBody(sPath.pathBody, tStartPoint);
		}	
	}
}

rule connectPathBody(sPathbody: Turn!PathBody, tPathStart: Urn!PathNode){
	do{
		thisModule.connectBodyNodes(sPathbody.pathNodes, tPathStart);
		
		if(not sPathbody.pathNodes -> isEmpty()){
			thisModule.connectLastNodeToPathEnd(sPathbody, sPathbody.pathNodes.last());
		}
	}
}

rule connectBodyNodes(sPathNodes: Sequence(Turn!PathBodyNode), tPathStart: Urn!PathNode){
	using{
		tNode : Urn!PathNode = OclUndefined;
		tPreviousNode : Urn!PathNode = tPathStart;
	}
	do{
		for(sCurrentNode in sPathNodes){
			if(sCurrentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.processTimer(sCurrentNode);
			}

			tNode <- thisModule.retrieveNode(sCurrentNode);
			
			if(sCurrentNode.oclIsTypeOf(Turn!Connect)){
				thisModule.processConnect(sCurrentNode);
				sCurrentNode <- sCurrentNode.connectsTo;
				tNode <- thisModule.retrieveNode(sCurrentNode);
			}
			else if(sCurrentNode.oclIsTypeOf(Turn!WaitingPlace) or sCurrentNode.oclIsTypeOf(Turn!Timer) and not tPathStart.oclIsTypeOf(Urn!OrJoin)){
				if(not thisModule.emptyPointMap.get(sCurrentNode).oclIsUndefined()){
					tNode <- thisModule.emptyPointMap.get(sCurrentNode);
				}
			}
			
			thisModule.connect(tPreviousNode, tNode);
			tPreviousNode <- tNode;
		}
		tPreviousNode;
	}
}

rule connectStartPointToPathEnd(sStartPoint: Turn!StartPoint, tStartPoint: Urn!StartPoint, tPathEnd: Urn!PathNode){
	do{
		if(not sStartPoint.oclIsUndefined()){
			if(not sStartPoint.connect.oclIsUndefined()){
				tStartPoint <- thisModule.emptyPointMap.get(sStartPoint);
			}
		}

		thisModule.connect(tStartPoint, tPathEnd);
	}
}

rule connectLastNodeToPathEnd(sPathBody: Turn!PathBody, sLastNode: Turn!PathNode){
	do{
		if(sLastNode.oclIsTypeOf(Turn!Connect)){
			sLastNode <- sLastNode.connectsTo;
			
			if(sLastNode.oclIsTypeOf(Turn!StartPoint) and sPathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				thisModule.createNewConnection(thisModule.retrieveNode(sLastNode));
			}
		}
		
		-- connect last node with pathEnd
		thisModule.useConnection(thisModule.getPathEnd(sPathBody), thisModule.handleEmptyBody(sPathBody, thisModule.retrieveNode(sLastNode).nextFreeConnection()));
		
		if(sPathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(thisModule.getPathEnd(sPathBody).succ -> isEmpty()){
				if(not thisModule.emptyPointMap.get(sPathBody.pathNodes.first()).oclIsUndefined()){
					thisModule.connect(thisModule.emptyPointMap.get(sPathBody.pathNodes.first()), thisModule.getPathEnd(sPathBody));
				}
			}
		}	
	}
}

rule connectWithEmptyPoint(tCurrentNode: Urn!PathNode, nextNode: Urn!PathNode){
	using{
		vEmptyPoint : Urn!EmptyPoint = OclUndefined;
	}
	do{
		vEmptyPoint <- thisModule.createEmptyPoint();
		thisModule.connect(tCurrentNode, vEmptyPoint);  -- currentNode -> vEmptyPoint
		thisModule.connect(vEmptyPoint, nextNode);      -- vEmptyPoint -> nextNode
		thisModule.connect(tCurrentNode, nextNode);     -- currentNode -> nextNode
		vEmptyPoint;
	}
}