module ConnectNodes;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- At present, this is behavior is also partially performed by
-- rules in the "Process.atl" file. Ideally, this behavior should
-- be limited to only rules in this file.

rule connectPathEnd(body: Turn!PathBody, nextNodeConnection: Turn!NodeConnection){
	using{
		vPathEnd : Turn!PathNode = body.pathEnd;	
	}
	do{
		if(body.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			vPathEnd <- body.pathEnd.regularEnd;
		}
		
		if(nextNodeConnection.oclIsUndefined() and not thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> isEmpty()){
			nextNodeConnection <- thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> first().firstUnconnectedSucc();
		}
		
		thisModule.addPred(thisModule.retrieveNode(vPathEnd), nextNodeConnection);
	}
}

rule connectReferencedStub(body: Turn!PathBody, nextNodeConnection: Turn!NodeConnection){
	using{
		vStub : Urn!Stub = thisModule.retrieveNode(body.referencedStub);
		vOrJoin : Urn!OrJoin = OclUndefined;
	}
	do{
		if(vStub.pred -> size() >= body.index){
			vOrJoin <- thisModule.createOrJoin();
			thisModule.addPred(vOrJoin, nextNodeConnection);
			thisModule.addPred(vOrJoin, (vStub.pred -> first()).source.succ);
			thisModule.addPred(vStub, vOrJoin.succ);
		}
		else{
			thisModule.addPred(vStub, nextNodeConnection);	
		}
	}
}

rule connectEndToNextNode(body: Turn!PathBody, nextNodeConnection: Turn!NodeConnection){
	using{
		vStub : Urn!Stub = OclUndefined;
		vOrJoin : Urn!OrJoin = OclUndefined;	
	}
	do{
		if(not body.pathEnd.oclIsUndefined()){
			thisModule.connectPathEnd(body, nextNodeConnection);
		}
		else if(not body.referencedEnd.oclIsUndefined()){
			thisModule.addPred(thisModule.retrieveNode(body.referencedEnd), nextNodeConnection);
		}
		else if(not body.referencedStub.oclIsUndefined()){
			thisModule.connectReferencedStub(body, nextNodeConnection);
		}
	}
}

rule connectNodesAfterFork(obj: Turn!PathNode, forkNode: Urn!PathNode){
	using{
		vCounter : Integer = 1;
		vPathBodies : Sequence(Turn!PathBody) = 
			if(forkNode.oclIsTypeOf(Urn!OrFork)) then
				obj.getPathBodies()
			else
				obj.pathbody
			endif;
	}
	do{
		for(pathbody in vPathBodies){
			if(pathbody.pathNodes -> first().oclIsTypeOf(Turn!RespRef)){
				thisModule.addPred(thisModule.retrieveNode(pathbody.pathNodes -> first()), forkNode.succ -> at(vCounter));
			}
			vCounter <- vCounter.inc(); 			
		}
		
		if(obj.pbody.pathNodes -> isEmpty() and not obj.pbody.orFork.oclIsUndefined()){
			thisModule.addPred(forkNode, thisModule.retrieveNode(obj.pbody.orFork.orBody.orFork).succ -> at(thisModule.orForkNodeConnCounter));
			thisModule.orForkNodeConnCounter <- thisModule.orForkNodeConnCounter.inc();
		}
	}
}

rule connectForkNodes(pathend: Turn!PathEnd){
	using{
		vHasReferencedEnd : Boolean = OclUndefined;
		vFork : Urn!PathNode = thisModule.retrieveNode(pathend);
		vCounter : Integer = 1;
		vIsValid : Boolean = false;
		vPathBodies : Sequence(Turn!PathBody) = OclUndefined;
	}
	do{
		if(pathend.oclIsTypeOf(Turn!AndFork)){
			vIsValid <- true;
		}
		else if(pathend.oclIsTypeOf(Turn!OrFork) and not pathend.body.oclIsUndefined()){
			vIsValid <- true;
		}
		
		if(vIsValid){
			if(pathend.oclIsTypeOf(Turn!AndFork)){
				vPathBodies <- pathend.pathbody;
			}
			else if(pathend.oclIsTypeOf(Turn!OrFork) and not pathend.body.oclIsUndefined()){
				vPathBodies <- pathend.body.regularBody -> flatten() -> collect(rb|rb.pathBody);	
			}
			
			for(pathbody in vPathBodies){
				if(not pathbody.referencedEnd.oclIsUndefined() and not pathbody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
					thisModule.addPred(thisModule.retrieveNode(pathbody.referencedEnd), vFork.succ -> at(vCounter));
				}
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect) and vFork.oclIsTypeOf(Urn!AndFork)){
					thisModule.addPred(thisModule.retrieveNode(pathbody.pathEnd.regularEnd), vFork.succ -> at(vCounter));
				}
				else if(not pathbody.pathNodes -> isEmpty()){
					thisModule.connectNodes(pathbody, pathend, OclUndefined);
				}	
				
				vCounter <- vCounter.inc();
			}
		}
	}
}

--QUESTION: there doesn't appear to be a Turn!PathNode class. What should I use instead?
rule handleFirstNode(node: Turn!PathNode, firstNode: Turn!PathNode, nextNode: Urn!PathNode){
	do{
		if(firstNode.oclIsTypeOf(Turn!Connect)){
			if(node.oclIsTypeOf(Urn!AndFork)){ -- this condition necessarily implies that nextNode.oclIsTypeOf('AndFork')
				thisModule.createEmptyPointConnect(firstNode, nextNode.firstUnconnectedSucc());
			}
			else if(node.oclIsTypeOf(Turn!OrFork)){
				thisModule.createEmptyPointConnect(firstNode, thisModule.retrieveNode(node).succ -> first());
			}
			else{
				thisModule.createEmptyPointConnect(firstNode, thisModule.retrieveNode(node).firstUnconnectedSucc());
			}
		}
		else if(node.oclIsTypeOf(Turn!OrFork) or node.oclIsTypeOf(Turn!AndFork)){
			if(nextNode.oclIsUndefined()){
				nextNode <- thisModule.retrieveNode(node);
			}
			
			if(thisModule.retrieveNode(firstNode) <> nextNode)
				thisModule.addPred(thisModule.retrieveNode(firstNode), nextNode.firstUnconnectedSucc());
			
			if(node.oclIsTypeOf(Turn!OrFork)){
				thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).succ -> first());
			}
		}
		else if(firstNode.oclIsTypeOf(Turn!WaitingPlace)){
			if(not firstNode.connect.oclIsUndefined()){
				thisModule.addPred(thisModule.tUCMmap.nodes -> any(n|n.oclIsTypeOf(Urn!EmptyPoint) and n.succ -> includes(thisModule.retrieveNode(firstNode.connect).pred -> first())), thisModule.retrieveNode(node).firstUnconnectedSucc());
			}
			else{
				thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).firstUnconnectedSucc());
			}
		}
		else{
			thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).firstUnconnectedSucc());
		}
	}
}
	
rule handleNode(currentNode: Turn!PathNode, previousNode: Turn!PathNode){
	using{
		vConnect : Turn!PathNode = OclUndefined;
	}
	do{
		if(previousNode.oclIsTypeOf(Turn!Connect)){
			if(not currentNode.oclIsTypeOf(Turn!Connect) and not currentNode.oclIsTypeOf(Turn!OrJoin) and not currentNode.oclIsTypeOf(Turn!AndJoin)){
				thisModule.addSucc(thisModule.retrieveNode(previousNode.connectsTo), thisModule.createNodeConnection());
			}
			if(currentNode.oclIsTypeOf(Turn!Connect)){
				thisModule.createEmptyPointConnect(currentNode, thisModule.retrieveNode(previousNode.connectsTo).succ);
			}
			else{
				thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.retrieveNode(previousNode.connectsTo).firstUnconnectedSucc());	
			}
		}
		else if(currentNode.oclIsTypeOf(Turn!Connect)){
			thisModule.createEmptyPointConnect(currentNode, thisModule.retrieveNode(previousNode).succ);
		}
		else{
			thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.retrieveNode(previousNode).firstUnconnectedSucc());
		}
	}
}

rule connectNodes(pathbody: Sequence(Turn!PathBody), node: Turn!PathNode, nextNode: Urn!PathNode){
	using{
		vPreviousNode : Turn!PathNode = OclUndefined;
		vLastNode : Turn!PathNode = OclUndefined;
	}
	do{
		for(currentNode in pathbody.pathNodes){
			if(currentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.processTimer(currentNode);
			}
			
			if(vPreviousNode.oclIsUndefined()){
				thisModule.handleFirstNode(node, currentNode, nextNode);
			}
			else{
				thisModule.handleNode(currentNode, vPreviousNode);
			}
			
			vPreviousNode <- currentNode;
		}
		
		if(not vPreviousNode.oclIsUndefined()){
			vLastNode <- vPreviousNode;
			
			if(vLastNode.oclIsTypeOf(Turn!Connect)){
				if(vLastNode.connectsTo.oclIsTypeOf(Turn!WaitingPlace)){
					vLastNode <- vLastNode.connectsTo;
				}
				else if(vLastNode.connectsTo.oclIsTypeOf(Turn!StartPoint) and not pathbody.pathEnd.oclIsUndefined()){
					if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
						thisModule.addSucc(thisModule.retrieveNode(vLastNode.connectsTo), thisModule.createNodeConnection());
					}
					vLastNode <- vLastNode.connectsTo;
				}
			}
			
			thisModule.connectEndToNextNode(pathbody, thisModule.retrieveNode(vLastNode).firstUnconnectedSucc());
		}
	}
}