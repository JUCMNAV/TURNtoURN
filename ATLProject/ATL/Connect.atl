module ConnectNodes;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- At present, this is behavior is also partially performed by
-- rules in the "Process.atl" file. Ideally, this behavior should
-- be limited to only rules in this file.

rule getNodeToConnect(body: Turn!PathBody){
	using{
		vNodeToConnect : Turn!PathNode = OclUndefined;
	}
	do{
		if(not body.pathEnd.oclIsUndefined()){
			if(body.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				vNodeToConnect <- thisModule.retrieveNode(body.pathEnd.regularEnd);
			}
			else{
				vNodeToConnect <- thisModule.retrieveNode(body.pathEnd);	
			}
		}
		else if(not body.referencedEnd.oclIsUndefined()){
			vNodeToConnect <- thisModule.retrieveNode(body.referencedEnd);
		}
		else if(not body.referencedStub.oclIsUndefined()){
			vNodeToConnect <- thisModule.retrieveNode(body.referencedStub);
		}
		
		vNodeToConnect;
	}
}

rule connectEndToNextNode(body: Turn!PathBody, nextNodeConnection: Turn!NodeConnection){
	using{
		vNodeToConnect : Turn!PathNode = thisModule.getNodeToConnect(body);
		vEmptyPoints : Sequence(Urn!PathNode) = thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint));
		vOrJoin : Urn!OrJoin = OclUndefined;	
	}
	do{
		if(nextNodeConnection.oclIsUndefined() and not vEmptyPoints -> any(ep|not ep.nextFreeConnection().oclIsUndefined()).oclIsUndefined()){
			nextNodeConnection <- vEmptyPoints -> any(ep|not ep.nextFreeConnection().oclIsUndefined()).nextFreeConnection();
		}
		
		if(not body.referencedStub.oclIsUndefined()){
			if(vNodeToConnect.pred -> size() >= body.index){
				vOrJoin <- thisModule.createOrJoin();
				thisModule.useConnection(vOrJoin, nextNodeConnection);
				thisModule.useConnection(vOrJoin, (vNodeToConnect.pred -> first()).source.succ);
				nextNodeConnection <- vOrJoin.nextFreeConnection();
			}
		}
		
		if(not body.referencedEnd.oclIsUndefined()){
			if(vNodeToConnect.oclIsTypeOf(Urn!RespRef) or vNodeToConnect.oclIsTypeOf(Urn!FailurePoint)){
				vOrJoin <- thisModule.createOrJoin();
				thisModule.useConnection(vOrJoin, nextNodeConnection);
				thisModule.useConnection(vOrJoin, (vNodeToConnect.pred -> first()).source.succ);
				nextNodeConnection <- vOrJoin.nextFreeConnection();
			}
		}
		
		if(vNodeToConnect.oclIsTypeOf(Urn!EndPoint) and not vNodeToConnect.pred -> isEmpty()){
			vOrJoin <- thisModule.createOrJoin();
			thisModule.useConnection(vOrJoin, nextNodeConnection);
			thisModule.useConnection(vOrJoin, (vNodeToConnect.pred -> first()).source.succ);
			nextNodeConnection <- vOrJoin.nextFreeConnection();
		}
		
		if(nextNodeConnection.source.oclIsTypeOf(Urn!EmptyPoint) or nextNodeConnection.source.oclIsTypeOf(Urn!Timer)){
			if(not thisModule.emptyPointMap.get(nextNodeConnection.source).oclIsUndefined()){
				thisModule.debug(nextNodeConnection.source);
				nextNodeConnection.source <- thisModule.emptyPointMap.get(nextNodeConnection.source);
				
				--nextNodeConnection.source.succ <- nextNodeConnection.source.succ -> excluding(nextNodeConnection);
				--thisModule.emptyPointMap.get(nextNodeConnection.source).succ <- nextNodeConnection;
				--nextNodeConnection <- thisModule.emptyPointMap.get(nextNodeConnection.source).succ.last();
				
				thisModule.debug(nextNodeConnection.source);
			}
		}
		
		--if(nextNodeConnection.source.oclIsTypeOf(Urn!Timer)){
		--	if(not thisModule.emptyPointMap.get(nextNodeConnection.source).oclIsUndefined()){
		--		vNodeToConnect <- thisModule.emptyPointMap.get(nextNodeConnection.source);
		--		thisModule.debug(thisModule.emptyPointMap.get(nextNodeConnection.source).succ.last().target);
		--	}
		--}

		if(not vNodeToConnect.oclIsUndefined()){
			thisModule.useConnection(vNodeToConnect, nextNodeConnection);
		}
		
		--if(not Urn!PathNode.allInstances() -> select(e|e.id='183') -> isEmpty()){
		--	if(Urn!PathNode.allInstances() -> select(e|e.id='183').first().succ.last().target.oclIsTypeOf(Urn!EndPoint)){
		--		thisModule.debug('b');	
		--	}
		--}
	}
}

rule connectNodesAfterFork(sFork: Turn!PathNode, pathbodies: Sequence(Turn!PathBody)){
	using{
		vCurrentPosition : Integer = 1;
		vForkNode : Urn!PathNode = thisModule.retrieveNode(sFork);
	}
	do{
		if(sFork.pbody.pathNodes -> isEmpty() and not sFork.pbody.orFork.oclIsUndefined()){
			thisModule.useConnection(vForkNode, thisModule.retrieveNode(sFork.pbody.orFork.orBody.orFork).succ -> at(thisModule.orForkNodeConnCounter));
			thisModule.orForkNodeConnCounter <- thisModule.orForkNodeConnCounter.inc();
		}
	}
}

rule connectForkNodes(pathend: Turn!PathEnd, pathbodies: Sequence(Turn!PathBody)){
	using{
		vFork : Urn!PathNode = thisModule.retrieveNode(pathend);
		vCurrentPosition : Integer = 0;
	}
	do{
		for(pathbody in pathbodies){
			vCurrentPosition <- pathbodies.indexOf(pathbody);
			if(pathbody.referencedEnd.oclIsTypeOf(Turn!AndJoin) or pathbody.referencedEnd.oclIsTypeOf(Turn!OrJoin)){
				thisModule.useConnection(thisModule.retrieveNode(pathbody.referencedEnd), vFork.succ -> at(vCurrentPosition));
			}
			else if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect) and vFork.oclIsTypeOf(Urn!AndFork)){
				thisModule.useConnection(thisModule.retrieveNode(pathbody.pathEnd.regularEnd), vFork.succ -> at(vCurrentPosition));
			}
			else if(not pathbody.pathNodes -> isEmpty()){
				thisModule.connectNodes(pathbody, pathend, thisModule.retrieveNode(pathend));
			}
		}
	}
}
	
rule connectNode(currentNode: Turn!PathNode, nextNodeConnection: Urn!NodeConnection){
	using{
		vNode : Urn!PathNode = thisModule.retrieveNode(currentNode);
	}
	do{
		if(currentNode.oclIsTypeOf(Turn!Connect)){
			if(currentNode.connectsTo.oclIsTypeOf(Turn!Timer)){
				thisModule.createAsynchEmptyPointConnect(currentNode, nextNodeConnection);
				--thisModule.debug(thisModule.resolveTemp(currentNode.connectsTo, 'tTimer').pred -> collect(n|n.source.toString()));
			}
			else{
				thisModule.createEmptyPointConnect(currentNode, nextNodeConnection);
			}
		}
		else{
			if(currentNode.oclIsTypeOf(Turn!WaitingPlace)){
				if(not currentNode.connect.oclIsUndefined()){
					vNode <- thisModule.emptyPointMap.get(currentNode.connect);
				}
			}
			else if(currentNode.oclIsTypeOf(Turn!Timer)){
				if(not thisModule.emptyPointMap.get(thisModule.resolveTemp(currentNode, 'tTimer')).oclIsUndefined()){
					vNode <- thisModule.emptyPointMap.get(thisModule.resolveTemp(currentNode, 'tTimer'));
				}
			}

			thisModule.useConnection(vNode, nextNodeConnection);
		}
	}
}

rule connectNodes(pathbody: Sequence(Turn!PathBody), node: Turn!PathNode, previousNode: Urn!PathNode){
	using{
		vLastNode : Turn!PathNode = pathbody.pathNodes -> last();
	}
	do{
		if(not pathbody.pathNodes -> isEmpty()){
			for(currentNode in pathbody.pathNodes){
				if(currentNode.oclIsTypeOf(Turn!Timer)){
					thisModule.processTimer(currentNode);
				}
				
				if(node.oclIsTypeOf(Turn!OrFork) and thisModule.retrieveNode(currentNode) = previousNode){					
					thisModule.connectNode(currentNode, thisModule.retrieveNode(node).succ -> first());
				}
				else{
					thisModule.connectNode(currentNode, previousNode.nextFreeConnection());
				}
				
				if(currentNode.oclIsTypeOf(Turn!Connect)){
					previousNode <- thisModule.retrieveNode(currentNode.connectsTo);
				}
				else{
					previousNode <- thisModule.retrieveNode(currentNode);
				}
			}
		
			if(vLastNode.oclIsTypeOf(Turn!Connect)){
				--thisModule.debug(thisModule.retrieveNode(vLastNode));
				--thisModule.debug(thisModule.retrieveNode(currentNode));
				
				if(not vLastNode.connectsTo.oclIsTypeOf(Turn!Timer)){
					vLastNode <- vLastNode.connectsTo;
				}
				
				if(vLastNode.oclIsTypeOf(Turn!StartPoint) and pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
					thisModule.createNewConnection(thisModule.retrieveNode(vLastNode));
				}
			}

			thisModule.connectEndToNextNode(pathbody, thisModule.retrieveNode(vLastNode).nextFreeConnection());
		}
	}
}