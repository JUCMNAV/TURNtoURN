module Connect;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- At present, this is behavior is also partially performed by
-- rules in the "Process.atl" file. Ideally, this behavior should
-- be limited to only rules in this file.


rule connectPath(sPath: Turn!Path){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;	
	}
	do{
		thisModule.processPathBody(sPath.pathBody);
			
		if(sPath.startPoint.oclIsUndefined()){
			tStartPoint <- thisModule.createStartPoint();
		}
		else{
			tStartPoint <- thisModule.retrieveNode(sPath.startPoint);
		}
		
		if(sPath.pathBody.pathNodes -> isEmpty()){
			thisModule.connectStartPointToPathEnd(sPath.startPoint, tStartPoint, thisModule.getPathEnd(sPath.pathBody));
		}
		else{
			thisModule.connectPathBody(sPath.pathBody, tStartPoint);
		}	
	}
}

rule connectPathBody(sPathBody: Turn!PathBody, tPathStart: Urn!PathNode){
	do{
		thisModule.connectBodyNodes(sPathBody.pathNodes, tPathStart);
		
		if(sPathBody.pathNodes -> isEmpty()){
			thisModule.connect(tPathStart, thisModule.getPathEnd(sPathBody));
		}
		else{
			thisModule.connectLastNodeToPathEnd(sPathBody, sPathBody.pathNodes.last());
		}
	}
}

rule connectBody(sPathBody: Turn!PathBody, tPathStart: Urn!PathNode){
	using{
		tPathEnd : Urn!PathNode = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
	}
	do{
		thisModule.processPathBody(sPathBody);
		tLastNode <- thisModule.connectBodyNodes(sPathBody.pathNodes, tPathStart);
		tPathEnd <- thisModule.getPathEnd(sPathBody);
		thisModule.connect(tLastNode, tPathEnd);
		tPathEnd;
	}
}

rule connectBodyNodes(sPathNodes: Sequence(Turn!PathBodyNode), tPathStart: Urn!PathNode){
	using{
		tNode : Urn!PathNode = OclUndefined;
		tOrJoin : Urn!OrJoin = OclUndefined;
		tPreviousNode : Urn!PathNode = tPathStart;
	}
	do{
		for(sCurrentNode in sPathNodes){
			if(sCurrentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.processTimer(sCurrentNode);
			}

			tNode <- thisModule.retrieveNode(sCurrentNode);
			
			if(sCurrentNode.oclIsTypeOf(Turn!Connect)){
				thisModule.processConnect(sCurrentNode);
				sCurrentNode <- sCurrentNode.connectsTo;
				tNode <- thisModule.retrieveNode(sCurrentNode);
			}
			else if(sCurrentNode.oclIsTypeOf(Turn!WaitingPlace) or sCurrentNode.oclIsTypeOf(Turn!Timer) and not tPathStart.oclIsTypeOf(Urn!OrJoin)){
				if(not thisModule.emptyPointMap.get(sCurrentNode).oclIsUndefined()){
					tNode <- thisModule.emptyPointMap.get(sCurrentNode);
				}
			}
			
			if((tNode.oclIsTypeOf(Urn!RespRef) or tNode.oclIsTypeOf(Urn!FailurePoint)) and not tNode.pred -> isEmpty()){
				tOrJoin <- thisModule.createOrJoin();
				tNode.pred.first().target <- tOrJoin;
				thisModule.connect(tOrJoin, tNode);
				tNode <- tOrJoin;
			}
			
			thisModule.connect(tPreviousNode, tNode);
			tPreviousNode <- tNode;
		}
		
		tPreviousNode;
	}
}

rule connectStartPointToPathEnd(sStartPoint: Turn!StartPoint, tStartPoint: Urn!StartPoint, tPathEnd: Urn!PathNode){
	do{
		if(not sStartPoint.oclIsUndefined()){
			if(not sStartPoint.connect.oclIsUndefined() and not thisModule.emptyPointMap.get(sStartPoint).oclIsUndefined()){
				tStartPoint <- thisModule.emptyPointMap.get(sStartPoint);
			}
		}

		thisModule.connect(tStartPoint, tPathEnd);
	}
}

rule connectLastNodeToPathEnd(sPathBody: Turn!PathBody, sLastNode: Turn!PathNode){
	using{
		tLastNode : Urn!PathNode = thisModule.retrieveNode(sLastNode);
		tOrJoin : Urn!OrJoin = OclUndefined;
		tPathEnd : Urn!PathENd = OclUndefined;
	}
	do{
		if(sLastNode.oclIsTypeOf(Turn!Connect)){
			sLastNode <- sLastNode.connectsTo;
			tLastNode <- thisModule.retrieveNode(sLastNode);
		}
		
		tPathEnd <- thisModule.getPathEnd(sPathBody);
		
		if(sPathBody.meetsOrJoinConditions(tPathEnd)){
			tOrJoin <- thisModule.createOrJoin();
			thisModule.connect(tLastNode, tOrJoin);
			thisModule.createNewConnection(tOrJoin);
			tPathEnd.pred.first().target <- tOrJoin;
			tLastNode <- tOrJoin;
		}
		
		if(sPathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(thisModule.getPathEnd(sPathBody).succ -> isEmpty()){
				if(not thisModule.emptyPointMap.get(sPathBody.pathNodes.first()).oclIsUndefined()){
					tLastNode <- thisModule.emptyPointMap.get(sPathBody.pathNodes.first());
				}
			}
		}
		
		thisModule.connect(tLastNode, tPathEnd);
	}
}

rule connectWithEmptyPoint(tCurrentNode: Urn!PathNode, nextNode: Urn!PathNode){
	using{
		vEmptyPoint : Urn!EmptyPoint = OclUndefined;
	}
	do{
		vEmptyPoint <- thisModule.createEmptyPoint();
		thisModule.connect(tCurrentNode, vEmptyPoint);  -- currentNode -> vEmptyPoint
		thisModule.connect(tCurrentNode, nextNode);     -- currentNode -> nextNode
		thisModule.connect(vEmptyPoint, nextNode);      -- vEmptyPoint -> nextNode
		vEmptyPoint;
	}
}