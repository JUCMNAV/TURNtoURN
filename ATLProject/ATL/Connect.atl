module ConnectNodes;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- At present, this is behavior is also partially performed by
-- rules in the "Process.atl" file. Ideally, this behavior should
-- be limited to only rules in this file.

rule getNodeToConnect(body: Turn!PathBody){
	using{
		vNodeToConnect : Turn!PathNode = OclUndefined;
	}
	do{
		if(not body.pathEnd.oclIsUndefined()){
			vNodeToConnect <- thisModule.retrieveNode(body.pathEnd);	
		}
		else if(not body.referencedEnd.oclIsUndefined()){
			vNodeToConnect <- thisModule.retrieveNode(body.referencedEnd);
		}
		else if(not body.referencedStub.oclIsUndefined()){
			vNodeToConnect <- thisModule.retrieveNode(body.referencedStub);
		}
		
		vNodeToConnect;
	}
}

rule connectForkNodes(pathend: Turn!PathEnd, pathbodies: Sequence(Turn!PathBody)){
	using{
		vFork : Urn!PathNode = thisModule.retrieveNode(pathend);
	}
	do{
		for(pathbody in pathbodies){
			--thisModule.useConnection(thisModule.retrieveNode(pathend), thisModule.retrieveNode(pathend).nextFreeConnection());
			--if(vFork.oclIsTypeOf(Urn!OrFork)){
			--	thisModule.useConnection(vFork, thisModule.retrieveNode(pathend).nextFreeConnection());
			--}
			thisModule.connectNodes(pathbody, pathend, vFork);
			
			if(pathbody.referencedEnd.oclIsTypeOf(Turn!AndJoin) or pathbody.referencedEnd.oclIsTypeOf(Turn!OrJoin)){
				thisModule.useConnection(thisModule.retrieveNode(pathbody.referencedEnd), vFork.nextFreeConnection());
			}
			else if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect) and vFork.oclIsTypeOf(Urn!AndFork)){
				thisModule.useConnection(thisModule.retrieveNode(pathbody.pathEnd.regularEnd), vFork.nextFreeConnection());
			}
		}
	}
}

rule connectEndToNextNode(body: Turn!PathBody, nextNodeConnection: Turn!NodeConnection){
	using{
		vNodeToConnect : Turn!PathNode = thisModule.getNodeToConnect(body);
		vOrJoin : Urn!OrJoin = OclUndefined;	
	}
	do{
		if(not vNodeToConnect.oclIsUndefined()){
			if(vNodeToConnect.name='e17'){
				--thisModule.counter <- thisModule.counter + 1;
				--thisModule.debug(vRetrievedNode);
				--if(thisModule.counter = 2){
				--	thisModule.k.i;
				--}
			}
		}
		
		if(not nextNodeConnection.oclIsUndefined()){
			if(nextNodeConnection.source.oclIsTypeOf(Urn!EmptyPoint) or nextNodeConnection.source.oclIsTypeOf(Urn!Timer)){
				if(not thisModule.emptyPointMap.get(nextNodeConnection.source).oclIsUndefined()){
					nextNodeConnection.source <- thisModule.emptyPointMap.get(nextNodeConnection.source);
				}
			}
		}
		
		thisModule.handleEmptyBody(body, vNodeToConnect, nextNodeConnection);
	}
}

rule connectNodes(pathbody: Sequence(Turn!PathBody), node: Turn!PathNode, previousNode: Urn!PathNode){
	using{
		vLastNode : Turn!PathNode = pathbody.pathNodes -> last();
		vNode : Urn!PathNode = OclUndefined;
	}
	do{
		if(not pathbody.pathNodes -> isEmpty()){
			for(currentNode in pathbody.pathNodes){
				if(currentNode.oclIsTypeOf(Turn!Timer)){
					thisModule.processTimer(currentNode);
				}
				
				if(node.oclIsTypeOf(Turn!OrFork) and thisModule.retrieveNode(currentNode) = previousNode){
					thisModule.useConnection(previousNode, thisModule.retrieveNode(node).nextFreeConnection());
				}
				else{
					vNode <- thisModule.retrieveNode(currentNode);
					
					if(currentNode.oclIsTypeOf(Turn!Connect) or currentNode.oclIsTypeOf(Turn!WaitingPlace) or currentNode.oclIsTypeOf(Turn!Timer)){
						if(currentNode.oclIsTypeOf(Turn!Connect)){
							thisModule.createEmptyPointConnect(currentNode);
							vNode <- thisModule.retrieveNode(currentNode.connectsTo);
						--	thisModule.connect(previousNode, vNode); -- added an extra connection between the fork and the connectsTo object because this was needed in AndForkTestBranches and doesn't seem to change the appearance in AndFork
						}
						else if(currentNode.oclIsTypeOf(Turn!WaitingPlace)){
							if(not currentNode.connect.oclIsUndefined()){
								vNode <- thisModule.emptyPointMap.get(currentNode.connect);
							}
						}
						else if(currentNode.oclIsTypeOf(Turn!Timer)){
							if(not thisModule.emptyPointMap.get(thisModule.resolveTemp(currentNode, 'tTimer')).oclIsUndefined()){
								vNode <- thisModule.emptyPointMap.get(thisModule.resolveTemp(currentNode, 'tTimer'));
							}
						}
					}
					
					thisModule.useConnection(vNode, previousNode.nextFreeConnection());
				}
				
				if(currentNode.oclIsTypeOf(Turn!Connect)){
					currentNode <- currentNode.connectsTo;
				}

				previousNode <- thisModule.retrieveNode(currentNode);
			}
		
			if(vLastNode.oclIsTypeOf(Turn!Connect)){
				if(not vLastNode.connectsTo.oclIsTypeOf(Turn!Timer)){
					vLastNode <- vLastNode.connectsTo;
				}
				
				if(vLastNode.oclIsTypeOf(Turn!StartPoint) and pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
					thisModule.createNewConnection(thisModule.retrieveNode(vLastNode));
				}
			}
			
			if(thisModule.retrieveNode(vLastNode).nextFreeConnection().oclIsUndefined()){
				thisModule.connectEndToNextNode(pathbody, thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ep|not ep.nextFreeConnection().oclIsUndefined()).nextFreeConnection());
			}
			else{
				thisModule.connectEndToNextNode(pathbody, thisModule.retrieveNode(vLastNode).nextFreeConnection());
			}
		}
	}
}