module Connect;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- Handles exploration of nodes to find PathBodies and connect 
-- the appropriate parts.

rule connectComponentRefLongBoundElement(tFrom: String, tTo: String, tComponentRef: Urn!ComponentRef, nodes: Sequence(Urn!StartPoint)){
	using{
		tFromExists : Boolean = 
			(not nodes -> any(n|n.name = tFrom).oclIsUndefined())
			or (not nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.getRespName()=tFrom) -> isEmpty())
			and not (tFrom = '');
		tToExists : Boolean = 
			(not nodes -> any(n|n.name = tTo).oclIsUndefined())
			or (not nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.getRespName()=tTo) -> isEmpty())
			and not (tTo = '');
		tStartNode : Urn!PathNode = OclUndefined;
		tEndNode : Urn!PathNode = OclUndefined;
	}
	do{
		if(tFromExists and tToExists){ --unidirectional, tFrom must be before tTo
			tStartNode <- nodes -> any(n|n.name = tFrom);

			if(tStartNode.oclIsUndefined()){
				tStartNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.getRespName()=tFrom);
			}
			
			tEndNode <- nodes -> any(n|n.name=tTo);
			
			if(tEndNode.oclIsUndefined()){
				tEndNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.getRespName()=tTo);
			}
			
			tComponentRef.nodes <- thisModule.findPathBetweenNodes(tStartNode, tEndNode);
		}
	}
}

rule connectBodyNodes(sPathNodes: Sequence(Turn!PathBodyNode), tPathStart: Urn!PathNode){
	using{
		tNode : Urn!PathNode = OclUndefined;
		tPreviousNode : Urn!PathNode = tPathStart;
	}
	do{
		for(sCurrentNode in sPathNodes){
			if(sCurrentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.initTimer(sCurrentNode);
			}
			
			tNode <- thisModule.retrieveNode(sCurrentNode);
			thisModule.directConnect(tPreviousNode, tNode);
			tPreviousNode <- tNode;
		}
		
		tPreviousNode;
	}
}

rule newConnectPathEnd(sPathEnd: Turn!PathBodyNode){
	using{
		tPathEnd : Urn!PathNode = OclUndefined;
	}
	do{
		if(sPathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(sPathEnd.regularEnd.oclIsUndefined()){
				tPathEnd <- thisModule.createEndPoint();
				thisModule.endPointMap <- thisModule.endPointMap.including(sPathEnd.regularEnd, tPathEnd);
			}
			else if(thisModule.retrieveNode(sPathEnd.regularEnd).oclIsUndefined()){
				tPathEnd <- thisModule.createEndPoint();
				thisModule.initEndPointUsingEndpointWithConnect(tPathEnd, sPathEnd);
				thisModule.endPointMap <- thisModule.endPointMap.including(sPathEnd.regularEnd, tPathEnd);
			}
			else{
				tPathEnd <- thisModule.retrieveNode(sPathEnd.regularEnd);
			}
		}
		else if(sPathEnd.oclIsTypeOf(Turn!AndFork)){
			thisModule.newConnectAndFork(sPathEnd);
		}
		else if(sPathEnd.oclIsTypeOf(Turn!OrFork)){
			thisModule.newConnectOrFork(sPathEnd);
		}
		else if(sPathEnd.oclIsTypeOf(Turn!Stub)){
			thisModule.initStub(sPathEnd);
			thisModule.newConnectStub(sPathEnd);
		}
		else{
			-- PathEnd is undefined
		}

		tPathEnd;
	}
}

rule newDoConnect(sPathBody: Urn!PathBody, tStartNode : Urn!PathNode, tAlternatePathEnd : Urn!PathNode){
	using{
		tPathEnd : Urn!PathNode = tAlternatePathEnd;
		sPathEnd : Turn!PathBodyNode = sPathBody.pathEnd;
		tLastNode : Urn!PathNode = OclUndefined;
	}
	do{
		thisModule.collectPathBodyNodes(sPathBody);
		
		tLastNode <- thisModule.connectBodyNodes(sPathBody.pathNodes, tStartNode);
		tPathEnd <- thisModule.newConnectPathEnd(sPathBody.pathEnd);
		
		if(tPathEnd.oclIsUndefined()){
			tPathEnd <- thisModule.getPathEnd(sPathBody);
			
			if(tLastNode=tStartNode){
				thisModule.connect(tPathEnd, tAlternatePathEnd);
			}
			
			if(tPathEnd.oclIsUndefined()){
				tPathEnd <- tAlternatePathEnd;
			}
			
			if(not tPathEnd.oclIsUndefined()){
				if(sPathBody.index > tPathEnd.pred -> size()){
					thisModule.stubIndexMap <- thisModule.stubIndexMap.including(sPathBody.index, Sequence{tLastNode, tPathEnd}); --this approach won't work if an index is used more than once!
				}
				else{
					thisModule.connect(tLastNode, tPathEnd);
				}
			}
		}
		else{
			thisModule.connect(tLastNode, tPathEnd);
		}		
	}
}

rule newConnectAndFork(sAndFork: Turn!AndFork){
	using{
		tAndFork : Urn!AndFork = thisModule.retrieveNode(sAndFork);
		vNumberOfNonTerminatingNodes : Integer = sAndFork.pathbody -> select(pb|not thisModule.getPathEnd(pb).oclIsTypeOf(Urn!EndPoint)) -> size();
		tAndJoin : Urn!AndJoin = 
			if(sAndFork.connectingAndBody.oclIsUndefined() or vNumberOfNonTerminatingNodes < 2) then
				OclUndefined
			else
				thisModule.createAndJoin()
			endif;
		tPathEnd : Urn!PathNode = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
	}
	do{
		for(sPathBody in sAndFork.pathbody){
			thisModule.newDoConnect(sPathBody, tAndFork, tAndJoin);
		}
		
		if(not sAndFork.connectingAndBody.oclIsUndefined()){
			if(tAndJoin.oclIsUndefined()){
				thisModule.newDoConnect(sAndFork.connectingAndBody, tAndFork, OclUndefined);
			}
			else{
				thisModule.newDoConnect(sAndFork.connectingAndBody, tAndJoin, OclUndefined);
			}
		}
	}
}

rule newConnectOrFork(sOrFork: Turn!OrFork){
	using{
		tOrFork : Urn!OrFork = thisModule.retrieveNode(sOrFork);
		vNumberOfNonTerminatingNodes : Integer = 
			if(sOrFork.body.oclIsUndefined()) then
				0
			else 
				sOrFork.body.regularBody -> select(rb|not thisModule.getPathEnd(rb.pathBody).oclIsTypeOf(Urn!EndPoint)) -> size()
			endif;
		tOrJoin : Urn!OrJoin = 
			if(sOrFork.connectingOrBody.oclIsUndefined() or vNumberOfNonTerminatingNodes < 2) then
				OclUndefined
			else
				 thisModule.createOrJoin()
			endif;
		tPathEnd : Urn!PathNode = OclUndefined;
	}
	do{
		if(not sOrFork.body.oclIsUndefined()){
			for(sPathBody in sOrFork.body.regularBody -> collect(rb|rb.pathBody)){
				thisModule.newDoConnect(sPathBody, tOrFork, tOrJoin);
			}
			
			if(not sOrFork.body.elseBody.oclIsUndefined()){
				thisModule.newDoConnect(sOrFork.body.elseBody, tOrFork, tOrJoin);
			}
		}
		
		if(not sOrFork.connectingOrBody.oclIsUndefined()){
			if(tOrJoin.oclIsUndefined()){
				thisModule.newDoConnect(sOrFork.connectingOrBody, tOrFork, OclUndefined);
			}
			else{
				thisModule.newDoConnect(sOrFork.connectingOrBody, tOrJoin, OclUndefined);
			}
		}
	}
}

rule newConnectStub(sStub: Turn!Stub){
	using{
		tStub : Urn!Stub = thisModule.retrieveNode(sStub);
		vNumberOfNonTerminatingNodes : Integer = sStub.outPaths -> collect(op|op.path) -> select(p|not thisModule.getPathEnd(p).oclIsTypeOf(Urn!EndPoint)) -> size();
		tOrJoin : Urn!OrJoin = 
			if(sStub.connectingStubBody.oclIsUndefined() or vNumberOfNonTerminatingNodes < 2) then
				OclUndefined
			else
				thisModule.createOrJoin()
			endif;
		tPathEnd : Urn!PathNode = OclUndefined;
	}
	do{
		for(sPathBody in sStub.outPaths -> collect(op|op.path)){
			thisModule.newDoConnect(sPathBody, tStub, tOrJoin);
		}

		if(not sStub.connectingStubBody.oclIsUndefined()){
			if(tOrJoin.oclIsUndefined()){
				thisModule.newDoConnect(sStub.connectingStubBody, tStub, OclUndefined);
			}
			else{
				thisModule.newDoConnect(sStub.connectingStubBody, tOrJoin, OclUndefined);
			}
		}
	}
}

-- Connects paths for all the stubs with indeces. These are added to stubIndexMap at an earlier
-- stage of the code and left there to be considered last.
rule connectPathBodiesWithIndexes(){
	using{
		tStub : Urn!Stub = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
		tOrJoin : Urn!OrJoin = OclUndefined;
	}
	do{
		for(vIndex in thisModule.stubIndexMap.keySet()){
			tLastNode <- thisModule.stubIndexMap.get(vIndex).first();
			tStub <- thisModule.stubIndexMap.get(vIndex).last();

			if(vIndex <= tStub.pred -> size()){
				tOrJoin <- thisModule.createOrJoin();
				tStub.pred -> at(vIndex).target <- tOrJoin; --TODO: iterate over all of the pred
				thisModule.directConnect(tLastNode, tOrJoin);
				thisModule.directConnect(tOrJoin, tStub);
			}
			else{
				thisModule.directConnect(tLastNode, tStub);
			}
		}
		
		thisModule.stubIndexMap <- Map{};
	}
}

-- Sets orFork node conditions. Called after connectPathBodiesWithIndexes so that all connections are in place when this is done.
-- Is rather inefficient as it calls allInstances(); this approach can potentially be improved upon.
rule setOrForkConditions(){
	using{
		vCounter : Integer = 1;
		sOrFork : Turn!OrFork = OclUndefined;
	}
	do{
		for(tOrFork in thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!OrFork))){
			sOrFork <- Turn!OrFork.allInstances() -> any(n|thisModule.resolveTemp(n, 'tOrFork')=tOrFork);
			
			if(not sOrFork.body.oclIsUndefined()){
				for(sRegularOrFork in sOrFork.body.regularBody){
					tOrFork.succ -> at(vCounter).condition <- thisModule.resolveTemp(sRegularOrFork.condition, 'tCondition');
					vCounter <- vCounter + 1;
				}
				
				if(not sOrFork.body.elseBody.oclIsUndefined()){
					tOrFork.succ.last().condition <- thisModule.createCondition('else');
				}
			}
			
			vCounter <- 1;
		}
	}
}

-- Sets stub connection thresholds. Called after connectPathBodiesWithIndexes so that all connections are in place when this is done.
-- Is rather inefficient as it calls allInstances(); this approach can potentially be improved upon.
rule setStubThresholds(){
	using{
		vCounter : Integer = 1;
		sStub : Turn!Stub = OclUndefined;
	}
	do{
		for(tStub in thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!Stub))){
			sStub <- Turn!Stub.allInstances() -> any(n|thisModule.resolveTemp(n, 'tStub')=tStub);
			
			if(sStub.oclIsUndefined()){
				-- Declared using StubDeclaration, no outPaths
			}
			else{
				for(sOutPath in sStub.outPaths){
					if(sOutPath.threshold <> 0){
						tStub.succ.last().threshold <- sOutPath.threshold.toString();
					}
					
					vCounter <- vCounter + 1;
				}
			}
		}
	}
}

rule connectUCMmap(tUCMmap: Urn!UCMmap, paths: Sequence(Turn!Path)){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;
	}
	do{
		thisModule.tUCMmap <- tUCMmap;

		for(sPath in paths){
			if(sPath.startPoint.oclIsUndefined()){
				tStartPoint <- thisModule.createStartPoint();
			}
			else{
				tStartPoint <- thisModule.retrieveNode(sPath.startPoint);
			}
			
			thisModule.newDoConnect(sPath.pathBody, tStartPoint, OclUndefined);
		}
		
		-- I don't like the approach I've used below. The reason I have to do it as such is
		-- because Stubs need to be processed last so that all other elements in the path have
		-- been handled once they are considered (due to the fact stubs have indexes referencing)
		-- specific connections). There is probably a cleaner way to do this.
		thisModule.connectPathBodiesWithIndexes();
		thisModule.setOrForkConditions();
		thisModule.setStubThresholds();
		
		tUCMmap.connections <- tUCMmap.nodes -> flatten() -> collect(of|of.succ) -> flatten();
	}
}