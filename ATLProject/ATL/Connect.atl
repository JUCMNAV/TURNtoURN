-------------------------------------
-- TURN2URN
-------------------------------------
-- Author: Ruchika Kumar, 2016
-------------------------------------
-- Edited by: Saahil Hamayun, 2019
-------------------------------------

module Connect;

create OUT : Urn from IN : Turn;

------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------
--	File: Connect.atl
-------------------------------------------------------------------------------------------------------------------------------
--	Description:
--  	Contains all rules used to handle connections between nodes.
--  	Handles exploration of nodes to find PathBodies and connect their nodes.
-------------------------------------------------------------------------------------------------------------------------------
--	Contents:
--      * rule connectUCMmap(tUCMmap: Urn!UCMmap, paths: Sequence(Turn!Path))
--      * rule connectPathBody(sPathBody: Urn!PathBody, tStartNode: Urn!PathNode, tAlternatePathEnd: Urn!PathNode)
--      * rule connectPathBodyNodes(tStartNode: Urn!PathNode, sPathNodes: Sequence(Turn!PathNode))
--      * rule connectLastNodeToPathEnd(sPathBody: Turn!PathBody, tLastNode: Urn!PathNode, tAlternatePathEnd: Urn!PathNode)
--      * rule connectPathEnd(sPathEnd: Turn!PathEnd, tAlternatePathEnd: Urn!PathEnd)
--      * rule connectPathEndPathBodies(sNode: Turn!PathBodyNode, sPathBodies: Sequence(Turn!PathBody),
--										sConnectingBody: Turn!PathBody, tNextConnectingNode : Urn!PathNode)
--		* rule connectIndexedPathBodies()
--      * rule setOrForkConditionsAndCreateAlternateBranches()
--      * rule setStubThresholds()
-------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------

-- All node connection is done through this rule.
-- It is called on each UCMmap in URNspec2URNspec.
rule connectUCMmap(tUCMmap: Urn!UCMmap, paths: Sequence(Turn!Path)){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;
	}
	do{
		thisModule.tUCMmap <- tUCMmap;

		for(sPath in paths){
			tStartPoint <- thisModule.getOrCreateStartPoint(sPath.startPoint);
			thisModule.connectPathBody(sPath.pathBody, tStartPoint, OclUndefined);
		}
		
		thisModule.connectIndexedPathBodies();
		thisModule.setOrForkConditionsAndCreateAlternateBranches();
		thisModule.setStubThresholds();
		
		tUCMmap.connections <- tUCMmap.nodes -> flatten() -> collect(of|of.succ) -> flatten();
	}
}

-- Connects a pathbody as such: startNode -> (pathNodes)* -> pathEnd (-> more nodes if pathEnd is not endPoint)*
-- If no pathEnd is found, uses the input alternate pathend. Lastly calls to connect the pathEnd, extending the 
-- total number of nodes to include those that follow the pathEnd. 
rule connectPathBody(sPathBody: Urn!PathBody, tStartNode: Urn!PathNode, tAlternatePathEnd: Urn!PathNode){
	using{
		tLastNode : Urn!PathNode = tStartNode;
	}
	do{
		thisModule.collectPathBodyNodesAndEnds(sPathBody);
		tLastNode <- thisModule.connectPathBodyNodes(tStartNode, sPathBody.pathNodes);
		thisModule.connectLastNodeToPathEnd(sPathBody, tLastNode, tAlternatePathEnd);			
		thisModule.connectPathEnd(sPathBody.pathEnd, tAlternatePathEnd);
		
		tAlternatePathEnd;
	}
}

-- Connects tStartNode to the first Urn node corresponding to nodes in sPathNodes,
-- then connects the nodes in sPathNodes sequentially. Returns the last node in
-- this chain (if sPathNodes is empty, this is tStartNode).
rule connectPathBodyNodes(tStartNode: Urn!PathNode, sPathNodes: Sequence(Turn!PathNode)){
	using{
		tCurrentNode : Urn!PathNode = OclUndefined;
		tConnect : Urn!Connect = OclUndefined;
		tEmptyPoint : Urn!EmptyPoint = OclUndefined;
		tLastNode : Urn!PathNode = tStartNode;	
	}
	do{
		for(sCurrentNode in sPathNodes){
			if(sCurrentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.initTimer(sCurrentNode);
			}
			
			if(sCurrentNode.oclIsTypeOf(Turn!Connect)){
				tConnect <- thisModule.resolveTemp(sCurrentNode, 'tConnect');
				thisModule.connect(tConnect, thisModule.getTargetNode(sCurrentNode.connectsTo));
				tCurrentNode <- thisModule.getTargetNode(sCurrentNode.connectsTo);
			}
			--else if(sCurrentNode.oclIsTypeOf(Turn!WaitingPlace) or sCurrentNode.oclIsTypeOf(Turn!Timer)) {
			--	tCurrentNode <- thisModule.getTargetNode(sCurrentNode);
			--	if (tCurrentNode.id = '128' or tCurrentNode.id='97') {
			--		tConnect <- (tCurrentNode.pred -> select(pred|pred.source.oclIsTypeOf(Urn!Connect)) -> first()).source;
			--		tEmptyPoint <- (tConnect.pred -> first()).source;
			--		thisModule.debug(tEmptyPoint);	
			--	}
			--	-- TODO: handle asynchronous start points sCurrentNode.oclIsTypeOf(Turn!StartPoint)
			--}
			else {
				tCurrentNode <- thisModule.getTargetNode(sCurrentNode);
			}
			
			thisModule.connect(tLastNode, tCurrentNode);
			tLastNode <- tCurrentNode;
		}
		
		tLastNode;
	}
}

-- Connects the input last node to the pathEnd of sPathBody. If the pathbody has an index that is non-zero, adds it
-- to the stub index map to be handled later.
rule connectLastNodeToPathEnd(sPathBody: Turn!PathBody, tLastNode: Urn!PathNode, tAlternatePathEnd: Urn!PathNode){
	using{
		tPathEnd : Urn!PathNode = OclUndefined;
	}
	do{
		tPathEnd <- thisModule.getOrCreatePathEnd(sPathBody);
			
		if(not tPathEnd.isDefined()){
			tPathEnd <- tAlternatePathEnd;
		}
		
		if(not tPathEnd.isDefined()){
			-- No path end found. Occurs for ending of nested and/or joins. Will be connected with parent's join.
		}
		else if(sPathBody.index > 0){
			-- To handle pathbody connection using indexes, we store in the index map for now.
			-- These connections will be processed after the rest of the UCMmap is done.
			thisModule.addConnectionToStubIndexMap(tLastNode, tPathEnd, sPathBody.index);
		}
		else{
			thisModule.connect(tLastNode, tPathEnd);
		}	
	}
}

-- Connects the nodes of the input pathEnd, resulting in the pathEnd being connected to all its pathbodies. 
-- Results in a connection as such: inputPathEnd -> (firstPathBodyNodes)  ->   pathEndOfPathEnd
--                                               -> (secondPathBodyNodes) ->
--                                               -> (nthPathBodyNodes)    ->
-- or simply as inputPathEnd -> pathEndOfPathEnd when no pathBodies.
rule connectPathEnd(sPathEnd: Turn!PathEnd, tAlternatePathEnd: Urn!PathEnd){
	do{
		if(sPathEnd.oclIsTypeOf(Turn!EndpointWithConnect) or not sPathEnd.isDefined()){
			-- Do nothing as we do not need to connect this PathEnd.
		}
		else{
			-- sPathEnd will be a OrFork, AndFork, or Stub
			thisModule.connectPathEndPathBodies(sPathEnd, sPathEnd.getPathBodies(), 
												sPathEnd.getConnectingBody(), tAlternatePathEnd);
		}
	}
}

-- This goes over the pathEnd, connecting its various pathbodies,
-- which is equivalent to saying this connects that pathEnd.
rule connectPathEndPathBodies(sNode: Turn!PathBodyNode, sPathBodies: Sequence(Turn!PathBody), 
							  sConnectingBody: Turn!PathBody, tNextConnectingNode : Urn!PathNode){
	using{
		tNode: Urn!PathNode = thisModule.getTargetNode(sNode);
		vNumberOfNonTerminatingNodes : Integer = sPathBodies -> select(pb|pb.isDefined()) 
															 -> select(pb|not thisModule.getOrCreatePathEnd(pb).oclIsTypeOf(Urn!EndPoint)) 
															 -> size();
		tLastNode : Urn!PathNode = 
			if(not sConnectingBody.isDefined() or vNumberOfNonTerminatingNodes < 2) then
				OclUndefined
			else
				if(sNode.oclIsTypeOf(Turn!AndFork)) then
					thisModule.createAndJoin()
				else
					thisModule.createOrJoin()
				endif
			endif;
	}
	do{
		for(sPathBody in sPathBodies -> select(pb|pb.isDefined())){
			-- Connect tNode to each sPathBody in sPathBodies, and connect the end of
			-- each sPathBody to tLastNode.
			thisModule.connectPathBody(sPathBody, tNode, tLastNode);
		}
		
		if(not tLastNode.isDefined()){
			-- If tLastNode isn't defined, we're in a case where we didn't need a join.
			-- Then, our LastNode is actually still our first node, which is tNode.
			tLastNode <- tNode;
		}
		
		if(sConnectingBody.isDefined()){
			-- Connect our LastNode to the pathbody of sConnectingBody, and connect the
			-- last node of sConnectingBody to tNextConnectingNode.
			thisModule.connectPathBody(sConnectingBody, tLastNode, tNextConnectingNode);
		}
	}
}

-- Connects paths for all the pathbodies that had indexes. This only happens in the case of stubs.
rule connectIndexedPathBodies(){
	using{
		tStub : Urn!Stub = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
	}
	do{
		-- StubIndexMap has node pairs to be connected and the index to connect them at.
		-- We added these pairs to stubIndexMap in connectLastNodeToPathEnd.
		for(vPredIndex in thisModule.stubIndexMap.keySet()){
			for(tNodesToConnect in thisModule.stubIndexMap.get(vPredIndex)){
				tLastNode <- tNodesToConnect.first();
				tStub <- tNodesToConnect.last();
				
				thisModule.connectAtTargetIndex(tLastNode, tStub, vPredIndex);
			}
		}
		
		thisModule.stubIndexMap <- Map{};
	}
}

-- Sets orFork node conditions. Called after connectPathBodiesWithIndexes so that all connections are in place when this is done.
-- This is rather inefficient as it calls allInstances(); I feel this approach can potentially be improved upon.
rule setOrForkConditionsAndCreateAlternateBranches(){
	using{
		vCounter : Integer = 1;
		sOrFork : Turn!OrFork = OclUndefined;
	}
	do{
		for(tOrFork in thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!OrFork))){
			sOrFork <- Turn!OrFork.allInstances() -> any(n|thisModule.resolveTemp(n, 'tOrFork')=tOrFork);
			
			-- Only happens in cases where only a condition is provided.
			if(sOrFork.condition.isDefined()){
				tOrFork.succ.first().condition <- thisModule.resolveTemp(sOrFork.condition, 'tCondition');
				thisModule.connect(tOrFork, thisModule.createEndPoint());
				tOrFork.succ -> at(2).condition <- thisModule.createCondition('!' + sOrFork.condition.expression.asString());
				
			}
			
			if(sOrFork.body.isDefined()){
				for(sRegularOrFork in sOrFork.body.regularBody){
					-- As we created the connections sequentially with respect to their order in the regularBody, 
					-- setting their conditions with respect to the order in the regularBody is fine.
					tOrFork.succ -> at(vCounter).condition <- thisModule.resolveTemp(sRegularOrFork.condition, 'tCondition');
					vCounter <- vCounter + 1;
				}
				
				if(sOrFork.body.elseBody.isDefined()){
					tOrFork.succ.last().condition <- thisModule.createCondition('else');
				}
				else if(sOrFork.body.regularBody -> size() = 1){
					-- If the body only had one connection, we create a second EndPoint equivalent to the 'not' of the condition of that
					-- element to more clearly show the control flow.
					thisModule.connect(tOrFork, thisModule.createEndPoint());
					tOrFork.succ -> at(2).condition <- thisModule.createCondition('!' + 
															sOrFork.body.regularBody.first().condition.expression.asString());
				}
			}
			
			vCounter <- 1;
		}
	}
}

-- Sets stub connection thresholds. Called after connectPathBodiesWithIndexes so that all connections are in place when this is done.
-- This is rather inefficient as it calls allInstances(); I feel this approach can potentially be improved upon.
rule setStubThresholds(){
	using{
		vCounter : Integer = 1;
		sStub : Turn!Stub = OclUndefined;
	}
	do{
		for(tStub in thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!Stub))){
			sStub <- Turn!Stub.allInstances() -> any(n|thisModule.resolveTemp(n, 'tStub')=tStub);
			
			if(sStub.isDefined()){
				for(sOutPath in sStub.outPaths){
					if(sOutPath.threshold <> 0){
						tStub.succ.first().threshold <- sOutPath.threshold.toString();
					}
					
					vCounter <- vCounter + 1;
				}
			}
			else{
				-- Declared using StubDeclaration, no outPaths
			}
		}
	}
}