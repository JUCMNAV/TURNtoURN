module Connect;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- Handles exploration of nodes to find PathBodies and connect 
-- the appropriate parts.

rule connectBodyNodes(sPathNodes: Sequence(Turn!PathBodyNode), tPathStart: Urn!PathNode){
	using{
		tNode : Urn!PathNode = OclUndefined;
		tPreviousNode : Urn!PathNode = tPathStart;
	}
	do{
		for(sCurrentNode in sPathNodes){
			if(sCurrentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.initTimer(sCurrentNode);
			}
			
			tNode <- thisModule.retrieveNode(sCurrentNode);
			thisModule.directConnect(tPreviousNode, tNode);
			tPreviousNode <- tNode;
		}
		
		tPreviousNode;
	}
}

rule connectEndpointWithConnect(sEndpointWithConnect: Turn!EndpointWithConnect){
	using{
		tEndPoint : Urn!EndPoint = OclUndefined;
	}
	do{
		if(sEndpointWithConnect.regularEnd.oclIsUndefined()){
			tEndPoint <- thisModule.createEndPoint();
		}
		else if(thisModule.retrieveNode(sEndpointWithConnect.regularEnd).oclIsUndefined()){
			tEndPoint <- thisModule.createEndPoint();
			thisModule.initEndPointUsingEndpointWithConnect(tEndPoint, sEndpointWithConnect);
		}
		else{
			-- EndPoint already exists
		}
		
		if(not tEndPoint.oclIsUndefined()){
			thisModule.endPointMap <- thisModule.endPointMap.including(sEndpointWithConnect.regularEnd, tEndPoint);
		}
		
		-- Return the Urn!EndPoint created using the Turn!EndpointWithConnect
		tEndPoint;
	}
}

rule connectAndFork(sAndFork: Turn!AndFork){
	using{
		tAndFork : Urn!AndFork = thisModule.retrieveNode(sAndFork);
		tAndJoin : Urn!AndJoin = OclUndefined;
		tPathEnd : Urn!PathNode = OclUndefined;
	}
	do{
		if(not sAndFork.connectingAndBody.oclIsUndefined()){
			tAndJoin <- thisModule.createAndJoin();
		}
		
		thisModule.doConnect(sAndFork.pathbody, tAndFork, tAndJoin);
		
		if(not sAndFork.connectingAndBody.oclIsUndefined()){
			tPathEnd <- thisModule.connectPathBody(sAndFork.connectingAndBody, tAndJoin);
		}
		
		-- Return the final node in the AndFork path or the first node of the following path.
		tPathEnd;
	}
}

rule connectOrFork(sOrFork: Turn!OrFork){
	using{
		tOrFork : Urn!OrFork = thisModule.retrieveNode(sOrFork);
		tOrJoin : Urn!OrJoin = OclUndefined;
		tPathEnd : Urn!PathNode = OclUndefined;
		vCounter : Integer = 1;
	}
	do{
		if(not sOrFork.connectingOrBody.oclIsUndefined()){
			tOrJoin <- thisModule.createOrJoin();
		}
		
		if(not sOrFork.body.oclIsUndefined()){
			thisModule.doConnect(sOrFork.body.regularBody -> collect(rb|rb.pathBody), tOrFork, tOrJoin);
			
			for(regularOrFork in sOrFork.body.regularBody){
				tOrFork.succ -> at(vCounter).condition <- thisModule.resolveTemp(regularOrFork.condition, 'tCondition');
				vCounter <- vCounter + 1;
			}
			
			if(not sOrFork.body.elseBody.oclIsUndefined()){
				thisModule.doConnect(Sequence { sOrFork.body.elseBody }, tOrFork, tOrJoin);
				tOrFork.succ.last().condition <- thisModule.createCondition('else');
			}
		}
		
		if(not sOrFork.connectingOrBody.oclIsUndefined()){
			tPathEnd <- thisModule.connectPathBody(sOrFork.connectingOrBody, tOrJoin);
		}
		
		-- Return the final node in the OrFork path or the first node of the following path.
		tPathEnd;	
	}
}

rule connectStub(sStub: Turn!Stub){
	using{
		tStub : Urn!Stub = thisModule.retrieveNode(sStub);
		tOrJoin : Urn!OrJoin = OclUndefined;
		tPathEnd : Urn!PathNode = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
		vCounter : Integer = 1;
	}
	do{
		thisModule.initStub(sStub);
		
		if(not sStub.connectingStubBody.oclIsUndefined()){
			tOrJoin <- thisModule.createOrJoin();
		}
		
		thisModule.doConnect(sStub.outPaths -> collect(op|op.path), tStub, tOrJoin);
		
		for(sOutPath in sStub.outPaths){
			if(sOutPath.threshold <> 0){
				tStub.succ.last().threshold <- sOutPath.threshold.toString();
			}
			
			vCounter <- vCounter + 1;
		}

		if(not sStub.connectingStubBody.oclIsUndefined()){
			if(sStub.outPaths -> isEmpty()){
				tLastNode <- thisModule.createEmptyPoint();
				thisModule.connect(tStub, tLastNode);
				thisModule.connect(tLastNode, tOrJoin);
			}
			
			tPathEnd <- thisModule.connectPathBody(sStub.connectingStubBody, tOrJoin);
		}
		
		-- Return the final node in the OrFork path or the first node of the following path.
		tPathEnd;	
	}
}

rule doConnect(sPathBodies : Sequence(Urn!PathBody), tStartNode : Urn!PathNode, tEnd : Urn!OrJoin){
	using{
		tPathEnd : Urn!PathNode = OclUndefined;
		tOrJoin : Urn!OrJoin = OclUndefined;
		tEmptyPoint : Urn!EmptyPoint = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
	}
	do{
		for(sPathBody in sPathBodies){
			thisModule.collectPathBodyNodes(sPathBody);
			
			tLastNode <- thisModule.connectBodyNodes(sPathBody.pathNodes, tStartNode);
			tPathEnd <- thisModule.connectPathEnd(sPathBody.pathEnd);
			
			if(tPathEnd.oclIsTypeOf(Urn!EmptyPoint)){
				thisModule.connect(tPathEnd, tEnd);
			}
			
			tPathEnd <- thisModule.getPathEnd(sPathBody);
			
			if(sPathBody.pathNodes -> isEmpty() and not tStartNode.succ -> any(s|s.target=tPathEnd).oclIsUndefined()){
				tOrJoin <- thisModule.createOrJoin();
				
				tEmptyPoint <- thisModule.createEmptyPoint();
				tStartNode.succ -> any(s|s.target=tPathEnd).target <- tEmptyPoint;
				thisModule.directConnect(tEmptyPoint, tOrJoin);
				
				tEmptyPoint <- thisModule.createEmptyPoint();
				thisModule.directConnect(tStartNode, tEmptyPoint);
				thisModule.directConnect(tEmptyPoint, tOrJoin);
				
				tLastNode <- tOrJoin;
			}

			thisModule.connect(tLastNode, tPathEnd);
			
			if(tPathEnd.oclIsTypeOf(Urn!EmptyPoint)){
				thisModule.connect(tPathEnd, tEnd);
			}
		}
	}
}

rule connectPathBody(sPathBody: Turn!PathBody, tPathStart: Urn!PathNode){
	using{
		tFirstNodeOfPathEnd : Urn!PathNode = OclUndefined;
		tLastNodeOfPathBody : Urn!PathNode = OclUndefined;
	}
	do{
		thisModule.collectPathBodyNodes(sPathBody);
		
		tLastNodeOfPathBody <- thisModule.connectBodyNodes(sPathBody.pathNodes, tPathStart);
		thisModule.connectPathEnd(sPathBody.pathEnd);
		
		tFirstNodeOfPathEnd <- thisModule.getPathEnd(sPathBody);
		thisModule.connect(tLastNodeOfPathBody, tFirstNodeOfPathEnd);
		
		tFirstNodeOfPathEnd;
	}
}

rule connectPathEnd(sPathEnd: Turn!PathBodyNode){
	using{
		tPathEnd : Urn!PathNode = OclUndefined;
	}
	do{
		if(sPathEnd.oclIsTypeOf(Turn!AndFork)){
			tPathEnd <- thisModule.connectAndFork(sPathEnd);
		}
		else if(sPathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			tPathEnd <- thisModule.connectEndpointWithConnect(sPathEnd);
		}
		else if(sPathEnd.oclIsTypeOf(Turn!OrFork)){
			tPathEnd <- thisModule.connectOrFork(sPathEnd);
		}
		else if(sPathEnd.oclIsTypeOf(Turn!Stub)){
			tPathEnd <- thisModule.connectStub(sPathEnd);
		}
		else{
			-- PathEnd is undefined
		}

		tPathEnd;
	}
}

rule connectUCMmap(tUCMmap: Urn!UCMmap, paths: Sequence(Turn!Path)){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;	
	}
	do{
		thisModule.tUCMmap <- tUCMmap;

		for(sPath in paths){
			if(sPath.startPoint.oclIsUndefined()){
				tStartPoint <- thisModule.createStartPoint();
			}
			else{
				tStartPoint <- thisModule.retrieveNode(sPath.startPoint);
			}
			
			thisModule.connectPathBody(sPath.pathBody, tStartPoint);
		}
		
		tUCMmap.connections <- tUCMmap.nodes -> flatten() -> collect(of|of.succ) -> flatten();	
	}
}