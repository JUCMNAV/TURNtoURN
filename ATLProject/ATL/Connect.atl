module Connect;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- Handles exploration of nodes to find PathBodies and connect 
-- the appropriate parts.

rule connectUCMmap(tUCMmap: Urn!UCMmap, paths: Sequence(Turn!Path)){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;
	}
	do{
		thisModule.tUCMmap <- tUCMmap;

		for(sPath in paths){
			if(sPath.startPoint.isDefined()){
				tStartPoint <- thisModule.retrieveNode(sPath.startPoint);
			}
			else{
				tStartPoint <- thisModule.createStartPoint();
			}
			
			thisModule.connectPathBody(sPath.pathBody, tStartPoint, OclUndefined);
		}
		
		-- I don't like the approach I've used below. The reason I have to do it as such is
		-- because Stubs need to be processed last so that all other elements in the path have
		-- been handled once they are considered (due to the fact stubs have indexes referencing)
		-- specific connections). There is probably a cleaner way to do this.
		thisModule.connectIndexedPathBodies();
		thisModule.setOrForkConditionsAndCreateAlternateBranches();
		thisModule.setStubThresholds();
		
		tUCMmap.connections <- tUCMmap.nodes -> flatten() -> collect(of|of.succ) -> flatten();
	}
}

rule connectPathBody(sPathBody: Urn!PathBody, tStartNode: Urn!PathNode, tAlternatePathEnd: Urn!PathNode){
	using{
		tCurrentNode : Urn!PathNode = OclUndefined;
		tLastNode : Urn!PathNode = tStartNode;
		sPathEnd : Urn!PathEnd = OclUndefined;
		tPathEnd : Urn!PathNode = tAlternatePathEnd;
	}
	do{
		if(sPathBody.isDefined()){
			thisModule.collectPathBodyNodesAndEnds(sPathBody);
			tLastNode <- thisModule.connectPathBodyNodes(tStartNode, sPathBody.pathNodes);
			thisModule.connectLastNodeToPathEnd(tLastNode, sPathBody, tAlternatePathEnd);			
			thisModule.doConnectForPathEnd(sPathBody.pathEnd, tAlternatePathEnd);
		}
		
		tPathEnd;
	}
}

rule connectPathBodyNodes(tStartNode : Urn!PathNode, sPathNodes : Sequence(Turn!PathNode)){
	using{
		tCurrentNode : Urn!PathNode = OclUndefined;
		tLastNode : Urn!PathNode = tStartNode;	
	}
	do{
		for(sCurrentNode in sPathNodes){
			if(sCurrentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.initTimer(sCurrentNode);
			}
			
			tCurrentNode <- thisModule.retrieveNode(sCurrentNode);
			thisModule.directConnect(tLastNode, tCurrentNode);
			tLastNode <- tCurrentNode;
		}
		
		tLastNode;
	}
}

rule connectLastNodeToPathEnd(tLastNode: Urn!PathNode, sPathBody: Turn!PathBody, tAlternatePathEnd: Urn!PathNode){
	using{
		sPathEnd : Turn!PathBodyNode = sPathBody.pathEnd;
		tPathEnd : Urn!PathNode = OclUndefined;
	}
	do{
		if(sPathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			tPathEnd <- thisModule.getOrCreateEndPoint(sPathEnd);
		}
		else{
			tPathEnd <- thisModule.getPathEnd(sPathBody);
		}
			
		if(not tPathEnd.isDefined()){
			tPathEnd <- tAlternatePathEnd;
		}
		
		if(not tPathEnd.isDefined()){
			-- No path end found - occurs for ending of nested and/or joins. Will be connected with parent's join.
		}
		else if(sPathBody.index > tPathEnd.pred -> size()){
			thisModule.stubIndexMap <- thisModule.stubIndexMap.including(sPathBody.index, Sequence{tLastNode, tPathEnd}); -- This approach won't work if an index is used more than once!
		}
		else{
			thisModule.connect(tLastNode, tPathEnd);
		}	
	}
}


rule doConnectForPathEnd(sPathEnd : Turn!PathEnd, tAlternatePathEnd : Urn!PathEnd){
	using{
		sPathBodies : Sequence(Turn!PathBodyNode) = Sequence {};
		sConnectingBody : Turn!PathBody = OclUndefined;
	}
	do{
		if(sPathEnd.oclIsTypeOf(Turn!EndpointWithConnect) or not sPathEnd.isDefined()){
			-- Do nothing as we do not need to connect this PathEnd.
		}
		else{
			if(sPathEnd.oclIsTypeOf(Turn!AndFork)){
				sPathBodies <- sPathEnd.pathbody;
				sConnectingBody <- sPathEnd.connectingAndBody;
			}
			else if(sPathEnd.oclIsTypeOf(Turn!OrFork)){
				if(sPathEnd.body.isDefined()){
					sPathBodies <- sPathEnd.body.regularBody -> collect(rb|rb.pathBody) -> including(sPathEnd.body.elseBody);
				}
				
				sConnectingBody <- sPathEnd.connectingOrBody;
			}
			else if(sPathEnd.oclIsTypeOf(Turn!Stub)){
				sPathBodies <- sPathEnd.outPaths -> collect(op|op.path);
				sConnectingBody <- sPathEnd.connectingStubBody;
			}
			
			thisModule.connectPathEndPathBodies(sPathEnd, sPathBodies, sConnectingBody, tAlternatePathEnd);
		}
	}
}

rule connectPathEndPathBodies(sNode: Turn!PathBodyNode, sPathBodies: Sequence(Turn!PathBody), sConnectingBody: Turn!PathBody, tNextConnectingNode : Urn!PathNode){
	using{
		tNode: Urn!PathNode = thisModule.retrieveNode(sNode);
		vNumberOfNonTerminatingNodes : Integer = sPathBodies -> select(pb|pb.isDefined()) -> select(pb|not thisModule.getOrCreateEndPoint(pb.pathEnd).oclIsTypeOf(Urn!EndPoint)) -> size();
		tLastNode : Urn!PathNode = 
			if(not sConnectingBody.isDefined() or vNumberOfNonTerminatingNodes < 2) then
				OclUndefined
			else
				if(sNode.oclIsTypeOf(Turn!AndFork)) then
					thisModule.createAndJoin()
				else
					thisModule.createOrJoin()
				endif
			endif;
	}
	do{
		for(sPathBody in sPathBodies -> select(pb|pb.isDefined())){
			thisModule.connectPathBody(sPathBody, tNode, tLastNode);
		}
		
		if(not tLastNode.isDefined()){
			tLastNode <- tNode;
		}
		
		thisModule.connectPathBody(sConnectingBody, tLastNode, tNextConnectingNode);
	}
}

-- Connects paths for all the stubs with indeces. These are added to stubIndexMap at an earlier
-- stage of the code and left there to be considered last.
rule connectIndexedPathBodies(){
	using{
		tStub : Urn!Stub = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
		tOrJoin : Urn!OrJoin = OclUndefined;
	}
	do{
		for(vIndex in thisModule.stubIndexMap.keySet()){
			tLastNode <- thisModule.stubIndexMap.get(vIndex).first();
			tStub <- thisModule.stubIndexMap.get(vIndex).last();

			if(vIndex <= tStub.pred -> size()){
				tOrJoin <- thisModule.createOrJoin();
				tStub.pred -> at(vIndex).target <- tOrJoin; --TODO: iterate over all of the pred
				thisModule.directConnect(tLastNode, tOrJoin);
				thisModule.directConnect(tOrJoin, tStub);
			}
			else{
				thisModule.directConnect(tLastNode, tStub);
			}
		}
		
		thisModule.stubIndexMap <- Map{};
	}
}

-- Sets orFork node conditions. Called after connectPathBodiesWithIndexes so that all connections are in place when this is done.
-- Is rather inefficient as it calls allInstances(); this approach can potentially be improved upon.
rule setOrForkConditionsAndCreateAlternateBranches(){
	using{
		vCounter : Integer = 1;
		sOrFork : Turn!OrFork = OclUndefined;
	}
	do{
		for(tOrFork in thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!OrFork))){
			sOrFork <- Turn!OrFork.allInstances() -> any(n|thisModule.resolveTemp(n, 'tOrFork')=tOrFork);
			
			if(sOrFork.condition.isDefined()){ -- Just condition case
				tOrFork.succ.first().condition <- thisModule.resolveTemp(sOrFork.condition, 'tCondition');
				thisModule.connect(tOrFork, thisModule.createEndPoint());
				tOrFork.succ -> at(2).condition <- thisModule.createCondition('!' + sOrFork.condition.expression.asString());
				
			}
			
			if(sOrFork.body.isDefined()){
				for(sRegularOrFork in sOrFork.body.regularBody){
					tOrFork.succ -> at(vCounter).condition <- thisModule.resolveTemp(sRegularOrFork.condition, 'tCondition');
					vCounter <- vCounter + 1;
				}
				
				if(sOrFork.body.elseBody.isDefined()){
					tOrFork.succ.last().condition <- thisModule.createCondition('else');
				}
				else if(sOrFork.body.regularBody -> size() = 1){
					thisModule.connect(tOrFork, thisModule.createEndPoint());
					tOrFork.succ -> at(2).condition <- thisModule.createCondition('!' + sOrFork.body.regularBody.first().condition.expression.asString());
				}
			}
			
			vCounter <- 1;
		}
	}
}

-- Sets stub connection thresholds. Called after connectPathBodiesWithIndexes so that all connections are in place when this is done.
-- Is rather inefficient as it calls allInstances(); this approach can potentially be improved upon.
rule setStubThresholds(){
	using{
		vCounter : Integer = 1;
		sStub : Turn!Stub = OclUndefined;
	}
	do{
		for(tStub in thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!Stub))){
			sStub <- Turn!Stub.allInstances() -> any(n|thisModule.resolveTemp(n, 'tStub')=tStub);
			
			if(sStub.isDefined()){
				for(sOutPath in sStub.outPaths){
					if(sOutPath.threshold <> 0){
						tStub.succ.last().threshold <- sOutPath.threshold.toString();
					}
					
					vCounter <- vCounter + 1;
				}
			}
			else{
				-- Declared using StubDeclaration, no outPaths
			}
		}
	}
}