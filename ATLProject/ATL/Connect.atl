module Connect;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- At present, this is behavior is also partially performed by
-- rules in the "Process.atl" file. Ideally, this behavior should
-- be limited to only rules in this file.


rule connectPath(path: Turn!Path){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;	
	}
	do{
		thisModule.processPathBody(path.pathBody);
			
		if(path.startPoint.oclIsUndefined()){
			tStartPoint <- thisModule.createStartPoint();
		}
		else{
			tStartPoint <- thisModule.retrieveNode(path.startPoint);
		}
		
		if(path.pathBody.pathNodes -> isEmpty()){
			thisModule.connectStartPointToPathEnd(path.startPoint, tStartPoint, thisModule.getPathEnd(path.pathBody));
		}
		else{
			thisModule.createNewConnection(tStartPoint);
			thisModule.connectPathBody(path.pathBody, path.startPoint, tStartPoint);
		}	
	}
}

rule connectPathBody(pathbody: Sequence(Turn!PathBody), node: Turn!PathNode, previousNode: Urn!PathNode){
	do{
		thisModule.connectBodyNodes(pathbody.pathNodes, node, previousNode);
		
		if(not pathbody.pathNodes -> isEmpty()){
			thisModule.connectLastNodeToPathEnd(pathbody, pathbody.pathNodes.last());
		}
	}
}

rule connectBodyNodes(pathNodes: Sequence(Turn!PathBodyNode), node: Turn!PathNode, previousNode: Urn!PathNode){
	using{
		vNode : Urn!PathNode = OclUndefined;
	}
	do{
		for(currentNode in pathNodes){
			if(currentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.processTimer(currentNode);
			}
			
			if(node.oclIsTypeOf(Turn!OrFork) and thisModule.retrieveNode(currentNode) = previousNode){
				thisModule.connect(thisModule.retrieveNode(node), previousNode);
			}
			else{
				vNode <- thisModule.retrieveNode(currentNode);
				
				if(currentNode.oclIsTypeOf(Turn!Connect) or currentNode.oclIsTypeOf(Turn!WaitingPlace) or currentNode.oclIsTypeOf(Turn!Timer)){
					if(currentNode.oclIsTypeOf(Turn!Connect)){
						thisModule.createEmptyPointConnect(currentNode);
						vNode <- thisModule.retrieveNode(currentNode.connectsTo);
					}
					else if(currentNode.oclIsTypeOf(Turn!WaitingPlace) or currentNode.oclIsTypeOf(Turn!Timer)){
						if(not thisModule.emptyPointMap.get(currentNode).oclIsUndefined()){
							vNode <- thisModule.emptyPointMap.get(currentNode);
						}
					}
				}
				
				thisModule.connect(previousNode, vNode);
			}
			
			if(currentNode.oclIsTypeOf(Turn!Connect)){
				currentNode <- currentNode.connectsTo;
			}

			previousNode <- thisModule.retrieveNode(currentNode);
		}
	}
}

rule connectStartPointToPathEnd(sStartPoint: Turn!StartPoint, tStartPoint: Urn!StartPoint, pathEnd: Urn!PathNode){
	using{
		vEmptyPoint : Urn!EmptyPoint = OclUndefined;
	}
	do{
		if(not sStartPoint.oclIsUndefined()){
			if(not sStartPoint.connect.oclIsUndefined()){
				tStartPoint <- thisModule.emptyPointMap.get(sStartPoint);
			}
		}

		thisModule.connect(tStartPoint, pathEnd);
	}
}

rule connectLastNodeToPathEnd(pathbody: Sequence(Turn!PathBody), lastNode: Turn!PathNode){
	do{
		if(lastNode.oclIsTypeOf(Turn!Connect)){
			lastNode <- lastNode.connectsTo;
			
			if(lastNode.oclIsTypeOf(Turn!StartPoint) and pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				thisModule.createNewConnection(thisModule.retrieveNode(lastNode));
			}
		}
		
		-- connect last node with pathEnd
		thisModule.useConnection(thisModule.getPathEnd(pathbody), thisModule.handleEmptyBody(pathbody, thisModule.retrieveNode(lastNode).nextFreeConnection()));
		
		if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(thisModule.getPathEnd(pathbody).succ -> isEmpty()){
				if(not thisModule.emptyPointMap.get(pathbody.pathNodes.first()).oclIsUndefined()){
					thisModule.connect(thisModule.emptyPointMap.get(pathbody.pathNodes.first()), thisModule.getPathEnd(pathbody));
				}
			}
		}	
	}
}

rule connectWithEmptyPoint(currentNode: Turn!PathNode, nextNode: Turn!PathNode){
	using{
		vEmptyPt : Turn!PathNode = OclUndefined;
	}
	do{
		vEmptyPt <- thisModule.createEmptyPoint();
		thisModule.connect(currentNode, vEmptyPt);  -- currentNode -> vEmptyPt
		thisModule.connect(vEmptyPt, nextNode);     -- vEmptyPt    -> nextNode
		thisModule.connect(currentNode, nextNode);  -- currentNode -> nextNode
		vEmptyPt;
	}
}