module ConnectNodes;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- At present, this is behavior is also partially performed by
-- rules in the "Process.atl" file. Ideally, this behavior should
-- be limited to only rules in this file.

rule connectReferencedEndToNextNode(body: Turn!PathBody, nextNode: Turn!PathNode){
	do{
		if(body.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(not body.pathNodes -> last().oclIsTypeOf(Turn!Connect)){
				if(thisModule.retrieveNode(body.referencedEnd).pred -> collect(s|s.source) -> isEmpty()){
					thisModule.addPred(thisModule.retrieveNode(body.referencedEnd), nextNode);
				}
			}
		}
		else if(not body.referencedEnd.oclIsUndefined()){
			thisModule.addPred(thisModule.retrieveNode(body.referencedEnd), nextNode);
		}
		else if(not body.referencedStub.oclIsUndefined()){
			thisModule.processReferencedStub(body, nextNode);
		}
	}
}

rule connectNodesAfterFork(pathbodies: Sequence(Turn!PathBody), forkNode: Turn!PathNode){
	using{
		vCounter: Integer = 1;	
	}
	do{
		for(pathbody in pathbodies){
			if(pathbody.pathNodes -> first().oclIsTypeOf(Turn!RespRef)){
				thisModule.addPred(thisModule.retrieveNode(pathbody.pathNodes -> first()), forkNode.succ -> at(vCounter));
			}
			vCounter <- vCounter.inc(); 			
		}	
	}
}

rule connectAndForkNodes(pathend: Turn!PathEnd){
	using{
		vHasReferencedEnd : Boolean = OclUndefined;
		vAndFork : Urn!AndFork = thisModule.retrieveNode(pathend);
		vCounter : Integer = 1;
	}
	do{
		for(pathbody in pathend.pathbody -> flatten()){
			if(pathbody.referencedEnd.oclIsUndefined() or pathbody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
				vHasReferencedEnd <- false;
			}
			else{
				vHasReferencedEnd <- not thisModule.retrieveNode(pathbody.referencedEnd).oclIsUndefined();
			}
			
			if(vHasReferencedEnd){
				thisModule.addPred(thisModule.retrieveNode(pathbody.referencedEnd), vAndFork.succ -> at(vCounter));
			}
			else if(pathbody.oclIsTypeOf(Turn!PathBodyNodes)){
				if(not pathbody.pathNodes -> isEmpty()){
					thisModule.connectNodes(pathbody, pathend, vAndFork);
				}	
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
					thisModule.addPred(thisModule.retrieveNode(pathbody.pathEnd.regularEnd), vAndFork.succ -> at(vCounter));
				}
			} 
			
			vCounter <- vCounter.inc();
		}
	}
}

rule connectOrForkNodes(originalPathend: Turn!PathEnd){
	using{
		vCounter : Integer = 1;
	}
	do{
		if(not originalPathend.body.oclIsUndefined()){
			for(pathbody in originalPathend.body.regularBody -> flatten() -> collect(rb|rb.pathBody)){
				if(not pathbody.referencedEnd.oclIsUndefined() and not pathbody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
					-- BUG: referencedEnd below is undefined in some cases, leading to an error; unsure why; temporary fix: added in the conditional below
					if(not thisModule.retrieveNode(pathbody.referencedEnd).oclIsUndefined()){
						thisModule.addPred(thisModule.retrieveNode(pathbody.referencedEnd), thisModule.retrieveNode(originalPathend).succ -> at(vCounter));
					}
				}
				else if(not pathbody.pathNodes -> isEmpty()){
					thisModule.connectNodes(pathbody, originalPathend, thisModule.retrieveNode(originalPathend));
				}
				vCounter <- vCounter.inc();
			}		
		}
	}
}

rule connectStubOutNodes(stubObj:Turn!Stub){
	using{
		vStubOutPathPosition : Integer = 1;
		vPathEnd : Turn!RegularEnd = OclUndefined;
		vFinishedConnection : Boolean = OclUndefined;
		vCurrentSuccessorToStub : Turn!PathNode = OclUndefined;
		vPreviousNode : Turn!PathNode = OclUndefined;
		vCurrentNode : Turn!PathNode = OclUndefined;
	}
	do{
		vStubOutPathPosition <- 1;
		for(outPath in stubObj.outPaths -> flatten()){
			vCurrentSuccessorToStub <- thisModule.retrieveNode(stubObj).succ -> at(vStubOutPathPosition);
			
			--if no pathNodes exist
			if(outPath.path.pathNodes -> isEmpty()){
				vPathEnd <- outPath.path.pathEnd;
				
				if(not vPathEnd.oclIsUndefined()){
					if(vPathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
						thisModule.addPred(thisModule.retrieveNode(vPathEnd.regularEnd), vCurrentSuccessorToStub);
					}
					else if(vPathEnd.oclIsTypeOf(Turn!OrFork) or vPathEnd.oclIsTypeOf(Turn!AndFork) or vPathEnd.oclIsTypeOf(Turn!Stub)){
						thisModule.addPred(thisModule.retrieveNode(vPathEnd), vCurrentSuccessorToStub);
					}
					else if(not outPath.path.referencedEnd.oclIsUndefined()){
						thisModule.addPred(thisModule.retrieveNode(outPath.path.referencedEnd), vCurrentSuccessorToStub);
					}
					else { 
						thisModule.addPred(thisModule.retrieveNode(vPathEnd), vCurrentSuccessorToStub);
					}
					
					if(vPathEnd.oclIsTypeOf(Turn!OrFork)){
						thisModule.connectOrForkNodes(vPathEnd);
					}
					else if(vPathEnd.oclIsTypeOf(Turn!AndFork)){
						thisModule.connectAndForkNodes(vPathEnd);
					}
				}
			}
			
			vStubOutPathPosition <- vStubOutPathPosition.inc();
		}	
	}
}

rule connectOrForkEndPoints(obj: Turn!OrFork, nextNode: Urn!PathNode, expression: String){
	using{
		vNextPred : Urn!NodeConnection = OclUndefined;
		vBody : Turn!PathBody = obj.connectingOrBody;
	}
	do{
		if(nextNode.oclIsTypeOf(Urn!OrFork)){
			vNextPred <- nextNode.succ -> any(s|s.condition.expression=expression);
		}
		else if(nextNode.oclIsTypeOf(Urn!OrJoin)){
			vNextPred <- nextNode.firstUnconnectedSucc();
		}
		
		if(vBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			thisModule.addPred(thisModule.retrieveNode(vBody.pathEnd.regularEnd), vNextPred);
		}
		else if(vBody.pathEnd.oclIsTypeOf(Turn!OrFork) or vBody.pathEnd.oclIsTypeOf(Turn!AndFork) or vBody.pathEnd.oclIsTypeOf(Turn!Stub)){
			thisModule.addPred(thisModule.retrieveNode(vBody.pathEnd), vNextPred);
		}
		
		if(vBody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
			thisModule.addPred(thisModule.retrieveNode(vBody.referencedEnd), vNextPred);
		}
		else{
			thisModule.connectReferencedEndToNextNode(vBody, vNextPred);
		}
	}
}

--rule connectTimerNodes(timerObj: Turn!Timer){
--	using{
--		vReferencedEnd : Turn!ReferencedEnd = timerObj.timeoutPath.referencedEnd;
--	}
--	do{
--		--if pathNodes exist NOT SURE IF REQUIRED AS THERE IS NO PATHNODES TO TIMEOUT PATH
--		if(not (timerObj.timeoutPath.pathNodes -> isEmpty())){
--			thisModule.addPred(thisModule.retrieveNode(timerObj.timeoutPath.pathNodes -> first()), thisModule.retrieveNode(timerObj).succ -> at(2));
--			thisModule.connectNodes(timerObj.timeoutPath, timerObj, OclUndefined);
--		}
--		
--		if(vReferencedEnd.oclIsTypeOf(Turn!RespRef)){
--			thisModule.addPred(thisModule.getResponsibility(thisModule.referencedEnd.name).respRefs -> first(), thisModule.retrieveNode(timerObj).succ -> at(2));
--		}
--		
--		if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!OrFork)){
--			thisModule.connectOrForkNodes(timerObj.timeoutPath.pathEnd);
--		}
--		else if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!AndFork)){
--			thisModule.connectAndForkNodes(timerObj.timeoutPath.pathEnd);
--		}
--		else if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!Stub)){
--			thisModule.createStubOutNodes(timerObj.timeoutPath.pathEnd);
--		}
--	}
--}

rule createEmptyPointConnect(currentNode: Turn!PathNode, newPred: Urn!PathNode){
	to
		tNodeConnection1: Urn!NodeConnection(),
		tConnect: Urn!Connect(
			id <- thisModule.nextId().toString(),
			name <- 'Connect' + tConnect.id,
			diagram <- thisModule.tUCMmap,
			succ <- tNodeConnection1,
			pred <- tNodeConnection2
		),
		tNodeConnection2: Urn!NodeConnection(),
		tEmptyPt: Urn!EmptyPoint(
			id <- thisModule.nextId().toString(),
			name <- 'EmptyPoint' + tEmptyPt.id,
			diagram <- thisModule.tUCMmap,
			succ <- tNodeConnection2
		)
	do{
		if(currentNode.connectsTo.oclIsTypeOf(Turn!Timer)){
			tEmptyPt.name <- 'AsynchConnectTimer#' + currentNode.connectsTo.name;
			thisModule.addPred(tEmptyPt, newPred);
		}
		else{
			thisModule.addPred(thisModule.retrieveNode(currentNode.connectsTo), tNodeConnection1);
			thisModule.addPred(thisModule.retrieveNode(currentNode.connectsTo), newPred);
		}
		thisModule.connectMap <- thisModule.connectMap.including(currentNode, tConnect);
		tConnect;
	}
}

--QUESTION: there doesn't appear to be a Turn!PathNode class. What should I use instead?
rule handleFirstNode(node: Turn!PathNode, firstNode: Turn!PathNode, nextNode: Urn!PathNode){
	do{
		if(firstNode.oclIsTypeOf(Turn!Connect)){
			if(node.oclIsTypeOf(Turn!AndFork)){
				thisModule.createEmptyPointConnect(firstNode, nextNode.firstUnconnectedSucc());
			}
			else if(node.oclIsTypeOf(Turn!OrFork)){
				thisModule.createEmptyPointConnect(firstNode, nextNode.succ -> first());
			}
			else{
				thisModule.createEmptyPointConnect(firstNode, thisModule.retrieveNode(node).firstUnconnectedSucc());
			}
		}
		else if(node.oclIsTypeOf(Turn!StartPoint)){
			if(firstNode.oclIsTypeOf(Turn!WaitingPlace)){
				if(not firstNode.connect.oclIsUndefined()){
					thisModule.addPred(thisModule.tUCMmap.nodes -> any(n|n.oclIsTypeOf(Urn!EmptyPoint) and n.succ -> includes(thisModule.retrieveNode(firstNode.connect).pred -> first())), thisModule.retrieveNode(node).firstUnconnectedSucc());
				}
				else{
					thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).firstUnconnectedSucc());
				}
			}
			else{
				thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).firstUnconnectedSucc());
			}
		}
		else if(node.oclIsTypeOf(Turn!OrFork) or node.oclIsTypeOf(Turn!AndFork)){
			if(nextNode.oclIsUndefined()){
				nextNode <- thisModule.retrieveNode(node);
			}
			
			thisModule.addPred(thisModule.retrieveNode(firstNode), nextNode.firstUnconnectedSucc());
			
			if(firstNode.oclIsTypeOf(Turn!Timer) and node.oclIsTypeOf(Turn!OrFork)){
				thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).succ -> first());
			}
		}
		else if(node.oclIsTypeOf(Turn!Stub)){
			thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).firstUnconnectedSucc());
		}
	}
}
	
rule handleNode(currentNode: Turn!PathNode, previousNode: Turn!PathNode){
	using{
		vConnect : Turn!PathNode = OclUndefined;
	}
	do{
		if(currentNode.oclIsTypeOf(Turn!Connect)){
			if(previousNode.oclIsTypeOf(Turn!Connect)){
				vConnect <- thisModule.createEmptyPointConnect(currentNode, thisModule.retrieveNode(previousNode.connectsTo).succ);
				if(not thisModule.retrieveNode(previousNode.connectsTo).oclIsUndefined()){
					thisModule.addPred(thisModule.retrieveNode(previousNode.connectsTo), vConnect.succ);
				}
			}
			else{
				thisModule.createEmptyPointConnect(currentNode, thisModule.retrieveNode(previousNode).succ);
			}
		}
		else if(previousNode.oclIsTypeOf(Turn!Connect)){
			if(previousNode.connectsTo.oclIsTypeOf(Turn!Timer)){
				thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.retrieveNode(previousNode).firstUnconnectedSucc()); 
			}
			else{
				if(not currentNode.oclIsTypeOf(Turn!OrJoin) and not currentNode.oclIsTypeOf(Turn!AndJoin)){
					thisModule.addSucc(thisModule.retrieveNode(previousNode.connectsTo), thisModule.createNodeConnection());
				}
				thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.retrieveNode(previousNode.connectsTo).firstUnconnectedSucc());
			}
		}
		else if((previousNode.oclIsTypeOf(Turn!RespRef) and not currentNode.oclIsTypeOf(Turn!Timer)) or currentNode.oclIsTypeOf(Turn!WaitingPlace) or currentNode.oclIsTypeOf(Turn!FailurePoint) or currentNode.oclIsTypeOf(Turn!RespRef)){
			thisModule.respDef <- thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(r|r.respDef.name=previousNode.name) -> flatten();
			thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.respDef -> collect(s|s.succ) -> flatten() -> select(s|s.target.oclIsUndefined()));
		}
		else if(previousNode.oclIsTypeOf(Turn!Timer) or previousNode.oclIsTypeOf(Turn!AndJoin) or previousNode.oclIsTypeOf(Turn!OrJoin)){
			thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.retrieveNode(previousNode).firstUnconnectedSucc());
		}
	}
}

rule handleRegularEnds(pathend: Turn!PathNode, currentNode: Turn!PathNode){
	using{
		vNewPred : Turn!PathNode = OclUndefined;	
	}
	do{
		if(currentNode.oclIsTypeOf(Turn!RespRef)){
			if(pathend.oclIsTypeOf(Turn!EndpointWithConnect)){
				thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
			}
			else if(pathend.oclIsTypeOf(Turn!Stub)){
				thisModule.addPred(thisModule.retrieveNode(pathend), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
			}
			else if(pathend.oclIsTypeOf(Turn!AndFork) or pathend.oclIsTypeOf(Turn!OrFork)){
				thisModule.addPred(thisModule.retrieveNode(pathend), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
			}
		}
		else if(pathend.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(currentNode.oclIsTypeOf(Turn!Connect)){
				if(currentNode.connectsTo.oclIsTypeOf(Turn!Timer)){
					thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
				}
				else if(pathend.regularEnd.oclIsTypeOf(Turn!EndPoint)){
					if(currentNode.connectsTo.oclIsTypeOf(Turn!StartPoint)){
						thisModule.addSucc(thisModule.retrieveNode(currentNode.connectsTo), thisModule.createNodeConnection());
					}
					thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode.connectsTo).firstUnconnectedSucc());
				}
			}
			else if(currentNode.oclIsTypeOf(Turn!WaitingPlace)){
				if(not currentNode.connect.oclIsUndefined() and not thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> isEmpty()){
					--TODO: figure out how to make this do something
					--vNewPred <- thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ept|ept.succ -> includes(thisModule.retrieveNode(currentNode.connect).pred -> first())).firstUnconnectedSucc();
					--thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), vNewPred);
				}
				else if(pathend.regularEnd.oclIsTypeOf(Turn!EndPoint)){
					thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
				}
			}
			else if(pathend.regularEnd.oclIsTypeOf(Turn!EndPoint)){
				thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
			}
		}
		else if(pathend.oclIsTypeOf(Turn!Stub) or pathend.oclIsTypeOf(Turn!OrFork) or pathend.oclIsTypeOf(Turn!AndFork)){
			if(currentNode.oclIsTypeOf(Turn!Connect)){
				if(currentNode.connectsTo.oclIsTypeOf(Turn!WaitingPlace)){
					currentNode <- currentNode.connectsTo;
				}
			}
			thisModule.addPred(thisModule.retrieveNode(pathend), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
		}
	}
}

rule connectNodes(pathbody: Sequence(Turn!PathBody), node: Turn!PathNode, nextNode: Urn!PathNode){
	using{
		vPreviousNode : Turn!PathNode = OclUndefined;
		vLastNode : Turn!PathNode = OclUndefined;
	}
	do{
		for(currentNode in pathbody.pathNodes){
			if(currentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.processTimer(currentNode);
			}
			
			if(vPreviousNode.oclIsUndefined()){
				thisModule.handleFirstNode(node, currentNode, nextNode);
			}
			else{
				thisModule.handleNode(currentNode, vPreviousNode);
			}
			
			vPreviousNode <- currentNode;
		}
		
		vLastNode <- vPreviousNode;
		
		if(not vLastNode.oclIsUndefined()){
			if(not pathbody.pathEnd.oclIsUndefined()){
				thisModule.handleRegularEnds(pathbody.pathEnd, vLastNode);
			}
			else{
				if(vLastNode.oclIsTypeOf(Turn!Connect)){
					if(vLastNode.connectsTo.oclIsTypeOf(Turn!WaitingPlace)){
						vLastNode <- vLastNode.connectsTo;
					}
				}
				
				if(not pathbody.referencedEnd.oclIsUndefined()){
					thisModule.addPred(thisModule.retrieveNode(pathbody.referencedEnd), thisModule.retrieveNode(vLastNode).succ);	
				}
				else if(not pathbody.referencedStub.oclIsUndefined()){-- and not vPreviousNode.oclIsUndefined()){
					thisModule.processReferencedStub(pathbody, thisModule.retrieveNode(vLastNode).succ);
				}
			}
		}
	}
}