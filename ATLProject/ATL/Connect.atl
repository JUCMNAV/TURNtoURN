module Connect;

create OUT : Urn from IN : Turn;

-- Contains all rules used to handle connections between nodes.
-- At present, this is behavior is also partially performed by
-- rules in the "Process.atl" file. Ideally, this behavior should
-- be limited to only rules in this file.

rule connectPath(sPath: Turn!Path){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;	
	}
	do{	
		if(sPath.startPoint.oclIsUndefined()){
			tStartPoint <- thisModule.createStartPoint();
		}
		else{
			tStartPoint <- thisModule.retrieveNode(sPath.startPoint);
		}
		
		thisModule.processPathBody(sPath.pathBody);
		
		if(sPath.pathBody.pathNodes -> isEmpty()){
			thisModule.connect(tStartPoint, thisModule.getPathEnd(sPath.pathBody));
		}
		else{
			thisModule.connectPathBody(sPath.pathBody, tStartPoint);
		}
	}
}

rule connectPathBody(sPathBody: Turn!PathBody, tPathStart: Urn!PathNode){
	using{
		tPathEnd : Urn!PathNode = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
	}
	do{
		tLastNode <- thisModule.connectBodyNodes(sPathBody.pathNodes, tPathStart);
		tPathEnd <- thisModule.getPathEnd(sPathBody);
		thisModule.newConnect(tLastNode, tPathEnd);
		tPathEnd;
	}
}

rule connectBodyNodes(sPathNodes: Sequence(Turn!PathBodyNode), tPathStart: Urn!PathNode){
	using{
		tNode : Urn!PathNode = OclUndefined;
		tOrJoin : Urn!OrJoin = OclUndefined;
		tPreviousNode : Urn!PathNode = tPathStart;
	}
	do{
		for(sCurrentNode in sPathNodes){
			if(sCurrentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.processTimer(sCurrentNode);
			}
			
			tNode <- thisModule.retrieveNode(sCurrentNode);
			thisModule.connect(tPreviousNode, tNode);
			tPreviousNode <- tNode;
		}
		
		tPreviousNode;
	}
}