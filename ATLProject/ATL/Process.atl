module Process;

create OUT : Urn from IN : Turn;

-- Contains all rules used to process a node in order to initialize it.
-- These rules are called in two cases. The first is in a matched rule,
-- to initialize the matched item. The second is in a called rule, to 
-- initialize some object created during a different object's matching.

rule processBinding(sBinding: Turn!Binding, tBinding: Urn!Binding){
	using{
		boundTerm : Turn!Binding = OclUndefined;
		sStub : Turn!Stub = OclUndefined;
		tStub: Urn!Stub = OclUndefined;
	}
	do{
		if(not sBinding.binding.oclIsUndefined()){
			boundTerm <- sBinding.binding;
		}
		else if(not sBinding.bindings.oclIsUndefined()){
			boundTerm <- sBinding.bindings;
		}
		
		if(not boundTerm.stubParam.stubDec.oclIsUndefined()){
			sStub <- boundTerm.stubParam.stubDec.stub;
		}
		else if(not boundTerm.stubParam.stub.oclIsUndefined()){
			sStub <- boundTerm.stubParam.stub;
		}
		
		if(not sStub.oclIsUndefined() and not thisModule.retrieveNode(sStub).pred -> isEmpty()){
			if(sBinding.oclIsTypeOf(Turn!InBinding)){
				tBinding.stubEntry <- thisModule.retrieveNode(sStub).pred -> at(sBinding.index);
			}
			else if(sBinding.oclIsTypeOf(Turn!OutBinding)){
				tBinding.stubExit <- thisModule.retrieveNode(sStub).succ -> at(sBinding.index);
			}
		}	
	}
}

rule processEndPoint(sEndPoint: Turn!EndPoint, tEndPoint: Turn!EndPoint){
	using{
		sPathBody : Turn!PathBody = sEndPoint.epConnect.pbody;	
	}
	do{
		if(not sEndPoint.condition.oclIsUndefined()){
			tEndPoint.postcondition <- thisModule.createCondition(sEndPoint.condition.expression.asString());
		}
		tEndPoint.name <- sEndPoint.turnGetLongestName();
		
		thisModule.endPointMap <- thisModule.endPointMap.including(sEndPoint, tEndPoint);
		
		tEndPoint;
	}
}

rule processTimer(sTimer: Turn!Timer){
	using{
		tTimer : Urn!Timer = thisModule.retrieveNode(sTimer);
	}
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tTimer);
		
		if(not sTimer.timeoutPath.oclIsUndefined()){
			thisModule.createNewConnection(tTimer);
			thisModule.processPathBody(sTimer.timeoutPath);
			
			if(not sTimer.timeoutCondition.oclIsUndefined()){
				tTimer.succ -> at(2).condition <- thisModule.createCondition(sTimer.timeoutCondition.expression.content.first());
			}
			
			if(sTimer.timeoutPath.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				thisModule.useConnection(thisModule.getPathEnd(sTimer.timeoutPath), tTimer.succ -> at(2));
			}
		}
		
		tTimer;
	}
}

rule processAndFork(sAndFork: Turn!AndFork){
	using{
		tAndFork : Urn!AndFork = thisModule.retrieveNode(sAndFork);
		tPathEnd : Urn!PathBodyNode = OclUndefined;
		tAndJoin : Urn!AndJoin = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;
		tOrJoin : Urn!OrJoin = OclUndefined;
	}
	do{
		for(pathbody in sAndFork.pathbody){
			thisModule.processPathBody(pathbody);
			thisModule.connectPathBody(pathbody, tAndFork);
		}
		
		if(not sAndFork.connectingAndBody.oclIsUndefined()){
			thisModule.processPathBody(sAndFork.connectingAndBody);
			
			tPathEnd <- thisModule.getPathEnd(sAndFork.connectingAndBody);
			tLastNode <- tAndFork;
			
			if(sAndFork.pathbody -> select(pb|pb.pathEnd.oclIsUndefined()) -> size() >= 2){
				tAndJoin <- thisModule.createAndJoin();
				thisModule.connectWithEmptyPoint(tAndFork, tAndJoin);
				tLastNode <- thisModule.connectBodyNodes(sAndFork.connectingAndBody.pathNodes, tAndJoin);
				
				if(sAndFork.connectingAndBody.meetsOrJoinConditions(tPathEnd)){
					tOrJoin <- thisModule.createOrJoin();
					thisModule.connect(tLastNode, tOrJoin);
					tPathEnd.pred.first().target <- tOrJoin;
					tLastNode <- tOrJoin;
				}
			}
			
			thisModule.connect(tLastNode, tPathEnd);
		}
		
		tAndFork;	
	}
}

rule processConnect(sConnect: Turn!Connect){
	do{
		thisModule.createEmptyPointConnect(sConnect);
	}
}

helper context Urn!PathNode def : isConnectedTo(tPathNode : Urn!PathNode) : Boolean =
	not(self.succ -> any(n|n.target=tPathNode).oclIsUndefined());


rule processOrFork(sOrFork: Turn!OrFork){
	using{
		tRegularOrForkBranches : Sequence(Turn!OrFork) = 
			if(sOrFork.body.oclIsUndefined()) then
				Sequence {}
			else
				sOrFork.body.regularBody
			endif;
		tOrFork : Urn!OrFork = thisModule.retrieveNode(sOrFork);
		sPathBodies : Sequence(Turn!PathBody) = 
			if(sOrFork.body.oclIsUndefined()) then
				Sequence {}
			else 
				sOrFork.body.regularBody -> collect(pb|pb.pathBody) -> flatten()
			endif;
		tNextNode : Urn!PathNode = OclUndefined;
		tOrJoin : Urn!OrJoin = OclUndefined;
		tEmptyPoint : Urn!EmptyPoint = OclUndefined;
		tEndPoint : Urn!EndPoint = OclUndefined;
		tLastNode : Urn!PathNode = OclUndefined;

	}
	do{
		if(not sOrFork.connectingOrBody.oclIsUndefined()){
			thisModule.processPathBody(sOrFork.connectingOrBody);
		}
		
		for(orFork in tRegularOrForkBranches){
			thisModule.createNewConnection(tOrFork);
			tOrFork.mostRecentUnusedConnection().condition <- thisModule.resolveTemp(orFork.condition, 'tCondition');
			thisModule.processPathBody(orFork.pathBody);
			thisModule.connectPathBody(orFork.pathBody, tOrFork);
		}

		tNextNode <- tOrFork;
		
		if(sPathBodies -> isEmpty()){
			tEndPoint <- thisModule.createEndPointUsingNode(sOrFork);
			thisModule.connectWithCondition(tOrFork, tEndPoint, thisModule.createCondition('!' + sOrFork.condition.expression.asString()));
			thisModule.connectWithCondition(tOrFork, thisModule.getPathEnd(sOrFork.connectingOrBody), thisModule.resolveTemp(sOrFork.condition, 'tCondition'));
		}
		else if(not sOrFork.body.elseBody.oclIsUndefined()){
			tOrJoin <- thisModule.createOrJoin();
			tEmptyPoint <- thisModule.connectWithEmptyPoint(tOrFork, tOrJoin);
			thisModule.addConditionToConnectionBetween(tOrFork, tEmptyPoint, thisModule.createCondition('else'));
			thisModule.connect(tOrJoin, thisModule.getPathEnd(sOrFork.connectingOrBody));
		}
		else if(not sOrFork.connectingOrBody.oclIsUndefined()){
			if(sPathBodies -> select(pb|pb.pathEnd.oclIsUndefined()) -> size() >= 2){
				tOrJoin <- thisModule.createOrJoin();
				tEmptyPoint <- thisModule.connectWithEmptyPoint(tOrFork, tOrJoin);
				tNextNode <- tOrJoin;
			}
			
			if(sOrFork.connectingOrBody.meetsOrJoinConditions(thisModule.getPathEnd(sOrFork.connectingOrBody))){
				tOrJoin <- thisModule.createOrJoin();
				thisModule.useConnection(tOrJoin, tNextNode.nextFreeConnection());
				thisModule.useConnection(tOrJoin, thisModule.getPathEnd(sOrFork.connectingOrBody).pred.first().source.succ);
				tNextNode <- tOrJoin;
			}
			
			if(sPathBodies -> size() = 1){
				tEndPoint <- thisModule.createEndPointUsingNode(sOrFork);
				thisModule.connectWithCondition(tOrFork, tEndPoint, thisModule.createCondition('!' + sPathBodies.first().orFork.condition.expression.asString()));
			}
			
			thisModule.connectPathBody(sOrFork.connectingOrBody, tNextNode);
		}

		tOrFork;
	}
}

rule addConditionToConnectionBetween(tFirstNode: Urn!PathNode, tSecondNode: Urn!PathNode, tCondition: Urn!Condition){
	do{
		tFirstNode.succ -> any(n|n.target=tSecondNode).condition <- tCondition;	
	}
}

rule processStub(sStub: Turn!Stub){
	using{
		vPlugins : Sequence(Turn!Stub) = OclUndefined;
		tStub : Urn!Stub = thisModule.retrieveNode(sStub);
		tNextNode : Urn!PathNode = OclUndefined;
		tNextPred :  Urn!NodeConnection = OclUndefined;
		tOutPaths : Sequence(Urn!StubOutPath) = OclUndefined;
		tPathEnd : Urn!PathNode = OclUndefined;
		tOrJoin : Urn!OrJoin = OclUndefined;
	}
	do{
		if(not sStub.params.oclIsUndefined()){
			vPlugins <- sStub.params.plugin;
		}
		else{
			vPlugins <- Turn!UCMmap.allInstances() -> any(m|m.name=thisModule.tUCMmap.name).stubs -> collect(s|s.params.plugin) -> flatten();
		}
			
		tStub.bindings <- vPlugins -> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'));
		
		for(outPath in sStub.outPaths){
			thisModule.createNewConnection(tStub);
			
			if(outPath.threshold <> 0){
				tStub.nextFreeConnection().threshold <- outPath.threshold.toString();
			}
			
			if(outPath.path.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				thisModule.processPathBody(outPath.path);
				thisModule.connect(tStub, thisModule.getPathEnd(outPath.path));
			}
		}
		
		--collecting nodes from connecting stub body
		if(not sStub.connectingStubBody.oclIsUndefined()){
			thisModule.processPathBody(sStub.connectingStubBody);
			
			tOutPaths <- sStub.outPaths -> select(op|op.path.pathEnd.oclIsUndefined());
			tNextNode <- tStub;
			
			if(sStub.outPaths -> isEmpty()){
			--	thisModule.createNewConnection(tStub);
			}
			else if(tOutPaths -> size() = 1){
				if(not sStub.connectingStubBody.pathNodes.first().oclIsUndefined()){
					tNextNode <- thisModule.retrieveNode(sStub.connectingStubBody.pathNodes.first());
				}
			}
			else if(tOutPaths -> size() >= 2){
				tOrJoin <- thisModule.createOrJoin();
				thisModule.createNewConnection(tOrJoin);
				thisModule.useConnection(tOrJoin, tStub.succ -> at(tOutPaths -> collect(op|op.index) -> at(1)));
				thisModule.useConnection(tOrJoin, tStub.succ -> at(tOutPaths -> collect(op|op.index) -> at(2)));
				tNextNode <- tOrJoin;
			}
			
			if(sStub.connectingStubBody.pathNodes -> isEmpty()){
				tPathEnd <- thisModule.getPathEnd(sStub.connectingStubBody);
				
				if(tOutPaths -> size() = 1){
					tNextPred <- tNextNode.succ -> at(tOutPaths.first().index);
				}
				else{
					tNextPred <- tNextNode.nextFreeConnection();
				}
				
				if(sStub.connectingStubBody.meetsOrJoinConditions(tPathEnd)){
					tOrJoin <- thisModule.createOrJoin();
					thisModule.connect(tStub, tOrJoin);
					thisModule.useConnection(tOrJoin, tNextPred);
					thisModule.useConnection(tOrJoin, tPathEnd.pred.first().source.succ);
					tNextNode <- tOrJoin;
				}
			}
			
			thisModule.connectPathBody(sStub.connectingStubBody, tNextNode);
		}
		
		tStub;
	}
}

rule processPathBody(sPathBody: Turn!PathNode){
	do{
		thisModule.collectReferencedEnds(sPathBody.pathNodes);
		
		if(not sPathBody.pathEnd.oclIsUndefined()){
			if(sPathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(not sPathBody.pathEnd.regularEnd.oclIsUndefined()){
					thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(thisModule.retrieveNode(sPathBody.pathEnd));
				}
			}
			else{
				thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(thisModule.retrieveNode(sPathBody.pathEnd));
			}
			
			thisModule.processPathEnd(sPathBody.pathEnd);	
		}
	}
}

rule processPathEnd(sPathEnd: Turn!PathBodyNode){
	using{
		tConnect : Urn!Connect = OclUndefined;	
	}
	do{
		if(sPathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(sPathEnd.regularEnd.oclIsUndefined()){
				thisModule.endPointMap <- thisModule.endPointMap.including(sPathEnd.regularEnd, thisModule.createEndPoint());
			}
			else if(thisModule.retrieveNode(sPathEnd.regularEnd).oclIsUndefined()){
				thisModule.processEndPoint(sPathEnd.regularEnd, thisModule.createEndPointUsingNode(sPathEnd.regularEnd));
			}
			
			if(not sPathEnd.connect.oclIsUndefined()){
				tConnect <- thisModule.createConnect();
				thisModule.connect(thisModule.retrieveNode(sPathEnd.regularEnd), tConnect);
				thisModule.connect(tConnect, thisModule.retrieveNode(sPathEnd.connect.connectsTo));
			}
		}
		else if(sPathEnd.oclIsTypeOf(Turn!AndFork)){
			thisModule.processAndFork(sPathEnd);
		}
		else if(sPathEnd.oclIsTypeOf(Turn!OrFork)){
			thisModule.processOrFork(sPathEnd);
		}
		else if(sPathEnd.oclIsTypeOf(Turn!Stub)){
			thisModule.processStub(sPathEnd);
		}
	}
}

rule processUCMmap(tUCMmap: Urn!UCMmap, paths: Sequence(Turn!Path)){
	do{
		thisModule.tUCMmap <- tUCMmap;

		for(path in paths){
			thisModule.connectPath(path);
		}
		
		tUCMmap.connections <- tUCMmap.nodes -> flatten() -> collect(of|of.succ) -> flatten();	
	}
}

rule processContRef(tContRef: Urn!ComponentRef, nodes: Sequence(Urn!StartPoint)){
	using{
		tMetadata : Sequence(Urn!Metadata) = tContRef.metadata -> flatten();
		tFrom : String = 
			if tMetadata -> select(md|md.name='from') -> size() = 1 then
				tMetadata -> select(md|md.name='from').first().value
			else
				''
			endif;
		tTo : String = 
			if tMetadata -> select(md|md.name='to') -> size() = 1 then
				tMetadata -> select(md|md.name='to').first().value
			else
				''
			endif;
		tFromExists : Boolean = 
			(nodes -> select(n|n.name = tFrom) -> size() = 1)
			or (not nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.getRespName()=tFrom) -> isEmpty())
			and not (tFrom = '');
		tToExists : Boolean = 
			(not nodes -> select(n|n.name = tTo) -> isEmpty())
			or (not nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.getRespName()=tTo) -> isEmpty())
			and not (tTo = '');
		vStartNode : Urn!PathNode = OclUndefined;
		vEndNode : Urn!PathNode = OclUndefined;
	}
	do{
		if(tFromExists and tToExists){ --unidirectional, tFrom must be before tTo
			vStartNode <- nodes -> any(n|n.name = tFrom);

			if(vStartNode.oclIsUndefined()){
				vStartNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.getRespName()=tFrom);
			}
			
			vEndNode <- nodes -> any(n|n.name = tTo);
			
			if(vEndNode.oclIsUndefined()){
				vEndNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.getRespName()=tTo);
			}
			
			tContRef.nodes <- thisModule.findPathBetweenNodes(vStartNode, vEndNode);	
		}
	}
}

-- TODO: implement
rule findPathBetweenNodes(tStartNode: Urn!PathNode, tEndNode: Urn!PathNode){
	using{
		vPath : Sequence(Urn!PathNode) = Sequence{tStartNode};	
	}
	do{
		vPath <- vPath.including(tEndNode);
		--thisModule.debug(vPath);
		
		--vPath;
		OclUndefined;
	}
}