module Process;

create OUT : Urn from IN : Turn;

-- Contains all rules used to process a node in order to initialize it.
-- These rules are called in two cases. The first is in a matched rule,
-- to initialize the matched item. The second is in a called rule, to 
-- initialize some object created during a different object's matching.

rule processBinding(s: Turn!Binding, tBinding: Urn!Binding){
	using{
		vBoundTerm : Turn!Binding = OclUndefined;
		vStubItem : Turn!Stub = OclUndefined;
		vStub: Urn!Stub = OclUndefined;
	}
	do{
		if(not s.binding.oclIsUndefined()){
			vBoundTerm <- s.binding;
		}
		else if(not s.bindings.oclIsUndefined()){
			vBoundTerm <- s.bindings;
		}
		
		if(not vBoundTerm.stubParam.stubDec.oclIsUndefined()){
			vStubItem <- vBoundTerm.stubParam.stubDec.stub;
		}
		else if(not vBoundTerm.stubParam.stub.oclIsUndefined()){
			vStubItem <- vBoundTerm.stubParam.stub;
		}
		
		if(not vStubItem.oclIsUndefined() and not thisModule.retrieveNode(vStubItem).pred -> isEmpty()){
			if(s.oclIsTypeOf(Turn!InBinding)){
				tBinding.stubEntry <- thisModule.retrieveNode(vStubItem).pred -> at(s.index);
			}
			else if(s.oclIsTypeOf(Turn!OutBinding)){
				tBinding.stubExit <- thisModule.retrieveNode(vStubItem).succ -> at(s.index);
			}
		}	
	}
}

rule processEndPoint(node: Turn!PathNode, tEndPoint: Turn!EndPoint){
	do{
		tEndPoint.postcondition <- node.condition;
		tEndPoint.name <- node.turnGetLongestName();
		
		thisModule.endPointMap <- thisModule.endPointMap.including(node, tEndPoint);
		
		if(node.epConnect.pbody.pathNodes -> isEmpty()){
			--Using backlinks to connect orFork
			thisModule.currentOrFork <- node.epConnect.pbody.orFork;
			if(not thisModule.currentOrFork.oclIsUndefined()){
				thisModule.condExpression <- thisModule.currentOrFork.condition.expression.asString();
				thisModule.useConnection(tEndPoint, thisModule.retrieveNode(thisModule.currentOrFork.orBody.orFork).succ -> any(s|s.condition.expression=thisModule.condExpression));
			}
			
			--Using backlinks to connect andFork
			thisModule.currentAndFork <- node.epConnect.pbody.andFork;
			if(not thisModule.currentAndFork.oclIsUndefined()){
				thisModule.useConnection(tEndPoint, thisModule.retrieveNode(thisModule.currentAndFork).nextFreeConnection());
			}
		}
		
		tEndPoint;
	}
}

rule processTimer(timerObj : Turn!Timer){
	using{
		tTimer : Urn!Timer = thisModule.retrieveNode(timerObj);
	}
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tTimer);
		
		if(not timerObj.timeoutPath.oclIsUndefined()){
			thisModule.createNewConnection(tTimer);
			thisModule.collectReferencedEnds(timerObj.timeoutPath.pathNodes);
			thisModule.processPathEnd(timerObj.timeoutPath.pathEnd);
			
			if(not timerObj.timeoutCondition.oclIsUndefined()){
				tTimer.succ -> at(2).condition <- thisModule.createCondition(timerObj.timeoutCondition.expression.content -> first());
			}
			
			if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				thisModule.useConnection(thisModule.retrieveNode(timerObj.timeoutPath.pathEnd.regularEnd), tTimer.succ -> at(2));
			}
		}
		
		tTimer;
	}
}

rule handleForkJoin(fork: Urn!PathNode, connectingBody: Turn!PathBody, numberOfTerminatingNodes: Integer){
	using{
		vFirstPathNode : Turn!PathNode = OclUndefined;
		vNextNode : Turn!PathNode = fork;
	}
	do{
		thisModule.collectReferencedEnds(connectingBody.pathNodes);
		thisModule.processPathEnd(connectingBody.pathEnd);
		
		if(numberOfTerminatingNodes = 1){	
			vFirstPathNode <- connectingBody.pathNodes -> first();
			
			if(not vFirstPathNode.oclIsUndefined() and not vFirstPathNode.oclIsTypeOf(Turn!Connect)){
				if(not vFirstPathNode.name.oclIsUndefined()){
					vNextNode <- thisModule.retrieveNode(vFirstPathNode);
				}
			}
		}
		else if(numberOfTerminatingNodes >= 2){
			if(fork.oclIsTypeOf(Urn!Stub) or fork.oclIsTypeOf(Urn!OrFork)){
				vNextNode <- thisModule.createOrJoin();
			}
			else if(fork.oclIsTypeOf(Urn!AndFork)){
				vNextNode <- thisModule.createAndJoin();
			}
			
			if(not fork.oclIsTypeOf(Urn!Stub)){
				thisModule.connectWithEmptyPoint(fork, vNextNode);
			}
		}
		
		vNextNode;
	}
}

rule processAndFork(sAndFork: Turn!AndFork){
	using{
		tAndFork : Urn!AndFork = thisModule.retrieveNode(sAndFork);	
		vNumberOfTerminatingNodes : Integer = 
			if(not sAndFork.connectingAndBody.oclIsUndefined()) then
				sAndFork.pathbody -> select(pb|pb.pathEnd.oclIsUndefined()) -> size()
			else
				0
			endif;
		vNextNode : Turn!PathNode = OclUndefined;
		vNodeToConnect : Urn!PathNode = OclUndefined;
		vOrJoin : Urn!OrJoin = OclUndefined;
	}
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tAndFork);
		
		for(pathbody in sAndFork.pathbody){
			thisModule.createNewConnection(tAndFork);
			thisModule.processPathEnd(pathbody.pathEnd);	
		}
		
		if(not sAndFork.connectingAndBody.oclIsUndefined()){
			vNextNode <- thisModule.handleForkJoin(tAndFork, sAndFork.connectingAndBody, vNumberOfTerminatingNodes);

			if(sAndFork.connectingAndBody.pathNodes -> isEmpty()){
				vNodeToConnect <- thisModule.getNodeToConnect(sAndFork.connectingAndBody);
				
				if(not thisModule.handleOrJoinCase(vNodeToConnect, sAndFork.connectingAndBody, vNextNode)){
					if(vNumberOfTerminatingNodes >= 2){
						thisModule.connect(vNextNode, thisModule.getNodeToConnect(sAndFork.connectingAndBody));
					}
					else{
						thisModule.useConnection(thisModule.getNodeToConnect(sAndFork.connectingAndBody), vNextNode.nextFreeConnection());
					}
				}
			}
			else if(vNumberOfTerminatingNodes >= 2){
				vNextNode.succ <- thisModule.createNodeConnection();
			}
			
			thisModule.connectNodes(sAndFork.connectingAndBody, sAndFork, vNextNode);	
		}
		
		tAndFork;	
	}
}

rule handleOrJoinCase(nodeToConnect: Urn!PathNode, body: Turn!PathBody, nextNode: Urn!PathNode){
	using{
		vOrJoin : Urn!OrJoin = OclUndefined;	
	}
	do{
		if((nodeToConnect.oclIsTypeOf(Urn!EndPoint) and not nodeToConnect.pred -> isEmpty())
			or (not body.referencedStub.oclIsUndefined() and nodeToConnect.pred -> size() >= body.index)
			or 	nodeToConnect.oclIsTypeOf(Urn!RespRef) or nodeToConnect.oclIsTypeOf(Urn!FailurePoint)){
			
			vOrJoin <- thisModule.createOrJoin();
			thisModule.connect(nextNode, vOrJoin);
			thisModule.connect(vOrJoin, nodeToConnect);
			thisModule.useConnection(vOrJoin, (nodeToConnect.pred -> first()).source.succ);
			true;
		}
		else{
			false;	
		}
	}
}

rule connectWithEmptyPoint(currentNode: Turn!PathNode, nextNode: Turn!PathNode){
	using{
		vEmptyPt : Turn!PathNode = OclUndefined;
	}
	do{
		vEmptyPt <- thisModule.createEmptyPoint();
		thisModule.useConnection(nextNode, currentNode.nextFreeConnection());
		thisModule.connect(vEmptyPt, nextNode);
		thisModule.useConnection(vEmptyPt, currentNode.nextFreeConnection());
	}
}

rule processOrFork(sOrFork: Turn!OrFork){
	using{
		tOrFork : Urn!OrFork = thisModule.retrieveNode(sOrFork);
		vNode : Turn!OrFork = OclUndefined;
		vHasTarget : Boolean = OclUndefined;
		vPathbodies : Sequence(Turn!PathBody) = 
			if(sOrFork.body.oclIsUndefined()) then
				Sequence {}
			else 
				sOrFork.body.regularBody -> collect(pb|pb.pathBody) -> flatten()
			endif;
		vNumberOfTerminatingNodes : Integer =
			if(sOrFork.body.oclIsUndefined()) then
				0
			else
				vPathbodies -> select(pb|pb.pathEnd.oclIsUndefined()) -> size()
			endif;
		vConditions : Sequence(Turn!Condition) = OclUndefined;
		vNextNode : Turn!PathNode = OclUndefined;
		vNextPred : Turn!PathNode = OclUndefined;
		vEmptyPt : Turn!PathNode = OclUndefined;
	}
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tOrFork);
		thisModule.collectReferencedEnds(vPathbodies -> collect(pb|pb.pathNodes));
		
		if(sOrFork.body.oclIsUndefined()){
			thisModule.connectWithCondition(tOrFork, thisModule.createEndPointUsingNode(sOrFork), thisModule.createCondition('!' + sOrFork.condition.expression.asString()));
			vNextNode <- thisModule.handleForkJoin(tOrFork, sOrFork.connectingOrBody, vNumberOfTerminatingNodes);
			thisModule.connectWithCondition(tOrFork, thisModule.getNodeToConnect(sOrFork.connectingOrBody), thisModule.resolveTemp(sOrFork.condition, 'tCondition'));
			thisModule.connectNodes(sOrFork.connectingOrBody, sOrFork, vNextNode);
		}
		else{
			for(orFork in sOrFork.body.regularBody){
				thisModule.createNewConnection(tOrFork);
				tOrFork.mostRecentUnusedConnection().condition <- thisModule.resolveTemp(orFork.condition, 'tCondition');
				thisModule.processPathEnd(orFork.pathBody.pathEnd);
			}
			
			if(not sOrFork.body.elseBody.oclIsUndefined()){
				thisModule.collectReferencedEnds(sOrFork.connectingOrBody.pathNodes);
				thisModule.processPathEnd(sOrFork.connectingOrBody.pathEnd);

				vNextNode <- thisModule.createOrJoin();
				
				vEmptyPt <- thisModule.createEmptyPoint();
				thisModule.connectWithCondition(tOrFork, vEmptyPt, thisModule.createCondition('else'));
				thisModule.connect(vEmptyPt, vNextNode);
				
				thisModule.useConnection(vNextNode, tOrFork.nextFreeConnection());

				thisModule.createNewConnection(vNextNode);
				thisModule.useConnection(thisModule.getNodeToConnect(sOrFork.connectingOrBody), vNextNode.nextFreeConnection());
			}
			else if(not sOrFork.connectingOrBody.oclIsUndefined()){
				vNextNode <- thisModule.handleForkJoin(tOrFork, sOrFork.connectingOrBody, vNumberOfTerminatingNodes);
				
				if(vNumberOfTerminatingNodes >= 2){
					vNextNode.succ <- thisModule.createNodeConnection();
				}
				
				if(vPathbodies -> size() = 1){
					thisModule.connectWithCondition(tOrFork, thisModule.createEndPointUsingNode(sOrFork), thisModule.createCondition('!' + vPathbodies.first().orFork.condition.expression.asString()));
				}
				
				vConditions <- vPathbodies -> select(pb|pb.pathEnd.oclIsUndefined()) -> collect(pb|pb.orFork.condition);
				
				for(condition in vConditions){
					if(vPathbodies -> size() = 1){
						if(sOrFork.connectingOrBody.pathNodes -> isEmpty()){
							vNextPred <- vNextNode.nextFreeConnection();
						}
					}
					else{
						vNextPred <- vNextNode.nextFreeConnection();
					}
					
					thisModule.handleEmptyBody(sOrFork.connectingOrBody, thisModule.getNodeToConnect(sOrFork.connectingOrBody), vNextPred);
					
					if(sOrFork.connectingOrBody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
						thisModule.useConnection(thisModule.retrieveNode(sOrFork.connectingOrBody.referencedEnd), vNextPred);
					}
				}
				
				if(vPathbodies -> size() = 1){
					thisModule.connectNodes(sOrFork.connectingOrBody, sOrFork, vNextNode);	
				}
			}
		}

		tOrFork;
	}
}

rule handleEmptyBody(body: Urn!PathBody, nodeToConnect: Urn!PathNode, nextConnection: Urn!NodeConnection){
	using{
		vOrJoin : Urn!OrJoin = OclUndefined;	
	}
	do{
		if((nodeToConnect.oclIsTypeOf(Urn!EndPoint) and not nodeToConnect.pred -> isEmpty())
				or (not body.referencedStub.oclIsUndefined() and nodeToConnect.pred -> size() >= body.index)
				or (nodeToConnect.oclIsTypeOf(Urn!RespRef) or nodeToConnect.oclIsTypeOf(Urn!FailurePoint))
				){
			
			vOrJoin <- thisModule.createOrJoin();
			thisModule.createNewConnection(vOrJoin);
			thisModule.useConnection(vOrJoin, nextConnection);
			thisModule.useConnection(vOrJoin, nodeToConnect.pred.first().source.succ);
			nextConnection <- vOrJoin.nextFreeConnection();
		}
		
		thisModule.useConnection(nodeToConnect, nextConnection);
	}
}

rule processStub(sStub:Turn!Stub){
	using{
		vPlugins : Sequence(Turn!Stub) = OclUndefined;
		tStub : Urn!Stub = thisModule.retrieveNode(sStub);
		vPathEnd : Urn!PathEnd = OclUndefined;
		vPaths : Sequence(Turn!PathBody) = OclUndefined;
		vNextNode : Turn!PathNode = OclUndefined;
		vPathEnds : Sequence(Turn!PathNode) = OclUndefined;
		vCurrentPosition : Integer = 0;
	}
	do{
		if(not sStub.params.oclIsUndefined()){
			vPlugins <- sStub.params.plugin;
		}
		else{
			vPlugins <- Turn!UCMmap.allInstances() -> any(m|m.name=thisModule.tUCMmap.name).stubs -> collect(s|s.params.plugin) -> flatten();
		}
			
		tStub.bindings <- vPlugins -> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'));
		
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tStub);
		
		vPaths <- sStub.outPaths -> flatten() -> collect(op|op.path) -> flatten();
		thisModule.collectReferencedEnds(vPaths -> collect(p|p.pathNodes));
		
		for(outPath in sStub.outPaths -> flatten()){
			thisModule.createNewConnection(tStub);
			if(outPath.threshold <> 0){
				tStub.nextFreeConnection().threshold <- outPath.threshold.toString();
			}
		}
		
		--collecting nodes from connecting stub body
		if(not sStub.connectingStubBody.oclIsUndefined()){
			thisModule.outPaths <- sStub.outPaths -> select(op|op.path.pathEnd.oclIsUndefined());
			thisModule.numberOfTerminatingStubNodes <- thisModule.outPaths -> size();
			
			if(sStub.outPaths -> isEmpty()){
				thisModule.createNewConnection(tStub);
				thisModule.outPathNumber <- 1;
			}
			
			vNextNode <- thisModule.handleForkJoin(tStub, sStub.connectingStubBody, thisModule.numberOfTerminatingStubNodes);
			
			if(thisModule.numberOfTerminatingStubNodes >= 2){
				thisModule.createNewConnection(vNextNode);
			}
			
			if(thisModule.numberOfTerminatingStubNodes = 1){
				thisModule.outPathNumber <- thisModule.outPaths.first().index;	
			}
			else if(thisModule.numberOfTerminatingStubNodes >= 2){
				thisModule.useConnection(vNextNode, tStub.succ -> at(thisModule.outPaths -> collect(op|op.index) -> at(1)));
				thisModule.useConnection(vNextNode, tStub.succ -> at(thisModule.outPaths -> collect(op|op.index) -> at(2)));
				thisModule.outPathNumber <- 1;
			}
			
			if(sStub.connectingStubBody.pathNodes -> isEmpty()){
				thisModule.handleEmptyBody(sStub.connectingStubBody, thisModule.getNodeToConnect(sStub.connectingStubBody), vNextNode.succ -> at(thisModule.outPathNumber));
			}
			
			thisModule.connectNodes(sStub.connectingStubBody, sStub, thisModule.retrieveNode(sStub));

			if(sStub.pbody.pathNodes -> isEmpty() and not sStub.pbody.orFork.oclIsUndefined()){
				thisModule.useConnection(tStub, thisModule.retrieveNode(sStub.pbody.orFork.orBody.orFork).nextFreeConnection());
			}
		}
		
		vPathEnds <- sStub.outPaths -> collect(op|op.path.pathEnd) -> flatten() -> select(pe|pe.oclIsTypeOf(Turn!EndpointWithConnect));
		
		for(pathend in vPathEnds){
			thisModule.processPathEnd(pathend);	
			vCurrentPosition <- vPathEnds.indexOf(pathend);
			thisModule.useConnection(thisModule.retrieveNode(pathend.regularEnd), tStub.succ -> at(vCurrentPosition));
		}
		
		tStub;
	}
}

rule processPathEnd(pathend: Turn!PathNode){
	do{
		if(pathend.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(pathend.regularEnd.oclIsUndefined()){
				thisModule.createEndPoint();
			}
			else if(thisModule.retrieveNode(pathend.regularEnd).oclIsUndefined()){
				thisModule.processEndPoint(pathend.regularEnd, thisModule.createEndPointUsingNode(pathend.regularEnd));
			}
		}
		else if(pathend.oclIsTypeOf(Turn!AndFork)){
			thisModule.processAndFork(pathend);
			thisModule.connectForkNodes(pathend, pathend.pathbody);
		}
		else if(pathend.oclIsTypeOf(Turn!OrFork)){
			thisModule.processOrFork(pathend);
			if(not pathend.body.oclIsUndefined()){
				thisModule.connectForkNodes(pathend, pathend.body.regularBody -> flatten() -> collect(rb|rb.pathBody));
			}
		}
		else if(pathend.oclIsTypeOf(Turn!Stub)){
			thisModule.processStub(pathend);
		}
	}
}

rule processUCMmap(tUCMmap: Urn!UCMmap, paths: Sequence(Turn!Path)){
	using{
		vStartPoint : Urn!StartPoint = OclUndefined;
		vEmptyPoint : Urn!EmptyPoint = OclUndefined;
	}
	do{
		thisModule.tUCMmap <- tUCMmap;
		thisModule.collectReferencedEnds(paths -> flatten() -> collect(p|p.pathBody) -> flatten() -> collect(pb|pb.pathNodes) -> flatten());
		
		for(path in paths){
			thisModule.processPathEnd(path.pathBody.pathEnd);
			
			if(path.startPoint.oclIsUndefined()){
				vStartPoint <- thisModule.createStartPoint();
			}
			else{
				vStartPoint <- thisModule.retrieveNode(path.startPoint);	
			}
			
			if(path.pathBody.pathNodes -> isEmpty()){
				if(path.startPoint.oclIsUndefined()){
					vEmptyPoint <- thisModule.createEmptyPoint();
					thisModule.useConnection(vEmptyPoint, vStartPoint.nextFreeConnection());
					thisModule.connect(vEmptyPoint, thisModule.getNodeToConnect(path.pathBody));
				}
				else if(path.startPoint.connect.oclIsUndefined()){
					thisModule.useConnection(thisModule.getNodeToConnect(path.pathBody), vStartPoint.nextFreeConnection());
				}
			}
			else{
				thisModule.connectNodes(path.pathBody, path.startPoint, vStartPoint);
			}
			
			if(path.pathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(thisModule.retrieveNode(path.pathBody.pathEnd).pred -> isEmpty()){
					thisModule.useConnection(thisModule.getNodeToConnect(path.pathBody), thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ep|not ep.nextFreeConnection().oclIsUndefined()).nextFreeConnection());
				}
			}
		}
		
		tUCMmap.connections <- tUCMmap.nodes -> flatten() -> collect(of|of.succ) -> flatten();	
	}
}

rule processContRef(tContRef: Urn!ComponentRef, nodes: Sequence(Urn!StartPoint)){
	using{
		tMetadata : Sequence(Urn!Metadata) = tContRef.metadata -> flatten();
		tFrom : Urn!Metadata = 
			if tMetadata -> select(md|md.name='from') -> size() = 1 then
				tMetadata -> select(md|md.name='from') -> first().value
			else
				''
			endif;
		tTo : Urn!Metadata = 
			if tMetadata -> select(md|md.name='to') -> size() = 1 then
				tMetadata -> select(md|md.name='to') -> first().value
			else
				''
			endif;
		tFromExists : Boolean = 
			(nodes -> select(n|n.name = tFrom) -> size() = 1)
			or (not nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.getRespName()=tFrom) -> isEmpty())
			and not (tFrom = '');
		tToExists : Boolean = 
			(not nodes -> select(n|n.name = tTo) -> isEmpty())
			or (not nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.getRespName()=tTo) -> isEmpty())
			and not (tTo = '');
		vStartNode : Urn!PathNode = OclUndefined;
		vEndNode : Urn!PathNode = OclUndefined;
	}
	do{
		if(tFromExists and tToExists){ --unidirectional, tFrom must be before tTo
			vStartNode <- nodes -> any(n|n.name = tFrom);

			if(vStartNode.oclIsUndefined()){
				vStartNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.getRespName()=tFrom);
			}
			
			vEndNode <- nodes -> any(n|n.name = tTo);
			
			if(vEndNode.oclIsUndefined()){
				vEndNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.getRespName()=tTo);
			}
			
			tContRef.nodes <- thisModule.findPathBetweenNodes(vStartNode, vEndNode);	
		}
	}
}

-- TODO: implement
rule findPathBetweenNodes(startNode: Urn!PathNode, endNode: Urn!PathNode){
	using{
		vPath : Sequence(Urn!PathNode) = Sequence{startNode};	
	}
	do{
		vPath <- vPath.including(endNode);
		--thisModule.debug(vPath);
		
		--vPath;
		OclUndefined;
	}
}