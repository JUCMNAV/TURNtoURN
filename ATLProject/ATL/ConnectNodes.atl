module ConnectNodes;

create OUT : Urn from IN : Turn;

--QUESTION: are select(s|s.target = OclUndefined) and any(s|s.target.oclIsUndefined()) equivalent here? i.e., will there only ever be one item with s.target = undefined?
-- TODO: determine if this name is appropriate
rule processNode(tUCMmap: Urn!UCMmap, pathbody: Sequence(Turn!PathBody), currentNode: Urn!PathNode, previousNode: Urn!PathNode, isTimer: Boolean){
	using{
		newPred : Urn!PathNode = OclUndefined;
	}
	do{
		if(previousNode.oclIsTypeOf(Turn!WaitingPlace)){
			newPred <- thisModule.resolveTemp(previousNode, 'tWtPlace').firstUnconnectedSucc();
		}
		else if(previousNode.oclIsTypeOf(Turn!FailurePoint)){
			newPred <- thisModule.resolveTemp(previousNode, 'tFailPt').firstUnconnectedSucc();
		}
		else if(not isTimer and previousNode.oclIsTypeOf(Turn!Timer)){
			newPred <- thisModule.timerMap.get(previousNode).firstUnconnectedSucc();
		}
		else if(previousNode.oclIsTypeOf(Turn!Connect)){
			if(previousNode.connectsTo.oclIsTypeOf(Turn!StartPoint)){
				thisModule.addSucc(tUCMmap.getNode(previousNode.connectsTo.name), thisModule.createNodeConnection());
				newPred <- tUCMmap.getNode(previousNode.connectsTo.name).firstUnconnectedSucc();
			}
			else if(previousNode.connectsTo.oclIsTypeOf(Turn!Timer)){
				newPred <- thisModule.connectMap.get(previousNode).firstUnconnectedSucc(); 
			}
			else{
				newPred <- tUCMmap.getNode(previousNode.connectsTo.name).firstUnconnectedSucc();
			}
		}
		else if(isTimer){
			if(previousNode.oclIsTypeOf(Turn!RespRef)){
				newPred <- thisModule.resolveTemp(previousNode, 'tRespRef').succ -> select(s|s.target.oclIsUndefined());
			}
			else {
				newPred <- tUCMmap.getNode(previousNode.name).firstUnconnectedSucc();
			}
		}
		else if(previousNode.oclIsTypeOf(Turn!RespRef)){
			newPred <- thisModule.resolveTemp(previousNode, 'tRespRef').firstUnconnectedSucc();
		}
		else{
			newPred <- tUCMmap.getNode(previousNode.name).succ;
		}
		
		thisModule.addPred(currentNode, newPred);
		OclUndefined; -- RETURN VOID
	}
}

--I'm using the vague term isCaseOne here as I'm not sure of the difference between the two cases / why it is necessary
--TODO: name this more precisely
rule getNodeToConnect(tUCMmap: Urn!UCMmap, currentNode: Turn!PathNode, isCaseOne: Boolean){
	using{
		nodeToJoin : Urn!PathNode = OclUndefined;
		connectedToWaitingPlace : Boolean = false; -- INIT succeeded
	}
	do{
		if(currentNode.oclIsTypeOf(Turn!Connect)){
			connectedToWaitingPlace <- currentNode.connectsTo.oclIsTypeOf(Turn!WaitingPlace);
		}
		
		if(connectedToWaitingPlace){
			nodeToJoin <- tUCMmap.getNode(currentNode.connectsTo.name).firstUnconnectedSucc();	
		}
		else if(isCaseOne){
			nodeToJoin <- tUCMmap.getNode(currentNode.name).firstUnconnectedSucc();
		}
		else{
			nodeToJoin <- tUCMmap.getNode(currentNode.name).succ;
		}
				
		nodeToJoin; -- RETURN Urn!PathNode
	}
}

-- QUESTION: determine why we look at the first node, i.e., pathbody.pathNodes -> first(), rather than the last
-- TODO: determine how the next connecting node is chosen
-- TODO: determine if this name is appropriate
rule handleConnectNode(tUCMmap: Urn!UCMmap, currentNode: Turn!PathNode, previousNode: Turn!PathNode, ITEM: OclAny){
	using{
		vConnectsToTimer : Boolean = currentNode.connectsTo.oclIsTypeOf(Turn!Timer);
		vEmptyPtId : Integer = thisModule.nextId().toString();
		vName : String = 
			if (not vConnectsToTimer) then
				'EmptyPoint'+vEmptyPtId
			else
				'AsynchConnectTimer#'+currentNode.connectsTo.name
			endif;
		vNewNode : Urn!PathNode = OclUndefined;
	}
	to
		tNodeConnection1: Urn!NodeConnection(),
		tConnect: Urn!Connect(
			id <- thisModule.nextId().toString(),
			name <- 'Connect' + tConnect.id,
			diagram <- tUCMmap,
			succ <- tNodeConnection1,
			pred <- tNodeConnection2
		),
		tNodeConnection2: Urn!NodeConnection(),
		tEmptyPt: Urn!EmptyPoint(
			id <- vEmptyPtId,
			name <- vName,
			diagram <- tUCMmap,
			succ <- tNodeConnection2
		)
	do{
		vNewNode <- tEmptyPt;
		
		if(not vConnectsToTimer){
			thisModule.addPred(tUCMmap.getNode(currentNode.connectsTo.name), tConnect.succ);
			vNewNode <- tUCMmap.getNode(currentNode.connectsTo.name);
		}
		else if(previousNode.oclIsTypeOf(Turn!Connect)){
			if(not thisModule.connectMap.get(previousNode.connectsTo).oclIsUndefined()){
				thisModule.addPred(thisModule.connectMap.get(previousNode.connectsTo), tConnect.succ);
			}
		}
		
		thisModule.addPred(vNewNode, ITEM);
		tConnect;
	}
}


--TODO: find a way to reduce the number of arguments for this rule
rule handleForkLogic(tUCMmap: Turn!UCMmap, path: Turn!Path, firstNode: Turn!PathNode, nextNode: Urn!PathNode, case: String){
	do{
		if(case = 'And'){
			thisModule.currentMap <- thisModule.andForkMap;
		}
		else if(case = 'Or'){
			thisModule.currentMap <- thisModule.orForkMap;
		}
		else{
			--there should not be any other cases
		}
	
		thisModule.succeeded <- false;
		
		-- TODO: move this logic up a level into the methods that assign nextNode a value
		if(not nextNode.oclIsUndefined()){
			if(nextNode <> ''){
				thisModule.nextConnectingNode <- nextNode;
				thisModule.succeeded <- true;
			}
		}
		
		if(not thisModule.succeeded){
			thisModule.nextConnectingNode <- thisModule.currentMap.get(path);
		}

		if(firstNode.oclIsTypeOf(Turn!RespRef)){
			thisModule.addPred(thisModule.resolveTemp(firstNode ,'tRespRef'), thisModule.nextConnectingNode.firstUnconnectedSucc());
		}
		else if(firstNode.oclIsTypeOf(Turn!Connect)){
			-- look for asynchronous connect (QUESTION: what does this mean?)
			if(case = 'And'){ --AND case
				thisModule.connect <- thisModule.handleConnectNode(tUCMmap, firstNode, OclUndefined, thisModule.nextConnectingNode.firstUnconnectedSucc());
			}
			else if(case = 'Or'){ --OR case
				thisModule.connect <- thisModule.handleConnectNode(tUCMmap, firstNode, OclUndefined, thisModule.nextConnectingNode.succ -> first());
			}

			thisModule.connectMap <- thisModule.connectMap.including(firstNode, thisModule.connect);
		}
		else{
			if(firstNode.oclIsTypeOf(Turn!Timer)){
				thisModule.createTimer(tUCMmap, firstNode);
			}
			thisModule.addPred(tUCMmap.getNode(firstNode.name), thisModule.nextConnectingNode.firstUnconnectedSucc());
		}
		
		--ADDED FOR TIMER AND ORFORK CONNECTION
		if(firstNode.oclIsTypeOf(Turn!Timer)){
			thisModule.addPred(tUCMmap.getNode(firstNode.name), thisModule.currentMap.get(path).succ -> first());
		}
	}
}

--QUESTION: there doesn't appear to be a Turn!PathNode class. What should I use instead?
rule handleFirstNode(tUCMmap: Urn!UCMmap, path: Turn!Path, firstNode: Turn!PathNode, nextNode: Urn!PathNode){
	do{
		if(path.oclIsTypeOf(Turn!Path)){
			thisModule.startPoint <- tUCMmap.getNode(path.startPoint.name);
			
			if(firstNode.oclIsTypeOf(Turn!RespRef)){
				thisModule.addPred(thisModule.resolveTemp(firstNode, 'tRespRef'), thisModule.startPoint.succ -> first());
			}
			else if(firstNode.oclIsTypeOf(Turn!Timer)){
				thisModule.createTimer(tUCMmap, firstNode);
				thisModule.addPred(thisModule.timerMap.get(firstNode), thisModule.startPoint.succ);
			} --with an else
			else if(firstNode.oclIsTypeOf(Turn!Connect)) {
				thisModule.connect <- thisModule.handleConnectNode(tUCMmap, firstNode, OclUndefined, thisModule.startPoint.firstUnconnectedSucc());
				thisModule.connectMap <- thisModule.connectMap.including(firstNode, thisModule.connect);
			}
			else if(firstNode.oclIsTypeOf(Turn!WaitingPlace)){
				if(not firstNode.connect.oclIsUndefined() and not tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> isEmpty()){
					thisModule.addPred(tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ept|ept.succ -> includes(thisModule.connectMap.get(firstNode.connect).pred -> first())), thisModule.startPoint.succ);
				}
				else{
					thisModule.addPred(thisModule.resolveTemp(firstNode, 'tWtPlace'), thisModule.startPoint.succ);
				}
			}
			else if(firstNode.oclIsTypeOf(Turn!FailurePoint)){
				thisModule.addPred(thisModule.resolveTemp(firstNode, 'tFailPt'), thisModule.startPoint.succ);
			}
			else{
				thisModule.addPred(tUCMmap.getNode(firstNode.name), thisModule.startPoint.succ);
			}
		}
		else if(path.oclIsTypeOf(Turn!OrFork)){
			thisModule.handleForkLogic(tUCMmap, path, firstNode, nextNode, 'Or');
		}
		else if (path.oclIsTypeOf(Urn!OrJoin)){
			thisModule.succeeded <- false;
			
			if(firstNode.oclIsTypeOf(Turn!RespRef)){
				if(thisModule.getResponsibility(firstNode.name).respRefs -> select(r|r.diagram.name=tUCMmap.name) -> isEmpty()){
					thisModule.addPred((thisModule.getResponsibility(firstNode.name).respRefs -> any(r|r.diagram.name=tUCMmap.name)), tUCMmap.getNode(path.name).succ);
					thisModule.succeeded <- true;
				}
			}
			
			if(not thisModule.succeeded){
				thisModule.addPred(tUCMmap.getNode(firstNode.name), tUCMmap.getNode(path.name).succ -> first());
			}
		}
		else if(path.oclIsTypeOf(Turn!AndFork)){
			thisModule.handleForkLogic(tUCMmap, path, firstNode, nextNode, 'And');
		}
		else {
			thisModule.currentNode <- thisModule.stubMap.get(path);
			
			if(firstNode.oclIsTypeOf(Turn!RespRef)){
				thisModule.addPred(thisModule.resolveTemp(firstNode, 'tRespRef'), thisModule.currentNode.succ -> first());
			} 
			else if(firstNode.oclIsTypeOf(Turn!Timer)){
				thisModule.addPred(thisModule.createTimer(tUCMmap, firstNode), tUCMmap.getNode(path.name).succ -> first());
			}
			else if(firstNode.oclIsTypeOf(Turn!Connect)){
				thisModule.connect <- thisModule.handleConnectNode(tUCMmap, firstNode, OclUndefined, thisModule.currentNode.firstUnconnectedSucc());
				thisModule.connectMap <- thisModule.connectMap.including(firstNode, thisModule.connect);
			}
			else if(firstNode.oclIsTypeOf(Turn!WaitingPlace)){
				thisModule.addPred(thisModule.resolveTemp(firstNode, 'tWtPlace'), thisModule.currentNode.firstUnconnectedSucc());
			}
			else if(firstNode.oclIsTypeOf(Turn!FailurePoint)){
				thisModule.addPred(thisModule.resolveTemp(firstNode, 'tFailPt'), thisModule.currentNode.firstUnconnectedSucc());
			}
			else{
				thisModule.addPred(tUCMmap.getNode(firstNode.name), tUCMmap.getNode(path.name).succ -> first());
			}
		}
	}
}

rule handleNode(tUCMmap: Turn!UCMmap, pathbody: Sequence(Turn!PathBody), currentNode: Turn!PathNode, previousNode: Turn!PathNode){
	do{
		if(currentNode.oclIsTypeOf(Turn!WaitingPlace)){
			thisModule.processNode(tUCMmap, pathbody, thisModule.resolveTemp(currentNode, 'tWtPlace'), previousNode, false);
		}
		else if(currentNode.oclIsTypeOf(Turn!FailurePoint)){
			thisModule.processNode(tUCMmap, pathbody, thisModule.resolveTemp(currentNode, 'tFailPt'), previousNode, false);
		}
		else if(currentNode.oclIsTypeOf(Turn!RespRef)){
			thisModule.processNode(tUCMmap, pathbody, thisModule.resolveTemp(currentNode, 'tRespRef'), previousNode, false);
		}
		--NEED TO CREATE TIMER FOR ALL OTHER COMBINATIONS
		else if(currentNode.oclIsTypeOf(Turn!Timer)){
			thisModule.processNode(tUCMmap, pathbody, thisModule.createTimer(tUCMmap, currentNode), previousNode, true);
		}
		--NEED TO CREATE CONNECT FOR ALL OTHER COMBINATIONS
		else if(currentNode.oclIsTypeOf(Turn!Connect)){
			thisModule.pred <- '';
			
			if(previousNode.oclIsTypeOf(Turn!RespRef)){
				thisModule.pred <- tUCMmap.allRespDefsMatching(previousNode.name) -> any(s|not s.pred.oclIsUndefined()).succ;
			}
			else if(previousNode.oclIsTypeOf(Turn!Connect)){
				thisModule.pred <- tUCMmap.getNode(previousNode.connectsTo.name).firstUnconnectedSucc();
			}
			else{
				thisModule.pred <- tUCMmap.getNode(previousNode.name).succ;
			}
			
			thisModule.connect <- thisModule.handleConnectNode(tUCMmap, currentNode, previousNode, thisModule.pred);
			
			thisModule.connectMap <- thisModule.connectMap.including(currentNode, thisModule.connect);
		}
		-- DOUBLE CHECK IF THIS IS REQUIRED
		else if(previousNode.oclIsTypeOf(Turn!RespRef)){
			thisModule.addPred(tUCMmap.getNode(currentNode.name), tUCMmap.allRespDefsMatching(previousNode.name) -> collect(s|s.succ) -> flatten() -> select(s|s.target.oclIsUndefined()));
		}
		else if (previousNode.oclIsTypeOf(Turn!Connect)){
			if(previousNode.connectsTo.oclIsTypeOf(Turn!Timer)){
				thisModule.addPred(tUCMmap.getNode(currentNode.name), thisModule.connectMap.get(previousNode).firstUnconnectedSucc()); 
			}
			else{
				if(previousNode.connectsTo.oclIsTypeOf(Turn!StartPoint)){
					thisModule.addSucc(tUCMmap.getNode(previousNode.connectsTo.name).succ, thisModule.createNodeConnection());
				}
				thisModule.addPred(tUCMmap.getNode(currentNode.name), tUCMmap.getNode(previousNode.connectsTo.name).firstUnconnectedSucc());
			}
		}
		else{
			thisModule.addPred(tUCMmap.getNode(currentNode.name), tUCMmap.getNode(previousNode.name).succ);
		}
	}
}

rule handleRegularEnds(tUCMmap: Urn!UCMmap, pathbody: Sequence(Turn!PathBody), currentNode: Turn!PathNode, nextNode: Turn!PathNode){
	do{
		if(currentNode.oclIsTypeOf(Turn!RespRef)){
			thisModule.nextNode <- thisModule.resolveTemp(currentNode ,'tRespRef').firstUnconnectedSucc();
			
			--QUESTION: is it possible for something to be both Turn!RespRef and Turn!Connect
			if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect) and currentNode.oclIsTypeOf(Turn!Connect)){
				thisModule.addPred(tUCMmap.getNode(pathbody.pathEnd.regularEnd.name), tUCMmap.getNode(currentNode.connectsTo.name).succ);
			}
			else if (pathbody.pathEnd.oclIsTypeOf(Turn!Stub)){
				thisModule.addPred(thisModule.stubMap.get(pathbody.pathEnd), thisModule.nextNode);
			}
			else{
				thisModule.connectPathEndToNextNode(tUCMmap, pathbody.pathEnd, thisModule.nextNode);
			}
		}
		else if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
			thisModule.newPred <- ''; --TODO: determine a proper name for this
			
			if(not currentNode.oclIsTypeOf(Turn!Connect)){
				if(currentNode.oclIsTypeOf(Turn!WaitingPlace)){
					if(not currentNode.connect.oclIsUndefined() and not tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> isEmpty()){
						thisModule.newPred <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ept|ept.succ -> includes(thisModule.connectMap.get(currentNode.connect).pred -> first())).firstUnconnectedSucc();
					}
					else{
						thisModule.newPred <- thisModule.resolveTemp(currentNode, 'tWtPlace').firstUnconnectedSucc();
					}
				}
				else if(currentNode.oclIsTypeOf(Turn!FailurePoint)){
					thisModule.newPred <- thisModule.resolveTemp(currentNode, 'tFailPt').firstUnconnectedSucc();
				}
				else if(currentNode.oclIsTypeOf(Turn!Timer)){
					thisModule.newPred <- thisModule.timerMap.get(currentNode).firstUnconnectedSucc();
				}
				else{
					thisModule.newPred <- tUCMmap.getNode(currentNode.name).firstUnconnectedSucc();
				}
			}
			else if(currentNode.connectsTo.oclIsTypeOf(Turn!Timer)){
				thisModule.newPred <- thisModule.connectMap.get(currentNode).firstUnconnectedSucc(); 
			}
			else{
				--in case of a connect
				if(currentNode.connectsTo.oclIsTypeOf(Turn!StartPoint)){
					thisModule.addSucc(tUCMmap.getNode(currentNode.connectsTo.name), thisModule.createNodeConnection());
				}
				thisModule.newPred <- tUCMmap.getNode(currentNode.connectsTo.name).firstUnconnectedSucc();
			}
			
			thisModule.addPred(tUCMmap.getNode(pathbody.pathEnd.regularEnd.name), thisModule.newPred);
		}
		else if(pathbody.pathEnd.oclIsTypeOf(Turn!OrFork)){
			thisModule.addPred(thisModule.orForkMap.get(pathbody.pathEnd), thisModule.getNodeToConnect(tUCMmap, currentNode, true));
		}
		else if(pathbody.pathEnd.oclIsTypeOf(Turn!AndFork)){
			thisModule.addPred(thisModule.andForkMap.get(pathbody.pathEnd), thisModule.getNodeToConnect(tUCMmap, currentNode, true));
		}
		else if(pathbody.pathEnd.oclIsTypeOf(Turn!Stub)){
			if(currentNode.oclIsTypeOf(Turn!Timer)){
				thisModule.addPred(thisModule.stubMap.get(pathbody.pathEnd), thisModule.timerMap.get(currentNode).firstUnconnectedSucc());
			}
			else if(currentNode.oclIsTypeOf(Turn!Stub)){
				thisModule.addPred(thisModule.stubMap.get(pathbody.pathEnd), thisModule.stubMap.get(currentNode).firstUnconnectedSucc());
			}
			else{
				thisModule.addPred(thisModule.stubMap.get(pathbody.pathEnd), thisModule.getNodeToConnect(tUCMmap, currentNode, true));
			}
		}	
	}
}

rule handleReferencedEnds(tUCMmap: Turn!UCMmap, pathbody: Sequence(Turn!Pathbody), currentNode: Turn!PathNode){
	do{
		if(currentNode.oclIsTypeOf(Turn!RespRef)){
			if(pathbody.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				thisModule.addPred(tUCMmap.getNode(pathbody.referencedEnd.name), tUCMmap.allRespDefsMatching(currentNode.name) -> collect(s|s.succ) -> flatten() -> select(s|s.target.oclIsUndefined()));
			}
			else if (pathbody.referencedEnd.oclIsTypeOf(Turn!OrFork)){
				thisModule.addPred(thisModule.orForkMap.get(pathbody.pathEnd), thisModule.getResponsibility(currentNode.name).respRefs -> any(r|r.diagram.name = tUCMmap.name).succ);
			}
			else if (pathbody.referencedEnd.oclIsTypeOf(Turn!AndFork)){
				thisModule.addPred(thisModule.andForkMap.get(pathbody.pathEnd), thisModule.getResponsibility(currentNode.name).respRefs -> any(r|r.diagram.name = tUCMmap.name).succ);
			}
			else if (pathbody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
				thisModule.addPred(tUCMmap.firstRespDefMatching(pathbody.referencedEnd.name), tUCMmap.allRespDefsMatching(currentNode.name) -> collect(s|s.succ) -> flatten() -> select(s|s.target.oclIsUndefined()));
			}
			else{
				thisModule.addPred(tUCMmap.getNode(pathbody.referencedEnd.name), tUCMmap.allRespDefsMatching(currentNode.name) -> collect(s|s.succ) -> flatten() -> select(s|s.target.oclIsUndefined()));
			}
		}
		else if(pathbody.referencedEnd.oclIsTypeOf(Turn!OrFork)){
			thisModule.addPred(thisModule.orForkMap.get(pathbody.referencedEnd), tUCMmap.getNode(currentNode.name).firstUnconnectedSucc());
		}
		else if(pathbody.referencedEnd.oclIsTypeOf(Turn!AndFork)){
			thisModule.addPred(thisModule.andForkMap.get(pathbody.referencedEnd), tUCMmap.getNode(currentNode.name).firstUnconnectedSucc());
		}
		else if(pathbody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
			thisModule.addPred(thisModule.resolveTemp(pathbody.referencedEnd,'tRespRef'), thisModule.getNodeToConnect(tUCMmap, currentNode, true));
		}
		else{
			thisModule.succeeded <- false;
			
			if(pathbody.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(not currentNode.oclIsTypeOf(Turn!Connect)){
					if(tUCMmap.getNode(pathbody.referencedEnd.name).pred -> collect(s|s.source) -> isEmpty()){
						thisModule.addPred(tUCMmap.getNode(pathbody.referencedEnd.name), tUCMmap.getNode(currentNode.name).succ);
						thisModule.succeeded <- true;
					}
				}
			}
			
			if(not thisModule.succeeded){
				thisModule.addPred(tUCMmap.getNode(pathbody.referencedEnd.name), thisModule.getNodeToConnect(tUCMmap, currentNode, false));	
			}
		}	
	}
}

rule handleReferencedStubs(tUCMmap: Urn!UCMmap, pathbody: Sequence(Turn!Pathbody), currentNode: Turn!PathNode){
	do{
		if(currentNode.oclIsTypeOf(Turn!RespRef)){
			thisModule.nextNode <- '';
			
			if(tUCMmap.getNode(pathbody.referencedStub.name).pred -> size() >= pathbody.index){
				thisModule.nextNode <- tUCMmap.firstRespDefMatching(currentNode.name).succ;
			}
			else{
				thisModule.nextNode <- tUCMmap.allRespDefsMatching(currentNode.name) -> collect(s|s.succ) -> flatten() -> select(s|s.target.oclIsUndefined());
			}
			
			thisModule.processReferencedStub(tUCMmap, pathbody, thisModule.nextNode);
		}
		else if(tUCMmap.getNode(pathbody.referencedStub.name).pred -> size() >= pathbody.index){
			thisModule.firstPred <- tUCMmap.getNode(pathbody.referencedStub.name).pred -> first().source;
			
			thisModule.orJoinPred <- thisModule.getNodeToConnect(tUCMmap, currentNode, false);
			
			thisModule.orJoin <- thisModule.createOrJoin(tUCMmap, thisModule.orJoinPred);
			thisModule.addPred(thisModule.orJoin, thisModule.firstPred.succ);
			thisModule.addPred(tUCMmap.getNode(pathbody.referencedStub.name), thisModule.orJoin.succ);
		}
		else{
			thisModule.addPred(tUCMmap.getNode(pathbody.referencedStub.name), thisModule.getNodeToConnect(tUCMmap, currentNode, false));
		}
	}
}

rule connectNodes(pathbody: Sequence(Turn!PathBody), path: Turn!Path, tUCMmap: Urn!UCMmap, nextNode: Urn!PathNode){
	do{
		if(not pathbody.pathNodes -> isEmpty()){
			thisModule.previousNode <- '';
			
			for (currentNode in pathbody.pathNodes){
				
				if(thisModule.previousNode = ''){
					thisModule.handleFirstNode(tUCMmap, path, currentNode, nextNode);
				}
				else{
					thisModule.handleNode(tUCMmap, pathbody, currentNode, thisModule.previousNode);
				}
				
				if(currentNode <> pathbody.pathNodes -> last()){
					thisModule.previousNode <- currentNode;
				}
			}
			
			thisModule.lastNode <- pathbody.pathNodes -> last();
			
			if(not pathbody.pathEnd.oclIsUndefined()){
				thisModule.handleRegularEnds(tUCMmap, pathbody, thisModule.lastNode);
			}
			else if(not pathbody.referencedEnd.oclIsUndefined()){
				thisModule.handleReferencedEnds(tUCMmap, pathbody, thisModule.lastNode);
			}
			else if(not pathbody.referencedStub.oclIsUndefined()){
				thisModule.handleReferencedStubs(tUCMmap, pathbody, thisModule.lastNode, thisModule.previousNode);
			}
		}
	}
}