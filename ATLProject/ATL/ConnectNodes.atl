module ConnectNodes;

create OUT : Urn from IN : Turn;

rule getNodeToConnect(currentNode: Turn!PathNode){
	using{
		vNodeToJoin : Urn!PathNode = OclUndefined;
		vConnectedToWaitingPlace : Boolean = 
			if(currentNode.oclIsTypeOf(Turn!Connect)) then
				currentNode.connectsTo.oclIsTypeOf(Turn!WaitingPlace)
			else
				false
			endif;
	}
	do{
		if(vConnectedToWaitingPlace){
			vNodeToJoin <- thisModule.retrieveNode(currentNode.connectsTo).firstUnconnectedSucc();	
		}
		else{
			vNodeToJoin <- thisModule.retrieveNode(currentNode).succ;
		}
				
		vNodeToJoin;
	}
}

-- QUESTION: determine why we look at the first node, i.e., pathbody.pathNodes -> first(), rather than the last
-- TODO: determine how the next connecting node is chosen
rule createEmptyPointConnect(currentNode: Turn!PathNode, newPred: Urn!PathNode){
	to
		tNodeConnection1: Urn!NodeConnection(),
		tConnect: Urn!Connect(
			id <- thisModule.nextId().toString(),
			name <- 'Connect' + tConnect.id,
			diagram <- thisModule.tUCMmap,
			succ <- tNodeConnection1,
			pred <- tNodeConnection2
		),
		tNodeConnection2: Urn!NodeConnection(),
		tEmptyPt: Urn!EmptyPoint(
			id <- thisModule.nextId().toString(),
			name <- 'EmptyPoint'+tEmptyPt.id,
			diagram <- thisModule.tUCMmap,
			succ <- tNodeConnection2
		)
	do{
		if(currentNode.connectsTo.oclIsTypeOf(Turn!Timer)){
			tEmptyPt.name <- 'AsynchConnectTimer#'+currentNode.connectsTo.name;
			thisModule.addPred(tEmptyPt, newPred);
		}
		else{
			thisModule.addPred(thisModule.retrieveNode(currentNode.connectsTo), tNodeConnection1);
			thisModule.addPred(thisModule.retrieveNode(currentNode.connectsTo), newPred);
		}
		thisModule.connectMap <- thisModule.connectMap.including(currentNode, tConnect);
		tConnect;
	}
}

--QUESTION: there doesn't appear to be a Turn!PathNode class. What should I use instead?
rule handleFirstNode(node: Turn!PathNode, firstNode: Turn!PathNode, nextNode: Urn!PathNode){
	do{
		if(node.oclIsTypeOf(Turn!StartPoint)){
			if(firstNode.oclIsTypeOf(Turn!WaitingPlace)){
				if(not firstNode.connect.oclIsUndefined()){
					--thisModule.debug(thisModule.tUCMmap.nodes -> any(n|n.oclIsTypeOf(Urn!EmptyPoint) and n.succ -> includes(thisModule.retrieveNode(firstNode.connect).pred -> first())).oclType());
					thisModule.addPred(thisModule.tUCMmap.nodes -> any(n|n.oclIsTypeOf(Urn!EmptyPoint) and n.succ -> includes(thisModule.retrieveNode(firstNode.connect).pred -> first())), thisModule.retrieveNode(node).firstUnconnectedSucc());
				}
				else{
					thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).firstUnconnectedSucc());
				}
			}
			else if(firstNode.oclIsTypeOf(Turn!Connect)) {
				thisModule.createEmptyPointConnect(firstNode, thisModule.retrieveNode(node).firstUnconnectedSucc());
			}
			else{
				thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).firstUnconnectedSucc());
			}
		}
		else if(node.oclIsTypeOf(Turn!OrFork) or node.oclIsTypeOf(Turn!AndFork)){
			if(nextNode.oclIsUndefined()){
				nextNode <- thisModule.retrieveNode(node);
			}
	
			if(firstNode.oclIsTypeOf(Turn!Connect)){
				if(node.oclIsTypeOf(Turn!AndFork)){
					thisModule.createEmptyPointConnect(firstNode, nextNode.firstUnconnectedSucc());
				}
				else if(node.oclIsTypeOf(Turn!OrFork)){
					thisModule.createEmptyPointConnect(firstNode, nextNode.succ -> first());
				}
			}
			else{
				thisModule.addPred(thisModule.retrieveNode(firstNode), nextNode.firstUnconnectedSucc());
			}
			
			if(firstNode.oclIsTypeOf(Turn!Timer) and node.oclIsTypeOf(Turn!OrFork)){
				thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).succ -> first());
			}
		}
		--else if(node.oclIsTypeOf(Turn!OrJoin) and firstNode.oclIsTypeOf(Turn!RespRef)){
			--if(thisModule.getResponsibility(firstNode.name).respRefs -> select(r|r.diagram.name=thisModule.tUCMmap.name) -> isEmpty()){
			--	thisModule.addPred((thisModule.getResponsibility(firstNode.name).respRefs -> any(r|r.diagram.name=thisModule.tUCMmap.name)), thisModule.retrieveNode(node).succ);
			--}
			--else{
			--	thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).succ -> firstUnconnectedSucc());
			--}
		--}
		else if(firstNode.oclIsTypeOf(Turn!Connect)){
			thisModule.createEmptyPointConnect(firstNode, thisModule.retrieveNode(node).firstUnconnectedSucc());
		}
		else{
			thisModule.addPred(thisModule.retrieveNode(firstNode), thisModule.retrieveNode(node).firstUnconnectedSucc());
		}
	}
}
	
rule handleNode(currentNode: Turn!PathNode, previousNode: Turn!PathNode){
	using{
		vConnect : Turn!PathNode = OclUndefined;
	}
	do{
		if(currentNode.oclIsTypeOf(Turn!Connect)){
			if(previousNode.oclIsTypeOf(Turn!Connect)){
				vConnect <- thisModule.createEmptyPointConnect(currentNode, thisModule.retrieveNode(previousNode.connectsTo).succ);
			--	if(not thisModule.connectMap.get(previousNode.connectsTo).oclIsUndefined()){
			--		thisModule.addPred(thisModule.connectMap.get(previousNode.connectsTo), vConnect.succ);
			--	}
			}
			else{
				thisModule.createEmptyPointConnect(currentNode, thisModule.retrieveNode(previousNode).succ);
			}
		}
		else if(previousNode.oclIsTypeOf(Turn!RespRef) and not (currentNode.oclIsTypeOf(Turn!Timer) or currentNode.oclIsTypeOf(Turn!WaitingPlace) or currentNode.oclIsTypeOf(Turn!FailurePoint) or currentNode.oclIsTypeOf(Turn!RespRef))){
			thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.tUCMmap.allRespDefsMatching(previousNode.name) -> collect(s|s.succ) -> flatten() -> select(s|s.target.oclIsUndefined()));
		}
		else if(previousNode.oclIsTypeOf(Turn!Connect)){
			--if(previousNode.connectsTo.oclIsTypeOf(Turn!Timer)){
			--	thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.connectMap.get(previousNode).firstUnconnectedSucc()); 
			--}
			--else{
				--if(currentNode.oclIsTypeOf(Turn!Timer) or currentNode.oclIsTypeOf(Turn!WaitingPlace) or currentNode.oclIsTypeOf(Turn!FailurePoint) or currentNode.oclIsTypeOf(Turn!RespRef)){
				--	thisModule.addSucc(thisModule.retrieveNode(previousNode.connectsTo), thisModule.createNodeConnection());
				--}
				--else{
				--	thisModule.addSucc(thisModule.retrieveNode(previousNode.connectsTo).succ, thisModule.createNodeConnection());
				--}
				thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.retrieveNode(previousNode.connectsTo).firstUnconnectedSucc());
			--}
		}
		else{
			thisModule.addPred(thisModule.retrieveNode(currentNode), thisModule.retrieveNode(previousNode).firstUnconnectedSucc());
		}
	}
}

rule handleRegularEnds(pathend: Turn!PathNode, currentNode: Turn!PathNode){
	using{
		vNewPred : Turn!PathNode = OclUndefined;	
	}
	do{
		if(currentNode.oclIsTypeOf(Turn!RespRef)){
			--QUESTION: is it possible for something to be both Turn!RespRef and Turn!Connect
			if(pathend.oclIsTypeOf(Turn!EndpointWithConnect) and currentNode.oclIsTypeOf(Turn!Connect)){
				thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode.connectsTo).firstUnconnectedSucc());
			}
			else if (pathend.oclIsTypeOf(Turn!Stub)){
				thisModule.addPred(thisModule.retrieveNode(pathend), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
			}
			else{
				thisModule.connectPathEndToNextNode(pathend, thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
			}
		}
		else if(pathend.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(currentNode.oclIsTypeOf(Turn!Connect)){
				if(currentNode.connectsTo.oclIsTypeOf(Turn!Timer)){
					thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
				}
				else{
					if(currentNode.connectsTo.oclIsTypeOf(Turn!StartPoint)){
						thisModule.addSucc(thisModule.retrieveNode(currentNode.connectsTo), thisModule.createNodeConnection());
					}
					thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode.connectsTo).firstUnconnectedSucc());
				}
			}
			else if(currentNode.oclIsTypeOf(Turn!WaitingPlace)){
				if(not currentNode.connect.oclIsUndefined() and not thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> isEmpty()){
					--vNewPred <- thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ept|ept.succ -> includes(thisModule.connectMap.get(currentNode.connect).pred -> first())).firstUnconnectedSucc();
					--thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), vNewPred);
				}
				else{
					thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
				}
			}
			else{
				thisModule.addPred(thisModule.retrieveNode(pathend.regularEnd), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
			}
		}
		else if(pathend.oclIsTypeOf(Turn!Stub) and (currentNode.oclIsTypeOf(Turn!Timer) or currentNode.oclIsTypeOf(Turn!Stub))){
			thisModule.addPred(thisModule.retrieveNode(pathend), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
		}
		else if(pathend.oclIsTypeOf(Turn!Stub) or pathend.oclIsTypeOf(Turn!OrFork) or pathend.oclIsTypeOf(Turn!AndFork)){
			thisModule.addPred(thisModule.retrieveNode(pathend), thisModule.getNodeToConnect(currentNode));
		}
	}
}

rule handleReferencedEnds(referencedEnd: Turn!PathNode, currentNode: Turn!PathNode){
	do{
		--if(currentNode.oclIsTypeOf(Turn!RespRef)){
			--if (referencedEnd.oclIsTypeOf(Turn!OrFork) or referencedEnd.oclIsTypeOf(Turn!AndFork)){
			--	thisModule.addPred(thisModule.retrieveNode(referencedEnd), thisModule.getResponsibility(currentNode.name).respRefs -> any(r|r.diagram.name=thisModule.tUCMmap.name).succ);
			--}
			--else{
		--		thisModule.addPred(thisModule.retrieveNode(referencedEnd), thisModule.tUCMmap.allRespDefsMatching(currentNode.name) -> collect(s|s.succ) -> flatten() -> select(s|s.target.oclIsUndefined()));
			--}
		--}
		--else if(referencedEnd.oclIsTypeOf(Turn!OrFork) or referencedEnd.oclIsTypeOf(Turn!AndFork)){
		--	thisModule.addPred(thisModule.retrieveNode(referencedEnd), thisModule.retrieveNode(currentNode).firstUnconnectedSucc());
		--}
		--else if(referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
		--	if(not currentNode.oclIsTypeOf(Turn!Connect)){
		--		if(thisModule.retrieveNode(referencedEnd).pred -> collect(s|s.source) -> isEmpty()){
		--			thisModule.addPred(thisModule.retrieveNode(referencedEnd), thisModule.retrieveNode(currentNode).succ);
		--		}
		--	}
		--}
		--else{
			thisModule.addPred(thisModule.retrieveNode(referencedEnd), thisModule.getNodeToConnect(currentNode));	
		--}	
	}
}

rule connectNodes(pathbody: Sequence(Turn!PathBody), node: Turn!PathNode, nextNode: Urn!PathNode){
	using{
		vPreviousNode : Turn!PathNode = OclUndefined;
		vLastNode : Turn!PathNode = pathbody.pathNodes -> last();
	}
	do{
		if(not pathbody.pathNodes -> isEmpty()){
			for (currentNode in pathbody.pathNodes){
				if(currentNode.oclIsTypeOf(Turn!Timer)){
					thisModule.processTimer(currentNode);	
				}
				
				if(vPreviousNode.oclIsUndefined()){
					thisModule.handleFirstNode(node, currentNode, nextNode);
				}
				else{
					thisModule.handleNode(currentNode, vPreviousNode);
				}
				
				if(currentNode <> vLastNode){
					vPreviousNode <- currentNode;
				}
			}
	
			if(not pathbody.pathEnd.oclIsUndefined()){
				thisModule.handleRegularEnds(pathbody.pathEnd, vLastNode);
			}
			else if(not pathbody.referencedEnd.oclIsUndefined()){
				thisModule.handleReferencedEnds(pathbody.referencedEnd, vLastNode);
			}
			else if(not pathbody.referencedStub.oclIsUndefined()){-- and not vPreviousNode.oclIsUndefined()){
				--if(vLastNode.oclIsTypeOf(Turn!RespRef)){
				--	thisModule.processReferencedStub(pathbody, thisModule.retrieveNode(vLastNode).succ);
				--}
				--else{
					thisModule.processReferencedStub(pathbody, thisModule.getNodeToConnect(vLastNode));
				--}
			}
		}
	}
}