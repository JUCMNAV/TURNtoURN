module ConnectNodes;

create OUT : Urn from IN : Turn;

rule connectNodes(pathbody: Sequence(Turn!PathBody), path: Turn!Path, tUCMmap: Urn!UCMmap, nextNode: Urn!PathNode){
	do{ 
		thisModule.nodeCounter <- 1;
		for (node in pathbody.pathNodes){
			if(thisModule.nodeCounter = 1){
				if(path.oclIsTypeOf(Turn!Path)){
					node; --path1statement1
				}
				--else if(path.oclIsTypeOf(Turn!OrFork)){
				--	node; --path1statement2
				--}
				--else if (path.oclIsTypeOf(Urn!OrJoin)){
				--	node; --path1statement3
				--}
				--else if(path.oclIsTypeOf(Turn!AndFork)){
				--	node; --path1statement4
				--}
				--else if(node.oclIsTypeOf(Turn!RespRef)){
				--	thisModule.resolveTemp(node, 'tRespRef').pred <- thisModule.stubMap.get(path).succ -> at(1);
				--} 
				--else if(node.oclIsTypeOf(Turn!Timer)){
				--	tUCMmap.nodes <- thisModule.createTimer(node, tUCMmap);
				--	thisModule.timerMap.get(node).pred <- tUCMmap.nodes -> any(n|path.name=n.name).succ -> at(1); 
				--}
				--else if(node.oclIsTypeOf(Turn!Connect)){
				--	node; --path1statement5
				--}
				--else if(node.oclIsTypeOf(Turn!WaitingPlace))
				--	thisModule.resolveTemp(node, 'tWtPlace').pred <- thisModule.stubMap.get(path).succ -> any(s|s.target.oclIsUndefined());
				--else if(node.oclIsTypeOf(Turn!FailurePoint))
				--	thisModule.resolveTemp(node, 'tFailPt').pred <- thisModule.stubMap.get(path).succ -> any(s|s.target.oclIsUndefined());
				--else{
				--	tUCMmap.nodes -> any(n|n.name=node.name).pred <- tUCMmap.nodes -> any(n|path.name=n.name).succ -> at(1);
				--}
			}
			else{ 
				node; --path2
			}
			thisModule.nodeCounter <- thisModule.nodeCounter.inc();
		}
	}
		
}