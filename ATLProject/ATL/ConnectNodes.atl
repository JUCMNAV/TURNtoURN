module ConnectNodes;

create OUT : Urn from IN : Turn;

--QUESTION: are select(s|s.target = OclUndefined) and any(s|s.target.oclIsUndefined()) equivalent here? i.e., will there only ever be one item with s.target = undefined?
-- TODO: determine if this name is appropriate
rule processNode(tUCMmap: Urn!UCMmap, pathbody: Sequence(Turn!PathBody), currentNode: Urn!PathNode, previousNode: Urn!PathNode, isTimer: Boolean){
	do{
		if(previousNode.oclIsTypeOf(Turn!WaitingPlace)){
			currentNode.pred <- thisModule.resolveTemp(previousNode, 'tWtPlace').succ -> any(s|s.target.oclIsUndefined());
		}
		else if(previousNode.oclIsTypeOf(Turn!FailurePoint)){
			currentNode.pred <- thisModule.resolveTemp(previousNode, 'tFailPt').succ -> any(s|s.target.oclIsUndefined());
		}
		else if(not isTimer and previousNode.oclIsTypeOf(Turn!Timer)){
			currentNode.pred <- thisModule.timerMap.get(previousNode).succ -> any(s|s.target.oclIsUndefined());
		}
		else if(previousNode.oclIsTypeOf(Turn!Connect)){
			if(previousNode.connectsTo.oclIsTypeOf(Turn!StartPoint)){
				tUCMmap.getNode(previousNode.connectsTo.name).succ <- thisModule.createNodeConnection();
				currentNode.pred <- tUCMmap.getNode(previousNode.connectsTo.name).succ -> any(s|s.target.oclIsUndefined());
			}
			else if(previousNode.connectsTo.oclIsTypeOf(Turn!Timer)){
				currentNode.pred <- thisModule.connectMap.get(previousNode).succ -> any(s|s.target.oclIsUndefined()); 
			}
			else{
				currentNode.pred <- tUCMmap.getNode(previousNode.connectsTo.name).succ -> any(s|s.target.oclIsUndefined());
			}
		}
		else if(isTimer){
			if(previousNode.oclIsTypeOf(Turn!RespRef)){
				currentNode.pred <- thisModule.resolveTemp(previousNode, 'tRespRef').succ -> select(s|s.target.OclUndefined);
			}
			else {
				currentNode.pred <- tUCMmap.getNode(previousNode.name).succ -> any(s|s.target.oclIsUndefined());
			}
		}
		else if(previousNode.oclIsTypeOf(Turn!RespRef)){
			currentNode.pred <- thisModule.resolveTemp(previousNode, 'tRespRef').succ -> any(s|s.target.oclIsUndefined());
		}
		else{
			currentNode.pred <- tUCMmap.getNode(previousNode.name).succ;
		}
	}
}

--I'm using the vague term isCaseOne here as I'm not sure of the difference between the two cases / why it is necessary
--TODO: name this more precisely
rule getNodeToConnect(tUCMmap: Urn!UCMmap, currentPathNode: Turn!PathNode, isCaseOne: Boolean){
	do{
		thisModule.nodeToJoin <- '';
		
		thisModule.succeeded <- false;
		
		if(currentPathNode.oclIsTypeOf(Turn!Connect)){
			if(currentPathNode.connectsTo.oclIsTypeOf(Turn!WaitingPlace)){
				thisModule.nodeToJoin <- tUCMmap.getNode(currentPathNode.connectsTo.name).succ -> any(s|s.target.oclIsUndefined());
				thisModule.succeeded <- true;
			}
		}
		
		if(not thisModule.succeeded){
			if(isCaseOne){
				thisModule.nodeToJoin <- tUCMmap.getNode(currentPathNode.name).succ -> any(s|s.target.oclIsUndefined());
			}
			else{
				thisModule.nodeToJoin <- tUCMmap.getNode(currentPathNode.name).succ;
			}
		}
		
		thisModule.nodeToJoin;
	}
}

-- QUESTION: determine why we look at the first node, i.e., pathbody.pathNodes -> first(), rather than the last
-- TODO: determine how the next connecting node is chosen
-- TODO: determine if this name is appropriate
rule handleConnectNode(tUCMmap: Urn!UCMmap, NODE: Turn!PathNode, ITEM: Turn!PathNode, timerNode: Turn!PathNode){
	do{
		thisModule.connect <- thisModule.createConnect(tUCMmap);

		if(not NODE.connectsTo.oclIsTypeOf(Turn!Timer)){
			thisModule.emptyPt <- thisModule.createEmptyPt(tUCMmap, OclAny, true);
			thisModule.connect.pred <- thisModule.emptyPt.succ -> at(1);
			
			thisModule.connectedNode <- tUCMmap.getNode(NODE.connectsTo.name);
			thisModule.connectedNode.pred <- thisModule.connectedNode.pred -> union(thisModule.connect.succ);
			thisModule.connectedNode.pred <- thisModule.connectedNode.pred -> including(ITEM);
		}
		else{
			thisModule.emptyPtTimer <- thisModule.createEmptyPt(tUCMmap, NODE.connectsTo, true);
			thisModule.connect.pred <- thisModule.emptyPtTimer.succ -> at(1);
			-- TODO: not sure if this second condition I added avoids trying to connect the first path node or prevents the connect chain from starting up altogether
			if(not timerNode.oclIsUndefined() and not thisModule.connectMap.get(timerNode.connectsTo).oclIsUndefined()){
				--BROKEN TODO: fix the issue caused by this line
				thisModule.connectMap.get(timerNode.connectsTo).pred <- thisModule.connect.succ;
			}
			thisModule.emptyPtTimer.pred <- thisModule.emptyPtTimer.pred -> including(ITEM);
		}
		
		thisModule.connect;
	}
}


--TODO: find a way to reduce the number of arguments for this rule
rule handleForkLogic(tUCMmap: Turn!UCMmap, path: Turn!Path, node: Turn!PathNode, firstPathNode: Turn!PathNode, nextNode: Urn!PathNode, counter: Integer, case: String){
	do{
		if(case = 'and'){
			thisModule.currentMap <- thisModule.andForkMap;
		}
		else if(case = 'or'){
			thisModule.currentMap <- thisModule.orForkMap;
		}
		else{
			--there should not be any other cases
		}
	
		thisModule.succeeded <- false;
		
		-- TODO: move this logic up a level into the methods that assign nextNode a value
		if(not nextNode.oclIsUndefined()){
			if(nextNode <> ''){
				thisModule.nextConnectingNode <- nextNode;
				thisModule.succeeded <- true;
			}
		}
		
		if(not thisModule.succeeded){
			thisModule.nextConnectingNode <- thisModule.currentMap.get(path);
		}

		if(firstPathNode.oclIsTypeOf(Turn!RespRef)){
			thisModule.resolveTemp(firstPathNode ,'tRespRef').pred <- thisModule.nextConnectingNode.succ -> any(s|s.target.oclIsUndefined());
		}
		else if(firstPathNode.oclIsTypeOf(Turn!Connect)){
			-- look for asynchronous connect (QUESTION: what does this mean?)
			if(counter = -1){ --AND case
				thisModule.connect <- thisModule.handleConnectNode(tUCMmap, firstPathNode, thisModule.nextConnectingNode.succ -> any(s|s.target.oclIsUndefined()), firstPathNode);
			}
			else{ --OR case
				thisModule.connect <- thisModule.handleConnectNode(tUCMmap, firstPathNode, thisModule.nextConnectingNode.succ -> at(counter), OclUndefined);
			}

			thisModule.connectMap <- thisModule.connectMap.including(node, thisModule.connect);
		}
		else{
			-- where is this defined? where is it used?
			if(firstPathNode.oclIsTypeOf(Turn!Timer)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createTimer(firstPathNode, tUCMmap));
			}
			tUCMmap.getNode(firstPathNode.name).pred <- thisModule.nextConnectingNode.succ -> any(s|s.target.oclIsUndefined());
		}
		
		--ADDED FOR TIMER AND ORFORK CONNECTION
		if(node.oclIsTypeOf(Turn!Timer)){
			tUCMmap.getNode(node.name).pred <- thisModule.currentMap.get(path).succ -> at(counter);
		}
	}
}

rule connectNodes(pathbody: Sequence(Turn!PathBody), path: Turn!Path, tUCMmap: Urn!UCMmap, nextNode: Urn!PathNode){
	do{ 
		thisModule.nodeCounter <- 1;
		thisModule.firstPathNode <- '';
		thisModule.currentPathNode <- '';
		
		for (node in pathbody.pathNodes){
			thisModule.firstPathNode <- pathbody.pathNodes -> first();
			thisModule.currentPathNode <- pathbody.pathNodes -> at(thisModule.nodeCounter);
			
			if(thisModule.nodeCounter = 1){
				if(path.oclIsTypeOf(Turn!Path)){
					thisModule.startPoint <- tUCMmap.getNode(path.startPoint.name);
					
					if(node.oclIsTypeOf(Turn!RespRef)){
						thisModule.resolveTemp(node, 'tRespRef').pred <- thisModule.startPoint.succ -> at(1);
					}
					else if(node.oclIsTypeOf(Turn!Timer)){
						tUCMmap.nodes <- tUCMmap.nodes -> including(thisModule.createTimer(node, tUCMmap));
						thisModule.timerMap.get(node).pred <- thisModule.startPoint.succ;
					} --with an else
					else if(node.oclIsTypeOf(Turn!Connect)) {
						thisModule.connect <- thisModule.handleConnectNode(tUCMmap, node, thisModule.startPoint.succ -> any(s|s.target.oclIsUndefined()), OclUndefined);
						thisModule.connectMap <- thisModule.connectMap.including(node, thisModule.connect);
					}
					else if(node.oclIsTypeOf(Turn!WaitingPlace)){
						if(not node.connect.oclIsUndefined() and not tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> isEmpty()){
							tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ept|ept.succ -> includes(thisModule.connectMap.get(node.connect).pred -> first())).pred <- thisModule.startPoint.succ;
						}
						else{
							thisModule.resolveTemp(node, 'tWtPlace').pred <- thisModule.startPoint.succ;
						}
					}
					else if(node.oclIsTypeOf(Turn!FailurePoint)){
						thisModule.resolveTemp(node, 'tFailPt').pred <- thisModule.startPoint.succ;
					}
					else{
						tUCMmap.getNode(node.name).pred <- thisModule.startPoint.succ;
					}
				}
				else if(path.oclIsTypeOf(Turn!OrFork)){
					thisModule.handleForkLogic(tUCMmap, path, node, thisModule.firstPathNode, nextNode, thisModule.counter, 'or');
				}
				else if (path.oclIsTypeOf(Urn!OrJoin)){
					thisModule.succeeded <- false;
					
					if(node.oclIsTypeOf(Turn!RespRef)){
						if(thisModule.getResponsibility(node.name).respRefs -> select(r|r.diagram.name=tUCMmap.name) -> isEmpty()){
							thisModule.getResponsibility(node.name).respRefs -> any(r|r.diagram.name=tUCMmap.name).pred <- tUCMmap.getNode(path.name).succ;
							thisModule.succeeded <- true;
						}
					}
					
					if(not thisModule.succeeded){
						tUCMmap.getNode(node.name).pred <- tUCMmap.getNode(path.name).succ -> at(1);
					}
				}
				else if(path.oclIsTypeOf(Turn!AndFork)){
					thisModule.handleForkLogic(tUCMmap, path, node, thisModule.firstPathNode, nextNode, thisModule.counter, 'and');
				}
				else {
					thisModule.currentNode <- thisModule.stubMap.get(path);
					
					if(node.oclIsTypeOf(Turn!RespRef)){
						thisModule.resolveTemp(node, 'tRespRef').pred <- thisModule.currentNode.succ -> at(1);
					} 
					else if(node.oclIsTypeOf(Turn!Timer)){
						tUCMmap.nodes <- tUCMmap.nodes -> including(thisModule.createTimer(node, tUCMmap));
						thisModule.timerMap.get(node).pred <- tUCMmap.getNode(path.name).succ -> at(1);
					}
					else if(node.oclIsTypeOf(Turn!Connect)){
						thisModule.connect <- thisModule.handleConnectNode(tUCMmap, thisModule.firstPathNode, thisModule.currentNode.succ -> any(s|s.target.oclIsUndefined()), thisModule.firstPathNode);
						thisModule.connectMap <- thisModule.connectMap.including(node, thisModule.connect);
					}
					else if(node.oclIsTypeOf(Turn!WaitingPlace)){
						thisModule.resolveTemp(node, 'tWtPlace').pred <- thisModule.currentNode.succ -> any(s|s.target.oclIsUndefined());
					}
					else if(node.oclIsTypeOf(Turn!FailurePoint)){
						thisModule.resolveTemp(node, 'tFailPt').pred <- thisModule.currentNode.succ -> any(s|s.target.oclIsUndefined());
					}
					else{
						tUCMmap.getNode(node.name).pred <- tUCMmap.getNode(path.name).succ -> at(1);
					}
				}
			}
			else{ 
				thisModule.previousNode <- pathbody.pathNodes -> at(thisModule.nodeCounter-1);
				
				if(node.oclIsTypeOf(Turn!WaitingPlace)){
					thisModule.processNode(tUCMmap, pathbody, thisModule.resolveTemp(node, 'tWtPlace'), thisModule.previousNode, false);
				}
				else if(node.oclIsTypeOf(Turn!FailurePoint)){
					thisModule.processNode(tUCMmap, pathbody, thisModule.resolveTemp(node, 'tFailPt'), thisModule.previousNode, false);
				}
				else if(node.oclIsTypeOf(Turn!RespRef)){
					thisModule.processNode(tUCMmap, pathbody, thisModule.resolveTemp(node, 'tRespRef'), thisModule.previousNode, false);
				}
				--NEED TO CREATE TIMER FOR ALL OTHER COMBINATIONS
				else if(node.oclIsTypeOf(Turn!Timer)){
					tUCMmap.nodes <- thisModule.createTimer(node, tUCMmap);
					thisModule.processNode(tUCMmap, pathbody, thisModule.timerMap.get(node), thisModule.previousNode, true);
				}
				--NEED TO CREATE CONNECT FOR ALL OTHER COMBINATIONS
				else if(node.oclIsTypeOf(Turn!Connect)){
					thisModule.pred <- '';
					
					if(thisModule.previousNode.oclIsTypeOf(Turn!RespRef)){
						thisModule.pred <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(r|r.respDef.name = thisModule.previousNode.name)-> flatten() -> any(s|s.pred <> OclUndefined).succ;
					}
					else if(thisModule.previousNode.oclIsTypeOf(Turn!Connect)){
						thisModule.pred <- tUCMmap.getNode(thisModule.previousNode.connectsTo.name).succ -> any(s|s.target.oclIsUndefined());
					}
					else{
						thisModule.pred <- tUCMmap.getNode(thisModule.previousNode.name).succ;
					}
					
					thisModule.connect <- thisModule.handleConnectNode(tUCMmap, node, thisModule.pred, thisModule.firstPathNode);
					thisModule.connectMap <- thisModule.connectMap.including(node, thisModule.connect);
				}
				-- DOUBLE CHECK IF THIS IS REQUIRED
				else if(thisModule.previousNode.oclIsTypeOf(Turn!RespRef)){
					tUCMmap.getNode(node.name).pred <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(r|r.respDef.name = thisModule.previousNode.name)-> flatten() -> collect(s|s.succ) -> flatten() -> select(s|s.target = OclUndefined);
				}
				else if (thisModule.previousNode.oclIsTypeOf(Turn!Connect)){
					if(thisModule.previousNode.connectsTo.oclIsTypeOf(Turn!Timer)){
						tUCMmap.getNode(node.name).pred <- thisModule.connectMap.get(thisModule.previousNode).succ -> any(s|s.target.oclIsUndefined()); 
					}
					else{
						if(thisModule.previousNode.connectsTo.oclIsTypeOf(Turn!StartPoint)){
							tUCMmap.getNode(thisModule.previousNode.connectsTo.name).succ <- thisModule.createNodeConnection();
						}
						tUCMmap.getNode(node.name).pred <- tUCMmap.getNode(thisModule.previousNode.connectsTo.name).succ -> any(s|s.target.oclIsUndefined());
					}
				}
				else{
					tUCMmap.getNode(node.name).pred <- tUCMmap.nodes -> any(n|thisModule.previousNode.name).succ;
				}
			}
			--regular ends
			if(thisModule.nodeCounter = pathbody.pathNodes -> size() and not pathbody.pathEnd.oclIsUndefined()){
				if(thisModule.currentPathNode.oclIsTypeOf(Turn!RespRef)){
					thisModule.nextNode <- thisModule.resolveTemp(thisModule.currentPathNode ,'tRespRef').succ -> any(s|s.target = OclUndefined);
					
					if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect) and thisModule.currentPathNode.oclIsTypeOf(Turn!Connect)){
						tUCMmap.getNode(pathbody.pathEnd.regularEnd.name).pred <- tUCMmap.getNode(thisModule.currentPathNode.connectsTo.name).succ;
					}
					else if (pathbody.pathEnd.oclIsTypeOf(Turn!Stub)){
						thisModule.stubMap.get(pathbody.pathEnd).pred <- nextNode;
					}
					else{
						thisModule.connectPathEndToNextNode(tUCMmap, pathbody.pathEnd, thisModule.nextNode);
					}
				}
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
					thisModule.newPred <- ''; --TODO: determine a proper name for this
					
					if(not thisModule.currentPathNode.oclIsTypeOf(Turn!Connect)){
						if(thisModule.currentPathNode.oclIsTypeOf(Turn!WaitingPlace)){
							if(not thisModule.currentPathNode.connect.oclIsUndefined() and not tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> isEmpty()){
								thisModule.newPred <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ept|ept.succ -> includes(thisModule.connectMap.get(thisModule.currentPathNode.connect).pred -> first())).succ -> any(s|s.target.oclIsUndefined());
							}
							else{
								thisModule.newPred <- thisModule.resolveTemp(thisModule.currentPathNode, 'tWtPlace').succ -> any(s|s.target.oclIsUndefined());
							}
						}
						else if(thisModule.currentPathNode.oclIsTypeOf(Turn!FailurePoint)){
							thisModule.newPred <- thisModule.resolveTemp(thisModule.currentPathNode, 'tFailPt').succ -> any(s|s.target.oclIsUndefined());
						}
						else if(thisModule.currentPathNode.oclIsTypeOf(Turn!Timer)){
							thisModule.newPred <- thisModule.timerMap.get(thisModule.currentPathNode).succ -> any(s|s.target.oclIsUndefined());
						}
						else{
							thisModule.newPred <- tUCMmap.getNode(thisModule.currentPathNode.name).succ -> any(s|s.target.oclIsUndefined());
						}
					}
					else if(thisModule.currentPathNode.connectsTo.oclIsTypeOf(Turn!Timer)){
						thisModule.newPred <- thisModule.connectMap.get(thisModule.currentPathNode).succ -> any(s|s.target.oclIsUndefined()); 
					}
					else{
						--in case of a connect
						if(thisModule.currentPathNode.connectsTo.oclIsTypeOf(Turn!StartPoint)){
							tUCMmap.getNode(thisModule.currentPathNode.connectsTo.name).succ <- thisModule.createNodeConnection();
						}
						thisModule.newPred <- tUCMmap.getNode(thisModule.currentPathNode.connectsTo.name).succ -> any(s|s.target.oclIsUndefined());
					}
					
					tUCMmap.getNode(pathbody.pathEnd.regularEnd.name).pred <- thisModule.newPred;
				}
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!OrFork)){
					thisModule.orForkMap.get(pathbody.pathEnd).pred <- thisModule.getNodeToConnect(tUCMmap, thisModule.currentPathNode, true);
				}
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.andForkMap.get(pathbody.pathEnd).pred <- thisModule.getNodeToConnect(tUCMmap, thisModule.currentPathNode, true);
				}
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!Stub)){
					if(thisModule.currentPathNode.oclIsTypeOf(Turn!Timer)){
						thisModule.stubMap.get(pathbody.pathEnd).pred <- thisModule.timerMap.get(thisModule.currentPathNode).succ -> any(s|s.target.oclIsUndefined());
					}
					else if(thisModule.currentPathNode.oclIsTypeOf(Turn!Stub)){
						thisModule.stubMap.get(pathbody.pathEnd).pred <- thisModule.stubMap.get(thisModule.currentPathNode).succ -> any(s|s.target.oclIsUndefined());
					}
					else{
						thisModule.stubMap.get(pathbody.pathEnd).pred <- thisModule.getNodeToConnect(tUCMmap, thisModule.currentPathNode, true);	
					}
				}
			}
			--referenced ends
			else if(thisModule.nodeCounter = pathbody.pathNodes -> size() and not pathbody.referencedEnd.oclIsUndefined()){
				if(thisModule.currentPathNode.oclIsTypeOf(Turn!RespRef)){
					if(pathbody.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
						tUCMmap.getNode(pathbody.referencedEnd.name).pred <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(r|r.respDef.name = thisModule.currentPathNode.name)-> flatten() -> collect(s|s.succ) -> flatten() -> select(s|s.target = OclUndefined);
					}
					else if (pathbody.referencedEnd.oclIsTypeOf(Turn!OrFork)){
						thisModule.orForkMap.get(pathbody.pathEnd).pred <- thisModule.getResponsibility(thisModule.currentPathNode.name).respRefs -> any(r|r.diagram.name = tUCMmap.name).succ;
					}
					else if (pathbody.referencedEnd.oclIsTypeOf(Turn!AndFork)){
						thisModule.andForkMap.get(pathbody.pathEnd).pred <- thisModule.getResponsibility(thisModule.currentPathNode.name).respRefs -> any(r|r.diagram.name = tUCMmap.name).succ;
					}
					else if (pathbody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
						tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(r|r.respDef.name = pathbody.referencedEnd.name).pred <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(r|r.respDef.name = thisModule.currentPathNode.name)-> flatten() -> collect(s|s.succ) -> flatten() -> select(s|s.target = OclUndefined);
					}
					else{
						tUCMmap.getNode(pathbody.referencedEnd.name).pred <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(r|r.respDef.name = thisModule.currentPathNode.name)-> flatten() -> collect(s|s.succ) -> flatten() -> select(s|s.target = OclUndefined);
					}
				}
				else if(pathbody.referencedEnd.oclIsTypeOf(Turn!OrFork)){
					thisModule.orForkMap.get(pathbody.referencedEnd).pred <- tUCMmap.getNode(thisModule.currentPathNode.name).succ -> any(s|s.target.oclIsUndefined());
				}
				else if(pathbody.referencedEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.andForkMap.get(pathbody.referencedEnd).pred <- tUCMmap.getNode(thisModule.currentPathNode.name).succ -> any(s|s.target.oclIsUndefined());
				}
				else if(pathbody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
					thisModule.resolveTemp(pathbody.referencedEnd,'tRespRef').pred <- thisModule.getNodeToConnect(tUCMmap, thisModule.currentPathNode, true);
				}
				else{
					thisModule.succeeded <- false;
					
					if(pathbody.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
						if(not thisModule.currentPathNode.oclIsTypeOf(Turn!Connect)){
							if(tUCMmap.getNode(pathbody.referencedEnd.name).pred -> collect(s|s.source) -> isEmpty()){
								tUCMmap.getNode(pathbody.referencedEnd.name).pred <- tUCMmap.getNode(thisModule.currentPathNode.name).succ;
								thisModule.succeeded <- true;
							}
						}
					}
					
					if(not thisModule.succeeded){
						tUCMmap.getNode(pathbody.referencedEnd.name).pred <- thisModule.getNodeToConnect(tUCMmap, thisModule.currentPathNode, false);	
					}
				}
			}
			else if(thisModule.nodeCounter = pathbody.pathNodes -> size() and (not pathbody.referencedStub.oclIsUndefined())){
				if(thisModule.currentPathNode.oclIsTypeOf(Turn!RespRef)){
					thisModule.nextNode <- '';
					
					if(tUCMmap.getNode(pathbody.referencedStub.name).pred -> size() >= pathbody.index){
						thisModule.nextNode <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(r|r.respDef.name = thisModule.currentPathNode.name).succ;
					}
					else{
						thisModule.nextNode <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(r|r.respDef.name = thisModule.currentPathNode.name)-> flatten() -> collect(s|s.succ) -> flatten() -> select(s|s.target = OclUndefined);
					}
					
					thisModule.processReferencedStub(tUCMmap, pathbody, thisModule.nextNode);
				}
				else if(tUCMmap.getNode(pathbody.referencedStub.name).pred -> size() >= pathbody.index){
					thisModule.firstPred <- tUCMmap.getNode(pathbody.referencedStub.name).pred -> first().source;
					
					thisModule.orJoinPred <- thisModule.getNodeToConnect(tUCMmap, tUCMmap, thisModule.currentPathNode, false);
					
					thisModule.orJoin <- thisModule.createOrJoin(tUCMmap, thisModule.orJoinPred);
					thisModule.orJoin.pred <- thisModule.firstPred.succ;
					tUCMmap.getNode(pathbody.referencedStub.name).pred <- thisModule.orJoin.succ;
				}
				else{
					tUCMmap.getNode(pathbody.referencedStub.name).pred <- thisModule.getNodeToConnect(tUCMmap, thisModule.currentPathNode, false);
				}
			}
			thisModule.nodeCounter <- thisModule.nodeCounter.inc();
		}
	}		
}