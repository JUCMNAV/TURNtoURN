module ConnectNodes;

create OUT : Urn from IN : Turn;

rule connectNodes(pathbody: Sequence(Turn!PathBody), path: Turn!Path, tUCMmap: Urn!UCMmap, nextNode: Urn!PathNode){
	do{ 
		thisModule.nodeCounter <- 1;
		for (node in pathbody.pathNodes){
			if(thisModule.nodeCounter = 1){
				if(path.oclIsTypeOf(Turn!Path)){
					node; --statement1
				}
				else if(path.oclIsTypeOf(Turn!OrFork)){
					node; --statement2
				}
				else if (path.oclIsTypeOf(Urn!OrJoin)){
					node; --statement3
				}
				else if(path.oclIsTypeOf(Turn!AndFork)){
					node; --statement4
				}
				else if(node.oclIsTypeOf(Turn!RespRef)){
					thisModule.resolveTemp(node, 'tRespRef').pred <- thisModule.stubMap.get(path).succ -> at(1);
				} 
				else if(node.oclIsTypeOf(Turn!Timer)){
					tUCMmap.nodes <- thisModule.createTimer(node, tUCMmap);
					thisModule.timerMap.get(node).pred <- tUCMmap.nodes -> any(n|path.name=n.name).succ -> at(1); 
				}
				else if(node.oclIsTypeOf(Turn!Connect)){
					node; --statement5
				}
				else if(node.oclIsTypeOf(Turn!WaitingPlace))
					thisModule.resolveTemp(node, 'tWtPlace').pred <- thisModule.stubMap.get(path).succ -> any(s|s.target.oclIsUndefined());
				else if(node.oclIsTypeOf(Turn!FailurePoint))
					thisModule.resolveTemp(node, 'tFailPt').pred <- thisModule.stubMap.get(path).succ -> any(s|s.target.oclIsUndefined());
				else{
					tUCMmap.nodes -> any(n|n.name=node.name).pred <- tUCMmap.nodes -> any(n|path.name=n.name).succ -> at(1);
				}
			}
			else{ 
				node; --path2
			}
			thisModule.nodeCounter <- thisModule.nodeCounter.inc();
		}
	}
		
}