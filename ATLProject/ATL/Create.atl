module Create;

create OUT : Urn from IN : Turn;

-- Contains initializers and all rules used to instantiate model items in other parts
-- of the code. This is a good place to look for potential improvements as it may be
-- possible to make some of these into matched rules (either now, if I have missed
-- something, or in future versions of ATL).

--------------1/2 INITIALIZERS-------------

rule initBinding(sBinding: Turn!Binding, tBinding: Urn!Binding){
	using{
		boundTerm : Turn!Binding = OclUndefined;
		sStub : Turn!Stub = OclUndefined;
		tStub: Urn!Stub = OclUndefined;
	}
	do{
		if(not sBinding.binding.oclIsUndefined()){
			boundTerm <- sBinding.binding;
		}
		else if(not sBinding.bindings.oclIsUndefined()){
			boundTerm <- sBinding.bindings;
		}
		
		if(not boundTerm.stubParam.stubDec.oclIsUndefined()){
			sStub <- boundTerm.stubParam.stubDec.stub;
		}
		else if(not boundTerm.stubParam.stub.oclIsUndefined()){
			sStub <- boundTerm.stubParam.stub;
		}
		
		if(not sStub.oclIsUndefined() and not thisModule.retrieveNode(sStub).pred -> isEmpty()){
			if(sBinding.oclIsTypeOf(Turn!InBinding)){
				tBinding.stubEntry <- thisModule.retrieveNode(sStub).pred -> at(sBinding.index);
			}
			else if(sBinding.oclIsTypeOf(Turn!OutBinding)){
				tBinding.stubExit <- thisModule.retrieveNode(sStub).succ -> at(sBinding.index);
			}
		}	
	}
}

-- TODO: implement
rule findPathBetweenNodes(tStartNode: Urn!PathNode, tEndNode: Urn!PathNode){
	using{
		vPath : Sequence(Urn!PathNode) = Sequence{tStartNode};	
	}
	do{
		vPath <- vPath.including(tEndNode);
		--thisModule.debug(vPath);
		
		--vPath;
		OclUndefined;
	}
}

rule initContRef(tContRef: Urn!ComponentRef, nodes: Sequence(Urn!StartPoint)){
	using{
		tMetadata : Sequence(Urn!Metadata) = tContRef.metadata -> flatten();
		tFrom : String = 
			if tMetadata -> select(md|md.name='from') -> size() = 1 then
				tMetadata -> select(md|md.name='from').first().value
			else
				''
			endif;
		tTo : String = 
			if tMetadata -> select(md|md.name='to') -> size() = 1 then
				tMetadata -> select(md|md.name='to').first().value
			else
				''
			endif;
		tFromExists : Boolean = 
			(nodes -> select(n|n.name = tFrom) -> size() = 1)
			or (not nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.getRespName()=tFrom) -> isEmpty())
			and not (tFrom = '');
		tToExists : Boolean = 
			(not nodes -> select(n|n.name = tTo) -> isEmpty())
			or (not nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.getRespName()=tTo) -> isEmpty())
			and not (tTo = '');
		vStartNode : Urn!PathNode = OclUndefined;
		vEndNode : Urn!PathNode = OclUndefined;
	}
	do{
		if(tFromExists and tToExists){ --unidirectional, tFrom must be before tTo
			vStartNode <- nodes -> any(n|n.name = tFrom);

			if(vStartNode.oclIsUndefined()){
				vStartNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.getRespName()=tFrom);
			}
			
			vEndNode <- nodes -> any(n|n.name=tTo);
			
			if(vEndNode.oclIsUndefined()){
				vEndNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.getRespName()=tTo);
			}
			
			tContRef.nodes <- thisModule.findPathBetweenNodes(vStartNode, vEndNode);	
		}
	}
}

rule initEndPointUsingEndpointWithConnect(tEndPoint: Urn!EndPoint, sEndpointWithConnect: Turn!EndpointWithConnect){
	using{
		tConnect : Urn!Connect = OclUndefined;	
	}
	do{
		tEndPoint.name <- sEndpointWithConnect.regularEnd.turnGetLongestName();
		tEndPoint.contRef <- thisModule.getUrnComponentRef(sEndpointWithConnect.regularEnd);
		
		if(not sEndpointWithConnect.regularEnd.condition.oclIsUndefined()){
			tEndPoint.postcondition <- thisModule.createCondition(sEndpointWithConnect.regularEnd.condition.expression.asString());
		}
		
		if(not sEndpointWithConnect.connect.oclIsUndefined()){
			tConnect <- thisModule.createConnect();
			thisModule.connect(thisModule.retrieveNode(sEndpointWithConnect.regularEnd), tConnect);
			thisModule.connect(tConnect, thisModule.retrieveNode(sEndpointWithConnect.connect));
		}
	}
}

rule initStub(sStub: Turn!Stub){
	using{
		tPlugins : Sequence(Turn!Stub) = OclUndefined;
		tStub : Urn!Stub = thisModule.retrieveNode(sStub);	
	}
	do{
		if(not sStub.params.oclIsUndefined()){
			tPlugins <- sStub.params.plugin;
		}
		else{
			tPlugins <- Turn!UCMmap.allInstances() -> any(m|m.name=thisModule.tUCMmap.name).stubs -> collect(s|s.params.plugin) -> flatten();
		}
		
		tStub.bindings <- tPlugins -> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'));	
	}
}

rule initTimer(sTimer: Turn!Timer){
	using{
		tTimer : Urn!Timer = thisModule.retrieveNode(sTimer);
	}
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tTimer);
		
		if(not sTimer.timeoutPath.oclIsUndefined()){
			thisModule.collectPathBodyNodes(sTimer.timeoutPath);
			thisModule.connectPathEnd(sTimer.timeoutPath.pathEnd);
			thisModule.connectPathBody(sTimer.timeoutPath, tTimer);
			
			if(not sTimer.timeoutCondition.oclIsUndefined()){
				tTimer.succ.last().condition <- thisModule.createCondition(sTimer.timeoutCondition.expression.content.first());
			}
		}
		
		tTimer;
	}
}

-------------2/2 INSTANTIATORS-------------

rule createAndJoin(){
	to
		tAndJoin: Urn!AndJoin(
			id <- thisModule.nextId().toString(),
			name <- 'AndJoin' + tAndJoin.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tAndJoin;
	}
}

rule createBeliefLink(sBeliefLink: Turn!ElementLink){
	to
		tBeliefLink: Urn!BeliefLink(
			target <- thisModule.resolveTemp(sBeliefLink.dest, 'tIntentionalElementRef')
		)	
	do{
		tBeliefLink;
	}
}

rule createComponent(sComponent: Turn!ComponentRef){
	to
		tComponent: Urn!Component(
			id <- thisModule.nextId().toString(),
			name <- sComponent.turnGetLongestName()
		)
	do{
		tComponent;	
	}
}

rule createCondition(vSourceExpression: String){
	to
	 	tCondition: Urn!Condition(
	 		expression <- vSourceExpression,
			label <- vSourceExpression
	 	)
	do{
		tCondition;
	}		
}

rule createConnect(){
	to
		tConnect: Urn!Connect(
			id <- thisModule.nextId().toString(),
			name <- 'Connect' + tConnect.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tConnect;	
	}
}

rule createEmptyPoint(){
	to
		tEmptyPoint: Urn!EmptyPoint(
			id <- thisModule.nextId().toString(),
			name <- 'EmptyPoint' + tEmptyPoint.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tEmptyPoint;
	}
}

rule createEndPoint(){
	to
		tEndPoint: Urn!EndPoint(
			id <- thisModule.nextId().toString(),
			name <- 'EndPoint' + tEndPoint.id,
			label <- thisModule.createLabel(),
			diagram <- thisModule.tUCMmap
		)
	do{
		tEndPoint;
	}
}

rule createKPIEvalValueSet(sLinearConversion: Turn!LinearConversion){
	to
		tKpiEvalValueSet: Urn!KPIEvalValueSet(
			unit <- sLinearConversion.unit,
			targetValue <- sLinearConversion.targetValue,
			thresholdValue <- sLinearConversion.thresholdValue,
			worstValue <- sLinearConversion.worstValue
		)
	do{
		tKpiEvalValueSet;
	}
}

rule createLabel(){
	to
		tNodeLabel: Urn!NodeLabel()
	do{
		tNodeLabel;
	}
}

rule createMetadata(vName: String, vValue: String){
	to 
 		tMetadata: Urn!Metadata(
 			name <- vName,
 			value <- vValue 
		)
	do{
	 	tMetadata;
	}
}

rule createNewConnection(tPathNode: Urn!PathNode){
	to
		tNodeConnection: Urn!NodeConnection()
	do{
		tPathNode.succ <- tPathNode.succ.including(tNodeConnection);
	}
}

rule createOrJoin(){
	to
		tOrJoin: Urn!OrJoin(
			id <- thisModule.nextId().toString(),
			name <- 'OrJoin' + tOrJoin.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tOrJoin;
	}
}

rule createQMapKPIEvalValueSet(conv: Turn!QualToQMappings){
	to		
		tQMapKPIEvalValueSet: Urn!KPIEvalValueSet(
			kpiConv <- conv	
		)
	do{
		tQMapKPIEvalValueSet;
	}
}

rule createResponsibility(sResponsibility: Turn!RespRef){
	to
		tResponsibility: Urn!Responsibility(
			id <- thisModule.nextId().toString(),
			name <- sResponsibility.turnGetLongestName()
		)
	do{
		tResponsibility;
	}
}

rule createStartPoint(){
	to
		tNodeLabel: Urn!NodeLabel(),
		tStartPoint: Urn!StartPoint (
			id <- thisModule.nextId().toString(),
			name <- 'StartPoint' + tStartPoint.id,
			label <- tNodeLabel
		)
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tStartPoint);
		tStartPoint;
	}
}