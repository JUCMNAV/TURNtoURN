module Create;

create OUT : Urn from IN : Turn;

-- Contains all rules used to instantiate model items in other parts of the code.
-- This is a good place to look for potential improvements as it may be possible to
-- make some of these into matched rules (either now, if I have missed something),
-- or in future versions of ATL.

------------1/2 RULES WITH DO LOGIC--------------

rule createEmptyPointConnect(currentNode: Turn!PathNode){
	do{
		if(currentNode.connectsTo.oclIsTypeOf(Turn!Timer)){
			thisModule.createAsynchEmptyPointConnect(currentNode);
		}
		else if(currentNode.connectsTo.oclIsTypeOf(Turn!WaitingPlace)){
			thisModule.createWaitingPlaceEmptyPointConnect(currentNode);
		}
		else{
			thisModule.createStartPointEmptyPointConnect(currentNode);
		}	
	}
}

rule createStartPointEmptyPointConnect(currentNode: Turn!PathNode){
	using{
		tConnect: Urn!Connect = thisModule.createConnect();
		tEmptyPt: Urn!EmptyPoint = thisModule.createEmptyPoint();
	}
	do{
		thisModule.connect(tConnect, thisModule.retrieveNode(currentNode.connectsTo));
		thisModule.useConnection(tEmptyPt, thisModule.retrieveNode(currentNode.connectsTo).nextFreeConnection());
		
		thisModule.connect(tEmptyPt, tConnect);
		
		thisModule.createNewConnection(tEmptyPt);

		thisModule.emptyPointMap <- thisModule.emptyPointMap.including(currentNode, tEmptyPt);
		thisModule.connectMap <- thisModule.connectMap.including(currentNode, tConnect);
		
		tEmptyPt;
	}
}

rule createWaitingPlaceEmptyPointConnect(currentNode: Turn!PathNode){
	using{
		tConnect: Urn!Connect = thisModule.createConnect();
		tEmptyPt: Urn!EmptyPoint = thisModule.createEmptyPoint();
	}
	do{
		thisModule.connect(tConnect, thisModule.retrieveNode(currentNode.connectsTo));
		--thisModule.useConnection(tEmptyPt, thisModule.retrieveNode(currentNode.connectsTo).nextFreeConnection());
		
		thisModule.connect(tEmptyPt, tConnect);
		
		thisModule.createNewConnection(tEmptyPt);

		thisModule.emptyPointMap <- thisModule.emptyPointMap.including(currentNode, tEmptyPt);
		thisModule.connectMap <- thisModule.connectMap.including(currentNode, tConnect);
		
		tEmptyPt;
	}
}

rule createAsynchEmptyPointConnect(currentNode: Turn!PathNode){
	using{
		tTimer : Urn!Timer = thisModule.resolveTemp(currentNode.connectsTo, 'tTimer');
		tConnect: Urn!Connect = thisModule.createConnect();
		tEmptyPt: Urn!EmptyPoint = thisModule.createAsynchronousEmptyPoint(currentNode.connectsTo.name);
	}
	do{
		thisModule.connect(tConnect, tTimer);
		thisModule.connect(tEmptyPt, tConnect);
		
		tEmptyPt.succ <- thisModule.createNodeConnection();

		thisModule.emptyPointMap <- thisModule.emptyPointMap.including(tTimer, tEmptyPt);
		thisModule.emptyPointMap <- thisModule.emptyPointMap.including(tEmptyPt, tTimer);
		thisModule.connectMap <- thisModule.connectMap.including(currentNode, tConnect);
		
		tEmptyPt;
	}
}


------------2/2 RULES WITHOUT DO LOGIC-----------
-- or well, where the only "do" logic is a return

rule createAndJoin(){
	to
		tAndJoin: Urn!AndJoin(
			id <- thisModule.nextId().toString(),
			name <- 'AndJoin' + tAndJoin.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tAndJoin;
	}
}

rule createBeliefLink(s: Turn!ElementLink){
	to
		tBeliefLink: Urn!BeliefLink (
			target <- thisModule.resolveTemp(s.dest, 'tIntElemRef')
		)	
	do{
		tBeliefLink;
	}
}

rule createComponent(s: Turn!ComponentRef){
	to
		tComp: Urn!Component(
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName()
		)
	do{
		tComp;	
	}
}

rule createCondition(sourceExpression: String){
	to
	 	targetCondition: Urn!Condition(
	 		expression <- sourceExpression,
			label <- sourceExpression
	 	)
	do{
		targetCondition;
	}		
}

rule createConnect(){
	to
		tConnect: Urn!Connect(
			id <- thisModule.nextId().toString(),
			name <- 'Connect' + tConnect.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tConnect;	
	}
}

rule createAsynchronousEmptyPoint(name: String){
	to
		tEmptyPt: Urn!EmptyPoint(
			id <- thisModule.nextId().toString(),
			name <- 'AsynchConnectTimer#' + name,
			diagram <- thisModule.tUCMmap
		)
	do{
		tEmptyPt;
	}
}

rule createEmptyPoint(){
	to
		tEmptyPt: Urn!EmptyPoint(
			id <- thisModule.nextId().toString(),
			name <- 'EmptyPoint' + tEmptyPt.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tEmptyPt;
	}
}

rule createEndPointUsingNode(node: Turn!PathNode){
	to
		tEndPoint: Urn!EndPoint (
			id <- thisModule.nextId().toString(),
			name <- 'EndPoint' + tEndPoint.id,
			label <- thisModule.createLabel(),
			diagram <- thisModule.tUCMmap,
			contRef <- thisModule.getUrnCompRef(node)
		)
	do{
		tEndPoint;
	}
}

rule createEndPoint(){
	to
		tEndPoint: Urn!EndPoint (
			id <- thisModule.nextId().toString(),
			name <- 'EndPoint' + tEndPoint.id,
			label <- thisModule.createLabel(),
			diagram <- thisModule.tUCMmap
		)
	do{
		tEndPoint;
	}
}

rule createKpiEvalValueSet(s: Turn!LinearConversion){
	to
		tKpiEvalValueSet: Urn!KPIEvalValueSet(
			unit <- s.unit,
			targetValue <- s.targetValue,
			thresholdValue <- s.thresholdValue,
			worstValue <- s.worstValue
		)
	do{ 
		tKpiEvalValueSet;
	}
}

rule createLabel(){
	to
		tNodeLabel: Urn!NodeLabel()
	do{
		tNodeLabel;
	}
}

rule createMetadata(name: String, value: String){
	to 
 		targetMetadata: Urn!Metadata(
 			name <- name,
 			value <- value 
		)
	do{
	 	targetMetadata;
	}
}

rule createNodeConnection(){
	to
	 	tNodeConnection: Urn!NodeConnection()
	do{
		tNodeConnection;
	}		
}

rule createOrJoin(){
	to
		tOrJoin: Urn!OrJoin(
			id <- thisModule.nextId().toString(),
			name <- 'OrJoin' + tOrJoin.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tOrJoin;
	}
}

rule createQMapKpiEvalValueSet(conv: Turn!QualToQMappings){
	to		
		tQMapKpiEvalValueSet: Urn!KPIEvalValueSet(
			kpiConv <- conv	
		)
	do{
		tQMapKpiEvalValueSet;
	}
}

rule createResponsibility(s: Turn!RespRef){
	to
		tResp: Urn!Responsibility(
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName()
		)
	do{
		tResp;
	}
}

rule createStartPoint(){
	to
		tNodeConn: Urn!NodeConnection(),
		tNodeLabel: Urn!NodeLabel(),
		tStartPoint: Urn!StartPoint (
			id <- thisModule.nextId().toString(),
			name <- 'StartPoint' + tStartPoint.id,
			succ <- tNodeConn,
			label <- tNodeLabel
		)
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tStartPoint);
		tStartPoint;
	}
}