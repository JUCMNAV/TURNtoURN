-------------------------------------
-- TURN2URN
-------------------------------------
-- Author: Ruchika Kumar, 2016
-------------------------------------
-- Edited by: Saahil Hamayun, 2019
-------------------------------------

module Create;

create OUT : Urn from IN : Turn;

----------------------------------------------------------------------------------------------
--	File: Create.atl
----------------------------------------------------------------------------------------------
--	Description
--		Contains initializers and all rules used to instantiate model items in other parts
--		of the code. This is a good place to look for potential improvements as it may be
--		possible to make some of these into matched rules (either now, if I have missed
--		something, or in future versions of ATL).
----------------------------------------------------------------------------------------------
--	Contents:
--		1/3 INITIALIZERS
--		2/3 CONDITIONAL INSTANTIATORS (getOrCreate)
--		3/3 INSTANTIATORS
----------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------

----------------------1/3 INITIALIZERS----------------------
-- Used to initialize objects after they are created.
-- These are necessary because not all objects always
-- need to be initialized immediately after creation,
-- and sometimes they do not need initialization at all.
------------------------------------------------------------

rule initComponentRef(sComponentRef: Turn!ComponentRef){
	using{
		tComponentRef : Urn!ComponentRef = 	thisModule.resolveTemp(sComponentRef, 'tComponentRef');
	}
	do{
		tComponentRef.contDef.kind <- sComponentRef.getKind();
		tComponentRef.contDef.protected <- sComponentRef.protected;

		thisModule.tUCMmap <- tComponentRef.diagram;
		
		for(sLongBoundElement in (sComponentRef.elements.including(sComponentRef.element)) -> select(e|e.oclIsTypeOf(Turn!LongBoundElement))){
			thisModule.addLongBoundElementNodesToComponentRef(sLongBoundElement, tComponentRef);
		}

		for(sBoundElement in (sComponentRef.elements.including(sComponentRef.element)) -> select(e|e.oclIsTypeOf(Turn!BoundElement))){
			thisModule.addBoundElementNodeToComponentRef(sBoundElement, tComponentRef);
		}	
	}
}

rule initEndPointUsingEndpointWithConnect(tEndPoint: Urn!EndPoint, sEndpointWithConnect: Turn!EndpointWithConnect){
	using{
		tConnect : Urn!Connect = OclUndefined;
		tNodeToConnect : Urn!PathNode = OclUndefined;
	}
	do{
		tEndPoint.name <- sEndpointWithConnect.regularEnd.turnGetLongestName();
		
		if(sEndpointWithConnect.regularEnd.condition.isDefined()){
			tEndPoint.postcondition <- thisModule.createCondition(sEndpointWithConnect.regularEnd.condition.expression.asString());
		}
		
		if(sEndpointWithConnect.connect.isDefined()){
			tConnect <- thisModule.createConnect();
			tNodeToConnect <- thisModule.getTargetNode(sEndpointWithConnect.connect);
			thisModule.chainDirectConnect(Sequence { tEndPoint, tConnect, tNodeToConnect });
		}
	}
}

rule initTimer(sTimer: Turn!Timer){
	using{
		tTimer : Urn!Timer = thisModule.getTargetNode(sTimer);
	}
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tTimer);
		
		if(sTimer.timeoutPath.isDefined()){
			thisModule.connectPathBody(sTimer.timeoutPath, tTimer, OclUndefined);
			
			if(sTimer.timeoutCondition.isDefined()){
				tTimer.succ.first().condition <- thisModule.createCondition(sTimer.timeoutCondition.expression.content.first());
			}
		}
		
		tTimer;
	}
}

-------------------------------------------------------------------------------------------------------------------------------

--------------2/3 CONDITIONAL INSTANTIATORS (getOrCreate)--------------
-- Used to get objects, or create them if they do not already exist.
-----------------------------------------------------------------------

rule getOrCreateStartPoint(sStartPoint: Turn!StartPoint){
	using{
		tStartPoint : Urn!StartPoint = OclUndefined;	
	}
	do{
		if(sStartPoint.isDefined()){
			tStartPoint <- thisModule.getTargetNode(sStartPoint);
		}
		else{
			tStartPoint <- thisModule.createStartPoint();
		}
		
		tStartPoint;
	}
}

rule getOrCreateEndPoint(sEndpointWithConnect: Turn!EndpointWithConnect){
	using{
		tEndPoint : Urn!PathNode = OclUndefined;
	}
	do{
		if(sEndpointWithConnect.oclIsTypeOf(Turn!EndpointWithConnect)){
			if(not sEndpointWithConnect.regularEnd.isDefined()){
				tEndPoint <- thisModule.createEndPoint();
				thisModule.endPointMap <- thisModule.endPointMap.including(sEndpointWithConnect.regularEnd, tEndPoint);
			}
			else if(not thisModule.getTargetNode(sEndpointWithConnect.regularEnd).isDefined()){
				tEndPoint <- thisModule.createEndPoint();
				thisModule.initEndPointUsingEndpointWithConnect(tEndPoint, sEndpointWithConnect);
				thisModule.endPointMap <- thisModule.endPointMap.including(sEndpointWithConnect.regularEnd, tEndPoint);
			}
			else{
				tEndPoint <- thisModule.getTargetNode(sEndpointWithConnect.regularEnd);
			}
		}
		
		tEndPoint;
	}
}

rule getOrCreateKPIEvalValueSet(sEvaluation: Turn!IndicatorConversion){
	using{
		tKPIEvalValueSet : Urn!KPIEvalValueSet = OclUndefined;	
	}
	do{
		if(sEvaluation.conversion.oclIsTypeOf(Turn!QualToQMappings)){
			tKPIEvalValueSet <- thisModule.createQMapKPIEvalValueSet(sEvaluation.conversion);
		}
		else if(sEvaluation.conversion.oclIsTypeOf(Turn!LinearConversion)){
			tKPIEvalValueSet <- thisModule.createKPIEvalValueSet(sEvaluation.conversion);
		}
		
		tKPIEvalValueSet;
	}
}

rule getOrCreatePathEnd(sPathBody: Turn!PathBody){
	using{
		tPathEnd : Urn!PathNode = OclUndefined;
	}
	do{
		if(sPathBody.pathEnd.isDefined()){
			if(sPathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				tPathEnd <- thisModule.getOrCreateEndPoint(sPathBody.pathEnd);
			}
			else{
				tPathEnd <- thisModule.getTargetNode(sPathBody.pathEnd);
			}
		}
		else if(sPathBody.referencedEnd.isDefined()){
			tPathEnd <- thisModule.getTargetNode(sPathBody.referencedEnd);
		}
		else if(sPathBody.referencedStub.isDefined()){
			tPathEnd <- thisModule.getTargetNode(sPathBody.referencedStub);
		}
		else{
			-- PathBody has no PathEnd.
		}
		
		tPathEnd;
	}
}

rule getOrCreateStartPointPrecondition(sStartPoint: Turn!StartPoint){
	using{
		tPrecondition : Urn!Condition = OclUndefined;	
	}
	do{
		if(sStartPoint.failKind.isDefined()){
			if(sStartPoint.catches.isDefined()){
				tPrecondition <- thisModule.createCondition(sStartPoint.catches);
			}
		}
		else{
			tPrecondition <- sStartPoint.precondition;
		}
		
		tPrecondition;
	}
}

rule getOrCreateReferencedComponent(sComponentRef: Turn!ComponentRef){
	using{
		tExistingComponent : Urn!Component = Urn!Component.allInstances() -> any(c|c.name=sComponentRef.name);
		tComponent: Urn!Component = OclUndefined;
	}
	do{
		if(tExistingComponent.isDefined()){
			tComponent <- tExistingComponent;
		}
		else{
			tComponent <- thisModule.createComponent(sComponentRef);
		}
		
		tComponent;
	}
}

rule getOrCreateReferencedResponsibility(sRespRef: Turn!RespRef){
	using{
		tResponsibility : Urn!Responsibility = OclUndefined;	
	}
	do{
		if(thisModule.getResponsibility(sRespRef.turnGetLongestName()).isDefined()){
			tResponsibility <- thisModule.getResponsibility(sRespRef.turnGetLongestName());
		}
		else{
			tResponsibility <- thisModule.createResponsibility(sRespRef);
		}
		
		tResponsibility;
	}
}

-------------------------------------------------------------------------------------------------------------------------------

------3/3 INSTANTIATORS------
-- Used to create objects.
-----------------------------
rule createAndJoin(){
	to
		tAndJoin: Urn!AndJoin(
			id <- thisModule.nextId().toString(),
			name <- 'AndJoin' + tAndJoin.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tAndJoin;
	}
}

rule createBeliefLink(sBeliefLink: Turn!ElementLink){
	to
		tBeliefLink: Urn!BeliefLink(
			target <- thisModule.resolveTemp(sBeliefLink.dest, 'tIntentionalElementRef')
		)	
	do{
		tBeliefLink;
	}
}

rule createComponent(sComponent: Turn!ComponentRef){
	to
		tComponent: Urn!Component(
			id <- thisModule.nextId().toString(),
			name <- sComponent.turnGetLongestName()
		)
	do{
		tComponent;	
	}
}

rule createCondition(vSourceExpression: String){
	to
	 	tCondition: Urn!Condition(
	 		expression <- vSourceExpression,
			label <- vSourceExpression
	 	)
	do{
		tCondition;
	}		
}

rule createConnect(){
	to
		tConnect: Urn!Connect(
			id <- thisModule.nextId().toString(),
			name <- 'Connect' + tConnect.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tConnect;	
	}
}

rule createEmptyPoint(){
	to
		tEmptyPoint: Urn!EmptyPoint(
			id <- thisModule.nextId().toString(),
			name <- 'EmptyPoint' + tEmptyPoint.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tEmptyPoint;
	}
}

rule createEndPoint(){
	to
		tEndPoint: Urn!EndPoint(
			id <- thisModule.nextId().toString(),
			name <- 'EndPoint' + tEndPoint.id,
			label <- thisModule.createLabel(),
			diagram <- thisModule.tUCMmap
		)
	do{
		tEndPoint;
	}
}

rule createKPIEvalValueSet(sLinearConversion: Turn!LinearConversion){
	to
		tKPIEvalValueSet: Urn!KPIEvalValueSet(
			unit <- sLinearConversion.unit,
			targetValue <- sLinearConversion.targetValue,
			thresholdValue <- sLinearConversion.thresholdValue,
			worstValue <- sLinearConversion.worstValue
		)
	do{
		tKPIEvalValueSet;
	}
}

rule createLabel(){
	to
		tNodeLabel: Urn!NodeLabel()
	do{
		tNodeLabel;
	}
}

rule createNewConnection(tPathNode: Urn!PathNode){
	to
		tNodeConnection: Urn!NodeConnection(
			source <- tPathNode
		)
	do{
		tNodeConnection;	
	}
}

rule createOrJoin(){
	to
		tOrJoin: Urn!OrJoin(
			id <- thisModule.nextId().toString(),
			name <- 'OrJoin' + tOrJoin.id,
			diagram <- thisModule.tUCMmap
		)
	do{
		tOrJoin;
	}
}

rule createQMapKPIEvalValueSet(sConversion: Turn!QualToQMappings){
	to		
		tQMapKPIEvalValueSet: Urn!KPIEvalValueSet(
			kpiConv <- sConversion	
		)
	do{
		tQMapKPIEvalValueSet;
	}
}

rule createResponsibility(sResponsibility: Turn!RespRef){
	to
		tResponsibility: Urn!Responsibility(
			id <- thisModule.nextId().toString(),
			name <- sResponsibility.turnGetLongestName()
		)
	do{
		tResponsibility;
	}
}

rule createStartPoint(){
	to
		tNodeLabel: Urn!NodeLabel(),
		tStartPoint: Urn!StartPoint (
			id <- thisModule.nextId().toString(),
			name <- 'StartPoint' + tStartPoint.id,
			label <- tNodeLabel
		)
	do{
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(tStartPoint);
		tStartPoint;
	}
}