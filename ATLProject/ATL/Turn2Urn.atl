module Turn2Urn;
-- paths to metamodels for content assist
--@path Turn=/ATLProject/Metamodels/Turn.ecore
--@path Urn=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

create OUT : Urn from IN : Turn;

uses Connect;
uses Create;

-- Contents:
--	 1/5 GLOBAL VARIABLES
--	 2/5 HELPERS
--	 3/5 CALLED RULES
--	 4/5 MATCHED RULES WITHOUT DO BLOCKS
--	 5/5 MATCHED RULES WITH DO BLOCKS

-------------1/5 GLOBAL VARIABLES-------------

helper def: id : Integer = 0;

helper def: endPointMap : Map(Turn!EndPoint, Urn!EndPoint) = Map{};

helper def: stubIndexMap : Map(Integer, Sequence(Sequence(Urn!PathNode))) = Map{};

helper def: tUCMmap : Urn!UCMmap = OclUndefined;

--------------2/5 HELPERS---------------------

helper context Turn!Text def : asString() : String =
	self.content -> iterate(item; condition : String = '' | condition.concat(item));

helper context String def : capitalize(): String = 
	self.substring(1,1).toUpper() + self.substring(2, self.size());

helper context Integer def : inc() : Integer = self + 1;

--This should only be called on TURN objects; I haven't been able to determine how to express that restriction using OCL, though.
helper context OclAny def : turnGetLongestName() : String = 
	if(self.longName.isDefined()) then
		if(self.longName.longname.isDefined()) then
			self.longName.longname
		else
			self.name	
		endif
	else
		self.name	
	endif;

helper context Urn!PathNode def : nextFreeConnection() : Urn!NodeConnection =
	self.succ -> any(s|not s.target.isDefined());

helper context Urn!PathNode def : isAlreadyConnectedTo(tPathNode: Urn!PathNode) : Boolean =
	self.succ -> any(s|s.target=tPathNode).isDefined();

helper context Urn!PathNode def : isJoin() : Boolean =
	self.oclIsTypeOf(Urn!OrJoin) or self.oclIsTypeOf(Urn!AndJoin);

helper context Urn!PathNode def : hasSuccessors() : Boolean =
	self.succ -> notEmpty();

helper context Urn!PathNode def : hasPredecessors() : Boolean =
	self.pred -> notEmpty();

helper context Urn!PathNode def : connectionWith(tPathNode: Urn!PathNode) : Urn!NodeConnection =
	self.succ -> any(s|s.target=tPathNode);

helper context Turn!Stub def : isBlocking() : Boolean = 
	self.stubType.toString() = 'blocking';

helper context Turn!Stub def : isSynchronizing() : Boolean = 
	self.stubType.toString() = 'blocking' or self.stubType.toString() = 'synchronizing';

helper context Turn!Stub def : isDynamic() : Boolean = 
	if(self.isSynchronizing()) then
		self.isSynchronizing()
	else
		if(self.params.isDefined()) then
			self.params.plugin -> flatten() -> size() >= 2
		else
			false
		endif
	endif;

helper context Turn!StartPoint def : getFailKind() :String =
	if(self.failKind.isDefined()) then
		self.failKind.toString().capitalize()
	else
		OclUndefined
	endif;
	
helper context Turn!FailurePoint def : getFailExpression() : String =
	if(self.failLabel.isDefined()) then
		self.failLabel.failure
	else
		OclUndefined
	endif;

helper context Turn!IntentionalElement def : getImportance() : String =
	if(self.importance.toString().toLower().equals('none')) then
		OclUndefined
	else
		self.importance.toString().capitalize()
	endif;

helper context Turn!IntentionalElement def : getType() : String =
	if(self.type.toString() = 'resource') then
		'Ressource'
	else
		self.type.toString().capitalize()
	endif;

helper context OclAny def : isDefined() : Boolean =
	not self.oclIsUndefined();

helper context Urn!PathNode def : hasFreeConnection() : Boolean =
	self.nextFreeConnection().isDefined();

helper context Turn!AndFork def : getPathBodies() : Sequence(Urn!PathBody) = 
	self.pathbody;

helper context Turn!OrFork def : getPathBodies() : Sequence(Urn!PathBody) = 
	if(self.body.isDefined()) then
		if(self.body.elseBody.isDefined()) then
			self.body.regularBody -> collect(rb|rb.pathBody) -> including(self.body.elseBody)
		else
			self.body.regularBody -> collect(rb|rb.pathBody)
		endif
	else
		Sequence {}
	endif;

helper context Turn!Stub def : getPathBodies() : Sequence(Urn!PathBody) = 
	self.outPaths -> collect(op|op.path);

helper context Turn!AndFork def : getConnectingBody() : Urn!PathBody = 
	self.connectingAndBody;

helper context Turn!OrFork def : getConnectingBody() : Urn!PathBody = 
	self.connectingOrBody;

helper context Turn!Stub def : getConnectingBody() : Urn!PathBody = 
	self.connectingStubBody;



-----------------------3/5 CALLED RULES-----------------------------

rule addConnectionToStubIndexMap(tFromNode: Urn!PathNode, tToNode: Urn!PathNode, vIndex: Integer){
	do{
		if(not thisModule.stubIndexMap.get(vIndex).isDefined()){
			thisModule.stubIndexMap <- thisModule.stubIndexMap.including(vIndex, Sequence{});
		}
		thisModule.stubIndexMap <- thisModule.stubIndexMap.including(vIndex, thisModule.stubIndexMap.get(vIndex).including(Sequence{tFromNode, tToNode}));
	}
}

rule collectPathBodyNodesAndEnds(sPathBody: Turn!PathBody){
	using{
		vTypesOfNodeToAdd : Sequence(String) = 
			Sequence { 
				'tRespRef', 'tAndJoin', 'tOrJoin', 
				'tWaitingPlace', 'tFailurePoint' 
			};
		sPathNodes : Sequence(Turn!PathNode) = sPathBody.pathNodes;
	}
	do{
		sPathNodes <- sPathNodes -> flatten();
		
		for(vTypeOfNodeToAdd in vTypesOfNodeToAdd){
			thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.union(sPathNodes -> collect(sPathNode|thisModule.resolveTemp(sPathNode, vTypeOfNodeToAdd)));
		}
		
		if(sPathBody.pathEnd.isDefined()){
			if(sPathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(sPathBody.pathEnd.regularEnd.isDefined()){
					thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(thisModule.retrieveNode(sPathBody.pathEnd));
				}
			}
			else{
				thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(thisModule.retrieveNode(sPathBody.pathEnd));
			}
		}
	}
}

-- Connects two or more nodes in the order of the input sequence.
rule chainDirectConnect(tNodesToConnect: Sequence(Urn!PathNode)){
	using{
		tFromNode: Urn!PathNode = OclUndefined;
	}
	do{
		for(tToNode in tNodesToConnect){
			if(tFromNode.isDefined()){
				thisModule.directConnect(tFromNode, tToNode);
			}
			
			tFromNode <- tToNode;
		}
	}
}

rule joinAllPreds(tSuccNode: Urn!PathNode){
	using{
		tJoin : Urn!OrJoin = thisModule.createOrJoin();
		
		-- Used to copy preds in case of an or join to iterate over them without causing concurrent modification exception.
		tPreds : Sequence(Urn!NodeConnection) = Sequence{};
	}
	do{
		-- Add to tPreds so that we're not directly iterating over the preds; 
		-- Trying to modify the pred list while iterating on it directly raises an error.
		for(tPred in tSuccNode.pred){
			tPreds <- tPreds.including(tPred);	
		}
		
		for(tPred in tPreds){
			tPred.target <- tJoin;
		}
		
		tJoin;
	}
}

rule connectWithEmptyPoint(tFromNode: Urn!PathNode, tToNode: Urn!PathNode){
	using{
		tEmptyPoint : Urn!EmptyPoint = thisModule.createEmptyPoint();
	}
	do{
		thisModule.chainDirectConnect(Sequence { tFromNode, tEmptyPoint, tToNode });
	}
}

-- Connects two nodes, handling various special cases.
rule connect(tFromNode: Urn!PathNode, tToNode: Urn!PathNode){
	using{
		tJoin : Urn!OrJoin = OclUndefined;
		tEmptyPoint : Urn!EmptyPoint = OclUndefined;
	}
	do{
		if(tFromNode.isDefined() and tToNode.isDefined()){
			if(tToNode.hasPredecessors() and not tFromNode.oclIsTypeOf(Urn!StartPoint) and not tFromNode.oclIsTypeOf(Urn!Connect) and not tToNode.isJoin()){
				-- If two nodes enter the same target, and that target is not a join, then we create an OrJoin
				-- as the target for all these connections and have this OrJoin enter that target instead.
				
				tJoin <- thisModule.joinAllPreds(tToNode);
				thisModule.chainDirectConnect(Sequence { tFromNode, tJoin, tToNode });
			}
			else{
				thisModule.directConnect(tFromNode, tToNode);
			}
		}
	}
}

-- Connect at some index of the set of predecessors of tToNode. If attempting to connect
-- at an index greater than currently available set of preds, just create a new connection.
-- (and so increase size of pred by 1)
rule connectAtTargetIndex(tFromNode: Urn!PathNode, tToNode: Urn!PathNode, vPredIndex: Integer){
	using{
		tOrJoin : Urn!OrJoin = OclUndefined;	
	}
	do{
		if(vPredIndex > tToNode.pred -> size()){
			-- If trying to connect at an index > existing predecessors, just create a new index.
			-- Note that this will not be precise if (vPredIndex > tToNode.pred -> size() + 1) as we are
			-- treating all indexes > currently available as simply 1 greater than the current value.
			
			thisModule.directConnect(tFromNode, tToNode);
		}
		else{
			-- OrJoin with whatever is connected to the current index.
			
			tOrJoin <- thisModule.createOrJoin();
			tToNode.pred -> at(vPredIndex).target <- tOrJoin;
			thisModule.connect(tFromNode, tOrJoin);
			thisModule.connect(tOrJoin, tToNode);
		}	
	}
}

rule contributionNumberToKeyword(vQuantitativeContribution: Integer){
	using{
		vContribution :	String = OclUndefined;
	}
	do{
		-- Dictionary. Had to use called rule as elseif is not supported in helpers
		
		if(vQuantitativeContribution <= -1)
			vContribution <- 'Hurt';
		else if(vQuantitativeContribution < -49)
			vContribution <- 'SomeNegative';
		else if(vQuantitativeContribution = -100)
			vContribution <- 'Break';
		else if(vQuantitativeContribution = 0)
			vContribution <- 'Unknown';
		else if(vQuantitativeContribution < 50)
			vContribution <- 'Help';
		else if(vQuantitativeContribution <= 99)
			vContribution <- 'SomePositive';
		else if(vQuantitativeContribution = 100)
			vContribution <- 'Make';
		else
			vContribution <- OclUndefined;
		
		vContribution;
	}
}

rule contributionKeywordToNumber(vKeyword: String){
	using{
		vQuantitativeContribution : Integer = OclUndefined;	
	}
	do{
		if(vKeyword.equals('Make'))
			vQuantitativeContribution <- 100;
		else if(vKeyword.equals('Hurt'))
			vQuantitativeContribution <- -25;
		else if(vKeyword.equals('Break'))
			vQuantitativeContribution <- -100;
		else if(vKeyword.equals('SomePositive'))
			vQuantitativeContribution <- 50;
		else if(vKeyword.equals('SomeNegative'))
			vQuantitativeContribution <- -50;
		else if(vKeyword.equals('Help'))
			vQuantitativeContribution <- 25;
		else
			vQuantitativeContribution <- OclUndefined;
		
		vQuantitativeContribution;
	}
}

-- Connects two nodes, creating a connection with an empty point in between if the connection already exists.
rule directConnect(tFromNode: Urn!PathNode, tToNode: Urn!PathNode){
	do{
		if(tFromNode.isDefined() and tToNode.isDefined()){
			if(tFromNode.connectionWith(tToNode).isDefined()){
				thisModule.connectWithEmptyPoint(tFromNode, tToNode);	
			}
			else{
				if(not tFromNode.hasFreeConnection() and not tFromNode.connectionWith(tToNode).isDefined()){
					thisModule.createNewConnection(tFromNode);
				}
				
				thisModule.tUCMmap.connections <- thisModule.tUCMmap.connections.including(tFromNode.nextFreeConnection());
				thisModule.useConnection(tToNode, tFromNode.nextFreeConnection());
			}
		}
	}
}

-- Find and return the path between tStartNode and tEndNode as a sequence of PathNodes.
rule findPathBetweenNodes(tStartNode: Urn!PathNode, tEndNode: Urn!PathNode){
	using{
		tResult : Sequence(Urn!PathNode) = Sequence{};
		tConnect : Urn!Connect = OclUndefined;
	}
	do{
		if(tStartNode=tEndNode){
			tResult <- tResult.including(tStartNode);
		}
		else if(tStartNode.succ -> isEmpty()){
			-- Node not found in this path
		}
		else{
			for(tCurrentNode in tStartNode.succ -> collect(s|s.target)){
				tResult <- tResult.union(thisModule.findPathBetweenNodes(tCurrentNode, tEndNode));
			}
		}
		
		if(tStartNode<>tEndNode and tResult -> notEmpty()){
			tResult <- tResult.including(tStartNode);
			tConnect <- tStartNode.pred -> collect(p|p.source) -> any(s|s.oclIsTypeOf(Urn!Connect));
			
			if(tConnect.isDefined()){
				tResult <- tResult.including(tConnect);
				tResult <- tResult.union(tConnect.pred -> collect(p|p.source));
			}
		}
		
		tResult;
	}
}

rule getResponsibility(vResponsibilityName: String){
	do{
		Urn!Responsibility.allInstances() -> any(n|n.name=vResponsibilityName);
	}
}

rule nextId(){
	do{
		thisModule.id <- thisModule.id.inc();
		thisModule.id;
	}
}

-- Gets the Urn counterpart for a Turn node.
rule retrieveNode(sPathNode: Turn!PathNode){
	using{
		vPathNodeTypes : Sequence(String) = 
			Sequence {
				'tWaitingPlace', 'tFailurePoint', 'tRespRef',
				'tTimer', 'tAndFork', 'tOrFork', 'tStub',
				'tAndJoin', 'tOrJoin'
			};
		tRetrievedNode : Urn!PathNode = OclUndefined;
	}
	do{
		if(sPathNode.isDefined()){
			if(sPathNode.oclIsTypeOf(Turn!Stub)){
				if(sPathNode.stubRef.isDefined()){
					-- Stub was created Using a stub declaration, so we need to find that.
					sPathNode <- sPathNode.stubRef;
				}
			}
			else if(sPathNode.oclIsTypeOf(Turn!Connect)){
				sPathNode <- sPathNode.connectsTo;
			}
			else if(sPathNode.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(not sPathNode.regularEnd.isDefined()){
					-- If the regularEnd isn't defined, just get the first EndPoint.
					-- This won't work correctly if there's more than one unnamed EndPoint.
					-- TODO: fix this to make it work more generally.
					
					tRetrievedNode <- thisModule.tUCMmap.nodes -> any(n|n.oclIsTypeOf(Urn!EndPoint));
				}
				
				sPathNode <- sPathNode.regularEnd;
			}
			
			if(sPathNode.oclIsTypeOf(Turn!EndPoint)){
				tRetrievedNode <- thisModule.endPointMap.get(sPathNode);
			}
			else{
				for(vPathNodeType in vPathNodeTypes){
					if(not tRetrievedNode.isDefined()){
						tRetrievedNode <- thisModule.resolveTemp(sPathNode, vPathNodeType);	
					}
				}
			}
			
			if(not tRetrievedNode.isDefined()){
				tRetrievedNode <- thisModule.tUCMmap.nodes -> any(n|n.name=sPathNode.turnGetLongestName());
			}
		}
		
		tRetrievedNode;
	}
}

rule updateComponentRefUsingLongBoundElement(tFrom: String, tTo: String, tComponentRef: Urn!ComponentRef, nodes: Sequence(Urn!StartPoint)){
	using{
		tFromExists : Boolean = 
			(nodes -> any(n|n.name = tFrom).isDefined())
			or (nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.respDef.name=tFrom) -> notEmpty())
			and tFrom <> '';
		tToExists : Boolean = 
			(nodes -> any(n|n.name = tTo).isDefined())
			or (nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(rr|rr.respDef.name=tTo) -> notEmpty())
			and tTo <> '';
		tStartNode : Urn!PathNode = OclUndefined;
		tEndNode : Urn!PathNode = OclUndefined;
	}
	do{
		if(tFromExists and tToExists){ --unidirectional, tFrom must be before tTo
			tStartNode <- nodes -> any(n|n.name=tFrom);

			if(not tStartNode.isDefined()){
				tStartNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.respDef.name=tFrom);
			}
			
			tEndNode <- nodes -> any(n|n.name=tTo);
			
			if(not tEndNode.isDefined()){
				tEndNode <- nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.respDef.name=tTo);
			}
			
			tComponentRef.nodes <- thisModule.findPathBetweenNodes(tStartNode, tEndNode);
		}
	}
}

rule useConnection(tToNode: Urn!PathNode, tConnectionFromPreviousNode: Urn!NodeConnection){
	do{
		tToNode.pred <- tToNode.pred.including(tConnectionFromPreviousNode);
	}
}

-------------4/5 MATCHED RULES WITHOUT DO BLOCKS------------

rule Actor2Actor{
	from 
		sActor: Turn!Actor
	to 
		tActor: Urn!Actor(
			id <- thisModule.nextId().toString(),
			name <- sActor.turnGetLongestName(),
			importanceQuantitative <- sActor.importanceQuantitative
		),
		tActorRef: Urn!ActorRef(
			id <- thisModule.nextId().toString(),
			name <- 'ActorRef' + tActorRef.id,
			contDef <- tActor,
			nodes <- sActor.elems -> collect(e|thisModule.resolveTemp(e, 'tIntentionalElementRef')).union(sActor.elems -> collect(e|thisModule.resolveTemp(e, 'tBelief'))),
			label <- tCompLabel
		),
		tCompLabel: Urn!ComponentLabel
}

rule AndFork2AndFork{
	from
		sAndFork: Turn!AndFork
	using{
		vId : String = thisModule.nextId().toString();
		vAndForkName : String = sAndFork.turnGetLongestName();
		vName : String = 
			if(vAndForkName.isDefined()) then
				vAndForkName
			else
				'AndFork' + vId
			endif;
		vLabel : Urn!Label =
			if(vAndForkName.isDefined()) then
				thisModule.createLabel()
			else
				OclUndefined
			endif;
	}
	to
		tAndFork: Urn!AndFork (
			id <- vId,
			name <- vName,
			label <- vLabel,
			diagram <- thisModule.tUCMmap
		)
}

rule AndJoin2AndJoin{
	from 	
		sAndJoin: Turn!AndJoin
	to
		tAndJoin: Urn!AndJoin(
			id <- thisModule.nextId().toString(),
			name <- sAndJoin.turnGetLongestName(),
			label <- tNodeLabel
		),
		tNodeLabel: Urn!NodeLabel
}

rule ComponentBinding2ComponentBinding{
	from
		sComponentBinding: Turn!ComponentBinding
	to
		tComponentBinding: Urn!ComponentBinding(
			pluginComponent <- thisModule.resolveTemp(sComponentBinding.componentIn, 'tComponentRef'),
			parentComponent <- thisModule.resolveTemp(sComponentBinding.componentOut, 'tComponentRef')
		)
}

rule Concern2Concern{
	from 
		sConcern: Turn!Concern
	to 
		tConcern: Urn!Concern(
			id <- thisModule.nextId().toString(),
			name <- sConcern.turnGetLongestName(),
		 	elements <- sConcern.elements,
			--TODO: Turn!Concern has no property metadata; is this perhaps a logical error?
			--metadata <- s.metadata,
			condition <- sConcern.condition
		)
}

rule Condition2Condition{
	from 
		sCondition: Turn!Condition
	to 
		tCondition: Urn!Condition(
			expression <- sCondition.expression.asString(),
			label <- sCondition.expression.asString()
		)
	
}

rule Contribution2Contribution{
	from 
		sContribution: Turn!Contribution(sContribution.link.type.toString() <> 'belief')
	using{
		vHasNoContributionType : Boolean = sContribution.contribution.toString().equals('undefined');
	
		vContribution : String =
			if(vHasNoContributionType) then
				thisModule.contributionNumberToKeyword(sContribution.quantitativeContribution)
			else
				sContribution.contribution.toString().capitalize()
			endif;

		vQuantitativeContribution : Integer = thisModule.contributionKeywordToNumber(vContribution);
	}
	to 
		tContribution: Urn!Contribution(
			id <- thisModule.nextId().toString(),
			name <- sContribution.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(sContribution.dest, 'tIntentionalElement'),
			refs <- tLinkRef,
	 		correlation <- sContribution.correlation,
			contribution <- vContribution,
			quantitativeContribution <- vQuantitativeContribution
		),
		tLinkRef: Urn!LinkRef(
			link <- tContribution,
			target <- thisModule.resolveTemp(sContribution.dest, 'tIntentionalElementRef')
		)
}

rule ContributionChange2ContributionChange{
	from
		sContributionChange: Turn!ContributionChange
	using{
		vNewContribution : String = 
			if(sContributionChange.newContribution.toString() = 'undefined') then
				OclUndefined
			else
				sContributionChange.newContribution.toString().capitalize()
			endif;		
	}
	to
		tContributionChange: Urn!ContributionChange(
			contribution <- sContributionChange.contribution,
			newQuantitativeContribution <- sContributionChange.newQuantitativeContribution,
			newContribution <- vNewContribution
		)
}

rule ContributionContext2ContributionContext{
	from
		sContributionContext: Turn!ContributionContext
	to
		tContContext: Urn!ContributionContext(
			id <- thisModule.nextId().toString(),
			name <- sContributionContext.turnGetLongestName(),
			changes <- sContributionContext.changes,
			includedContexts <- sContributionContext.includedContexts
		)
}

rule ContributionContextGroup2ContributionContextGroup{
	from
		sContributionContextGroup: Turn!ContributionContextGroup
	to
		tContribGroups: Urn!ContributionContextGroup(
			id <- thisModule.nextId().toString(),
			name <- sContributionContextGroup.turnGetLongestName(),
			contribs <- sContributionContextGroup.contribs.including(sContributionContextGroup.contrib)
		)
}
	
rule Decomposition2Decomposition{
	from 
		sDecomposition: Turn!Decomposition(sDecomposition.link.type.toString() <> 'belief')
	to 
		tDecomposition: Urn!Decomposition(
			id <- thisModule.nextId().toString(),
			name <- sDecomposition.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(sDecomposition.dest, 'tIntentionalElement'),
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef(
			link <- tDecomposition,
			target <- thisModule.resolveTemp(sDecomposition.dest, 'tIntentionalElementRef')
		)
}

rule Dependency2Dependency{
	from 
		sDependency: Turn!Dependency(sDependency.link.type.toString() <> 'belief')
	to 
		tDependency: Urn!Dependency(
			id <- thisModule.nextId().toString(),
			name <- sDependency.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(sDependency.dest, 'tIntentionalElement'),
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef(
			link <- tDependency,
			target <- thisModule.resolveTemp(sDependency.dest, 'tIntentionalElementRef')
		)
}

rule Evaluation2Evaluation{
	from
		sEvaluation: Turn!Evaluation
	using{
		vKPIEvalValueSet : Urn!KPIEvalValueSet =
			if(sEvaluation.conversion.oclIsTypeOf(Turn!QualToQMappings)) then
				thisModule.createQMapKpiEvalValueSet(sEvaluation.conversion)
			else
				if(sEvaluation.conversion.oclIsTypeOf(Turn!LinearConversion)) then
					thisModule.createKPIEvalValueSet(sEvaluation.conversion)
				else
					OclUndefined
				endif
			endif;
	}
 	to 
		tEvaluation: Urn!Evaluation(
		 	exceeds <- sEvaluation.exceeds,
		 	intElement <- thisModule.resolveTemp(sEvaluation.intElement, 'tIntentionalElement'),
			evaluation <- sEvaluation.evaluation,
			qualitativeEvaluation <- sEvaluation.qualitativeEvaluation.toString().capitalize(),
			kpiEvalValueSet <- vKPIEvalValueSet
		)
}

rule FailurePoint2FailurePoint{
	from		
		sFailurePoint: Turn!FailurePoint
	to
		tFailurePoint: Urn!FailurePoint (
			id <- thisModule.nextId().toString(),
			name <- sFailurePoint.turnGetLongestName(),
			succ <- tNodeConnection,
			label <- tNodeLabel,
			expression <- sFailurePoint.getFailExpression()
		),
		tNodeConnection: Urn!NodeConnection(
			condition <- sFailurePoint.condition
		),
		tNodeLabel: Urn!NodeLabel
}

-- IntentionalElement2Belief must come AFTER IntentionalElement2IntentionaElement!
rule IntentionalElement2IntentionalElement{
	from 
		sIntentionalElement: Turn!IntentionalElement(sIntentionalElement.type.toString() <> 'belief')
	using{
		sDecomposition : Turn!Decomposition = Turn!Decomposition -> allInstances() -> any(d|d.dest=sIntentionalElement);
		vId : String = thisModule.nextId().toString();
		vDecompositionType : String = 
			if(sDecomposition.isDefined()) then
				sDecomposition.decompositionType.toString().capitalize()
			else
				OclUndefined
			endif;
		vName : String = 
			if(sIntentionalElement.turnGetLongestName().isDefined()) then
				sIntentionalElement.turnGetLongestName()
			else
				'IntentionalElementRef' + vId
			endif;
	}
	to 
		tIntentionalElementRef: Urn!IntentionalElementRef(
			id <- vId,
			name <- vName,
			def <- tIntentionalElement,
			succ <- sIntentionalElement.linksSrc -> collect(c|thisModule.resolveTemp(c, 'tLinkRef'))
		),
		tIntentionalElement: Urn!IntentionalElement(
			id <- thisModule.nextId().toString(),
			name <- sIntentionalElement.turnGetLongestName(),
			linksSrc <- sIntentionalElement.linksSrc,
			decompositionType <- vDecompositionType,
			type <- sIntentionalElement.getType(),
			importance <- sIntentionalElement.getImportance(),
			importanceQuantitative <- sIntentionalElement.importanceQuantitative,
			metadata <- thisModule.createMetadata('TURN-URN-NAME', sIntentionalElement.name)
		)
}

-- IntentionalElement2Belief must come AFTER IntentionalElement2IntentionaElement!
rule IntentionalElement2Belief{
	from
		sIntentionalElement: Turn!IntentionalElement(sIntentionalElement.type.toString() = 'belief')
	using{
		tBeliefLinks : Sequence(Urn!BeliefLink) = sIntentionalElement.linksSrc -> collect(sLink| thisModule.createBeliefLink(sLink));
	}
	to 
	 	tBelief: Urn!Belief(
	 		id <- thisModule.nextId().toString(),
	 		name <- sIntentionalElement.name,
			description <- sIntentionalElement.name,
			succ <- tBeliefLinks
	 	)
}

rule Metadata2Metadata{
	from 
		sMetadata: Turn!Metadata
	to 
		tMetadata: Urn!Metadata(
			name <- sMetadata.name
		)
}

rule OrFork2OrFork{
	from
		sOrFork: Turn!OrFork
	using{
		vId : String = thisModule.nextId().toString();
		vOrForkName : String = sOrFork.turnGetLongestName();
		vName : String = 
			if(vOrForkName.isDefined()) then
				vOrForkName
			else
				'OrFork' + vId	
			endif;
		vLabel : Urn!Label =
			if(vOrForkName.isDefined()) then
				thisModule.createLabel()
			else
				OclUndefined
			endif;		
	}
	to
		tOrFork: Urn!OrFork(
			id <- vId,
			name <- vName,
			label <- vLabel,
			diagram <- thisModule.tUCMmap
		)
}

rule OrJoin2OrJoin{
	from 	
		sOrJoin: Turn!OrJoin
	to
		tOrJoin: Urn!OrJoin(
			id <- thisModule.nextId().toString(),
			name <- sOrJoin.turnGetLongestName(),
			label <- tNodeLabel
		),
		tNodeLabel: Urn!NodeLabel
}

rule PluginBinding2PluginBinding{
	from 
		sPluginBinding: Turn!PluginBinding	
	to
		tPluginBinding: Urn!PluginBinding(
			-- this could be other way round, binding could be inBinding or OutBinding and vice-versa.
			in <- sPluginBinding.bindings -> collect(b|thisModule.resolveTemp(b, 'tInBinding')).including(thisModule.resolveTemp(sPluginBinding.binding, 'tInBinding')),
			components <- sPluginBinding.bindings -> collect(b|thisModule.resolveTemp(b,'tComponentBinding')),
			out <- sPluginBinding.bindings -> collect(b|thisModule.resolveTemp(b, 'tOutBinding')).including(thisModule.resolveTemp(sPluginBinding.binding, 'tOutBinding')),
			plugin <- thisModule.resolveTemp(sPluginBinding.map, 'tUCMmap'),
			precondition <- thisModule.resolveTemp(sPluginBinding.condition, 'tCondition'),
			replicationFactor <- sPluginBinding.replication
		)
}

rule QMapping2QMapping{
	from 
		sQualToQMapping: Turn!QualToQMapping
	to
		tQualitativeMapping: Urn!QualitativeMapping(
			realWorldLabel <- sQualToQMapping.realWorldLabel,
			exceeds	<- sQualToQMapping.exceeds,
			evaluation <- sQualToQMapping.evaluation,
			qualitativeEvaluation <- sQualToQMapping.qualitativeEvaluation.toString().capitalize()
		)
}

rule QMappings2QMappings{
	from
		sQualToQMappings: Turn!QualToQMappings
	to
		tQualitativeMappings: Urn!QualitativeMappings(
			id <- thisModule.nextId().toString(),
			name <- sQualToQMappings.turnGetLongestName(),
			mapping <- sQualToQMappings.mappings
		)
}

rule RespRef2Responsibility{
	from
		sRespRef: Turn!RespRef
	using{
		tResponsibility : Urn!Responsibility = thisModule.getOrCreateReferencedResponsibility(sRespRef);
	}
	to
		tRespRef: Urn!RespRef(
			id <- thisModule.nextId().toString(),
			name <- 'RespRef' + tRespRef.id,
			label <- tNodeLabel,
			respDef <- tResponsibility
		),
		tNodeLabel: Urn!NodeLabel
}

rule StartPoint2StartPoint{
	from
		sStartPoint: Turn!StartPoint
	using{
		tPrecondition : Urn!Condition =
			if(sStartPoint.failKind.isDefined()) then
				if(sStartPoint.catches.isDefined()) then
					thisModule.createCondition(sStartPoint.catches)
				else
					OclUndefined
				endif
			else
				sStartPoint.precondition
			endif;
	}
	to
		tStartPoint: Urn!StartPoint(
			id <- thisModule.nextId().toString(),
			name <- sStartPoint.turnGetLongestName(),
			label <- tNodeLabel,
			precondition <- tPrecondition,
			failureKind <- sStartPoint.getFailKind()
		),
		tNodeLabel: Urn!NodeLabel
}

rule Strategies2Strategies{
	from
		sEvaluationStrategy: Turn!EvaluationStrategy
	using{
		vAuthor : String =
			if(sEvaluationStrategy.info.isDefined()) then
				sEvaluationStrategy.info.author
			else
				OclUndefined
			endif;
	}
	to
		tEvaluationStrategy: Urn!EvaluationStrategy(
			id <- thisModule.nextId().toString(),
			name <- sEvaluationStrategy.turnGetLongestName(),
			evaluations <- sEvaluationStrategy.evaluations,
			includedStrategies <- sEvaluationStrategy.includedStrategies,
			author <- vAuthor
		)
}

rule StrategiesGroup2StrategiesGroup{
	from
		sStrategiesGroup: Turn!StrategiesGroup
	to
		tStrategiesGroup: Urn!StrategiesGroup(
			id <- thisModule.nextId().toString(),
			name <- sStrategiesGroup.turnGetLongestName(),
			strategies <- sStrategiesGroup.evalStrategies.including(sStrategiesGroup.evalStrategy)
		)
}

rule Stub2Stub{
	from
		sStub: Turn!Stub(not sStub.stubRef.isDefined())
	to
		tStub: Urn!Stub(
			id <- thisModule.nextId().toString(),
			name <- sStub.turnGetLongestName(),
			diagram <- thisModule.tUCMmap,
			label <- tNodeLabel,
			blocking <- sStub.isBlocking(),
			synchronization <- sStub.isSynchronizing(),
			dynamic <- sStub.isDynamic(),
			bindings <- sStub.params.plugin-> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'))
		),
		tNodeLabel: Urn!NodeLabel
}

rule StubDeclaration2Stub{
	from
		sStubDeclaration: Turn!StubDeclaration
	to
		tStub: Urn!Stub(id <- thisModule.nextId().toString(),
			name <- sStubDeclaration.turnGetLongestName(),
			label <- tNodeLabel,
			diagram <- thisModule.tUCMmap,
			bindings <- sStubDeclaration.params.plugin-> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'))
		),
		tNodeLabel: Urn!NodeLabel
}

rule Timer2Timer{
	from
		sTimer: Turn!Timer
	to
		tTimer: Urn!Timer(
			id <- thisModule.nextId().toString(),
			name <- sTimer.turnGetLongestName(),
			succ <- tNodeConn,
			diagram <- thisModule.tUCMmap,
			label <- tNodeLabel,
			waitType <- sTimer.kind.toString().capitalize()
		),
		tNodeConn: Urn!NodeConnection(
			condition <- sTimer.condition
		),
		tNodeLabel: Urn!NodeLabel
}

rule URNlink2URNlink{
	from 
		sURNlink: Turn!URNlink
	to 
		tURNlink: Urn!URNlink(
			type <- sURNlink.type,
			fromElem <- sURNlink.fromElem,
			toElem <- sURNlink.toElem
		)
}

rule WaitingPlace2WaitingPlace{
	from		
		sWaitingPlace: Turn!WaitingPlace
	to
		tWaitingPlace: Urn!WaitingPlace(
			id <- thisModule.nextId().toString(),
			name <- sWaitingPlace.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel,
			waitType <- sWaitingPlace.kind.toString().capitalize()
		),
		tNodeConn: Urn!NodeConnection (
			condition <- sWaitingPlace.condition
		),
		tNodeLabel: Urn!NodeLabel
}

----------5/5 MATCHED RULES WITH DO BLOCKS----------------

rule UCMmap2UCMmap{
	from
		sUCMmap: Turn!UCMmap
	to
		tUCMmap: Urn!UCMmap(
			id <- thisModule.nextId().toString(),
			name <- sUCMmap.turnGetLongestName(),
			contRefs <- sUCMmap.components -> collect(c|thisModule.resolveTemp(c, 'tComponentRef')),
			nodes <- sUCMmap.paths -> flatten() -> collect(p|p.startPoint) -> flatten() -> collect(p|thisModule.resolveTemp(p, 'tStartPoint')),
			connections <- sUCMmap.paths -> flatten() -> collect(p|p.startPoint) -> flatten() -> collect(p|thisModule.resolveTemp(p, 'tNodeConn'))
		)
	do{
		thisModule.connectUCMmap(tUCMmap, sUCMmap.paths);
	}
}

rule ComponentRef2ComponentRef {
	from 
		sComponentRef: Turn!ComponentRef
	using{
		tExistingComponent : Urn!Component = Urn!Component.allInstances() -> any(c|c.name=sComponentRef.name);
		tRetrievedComponent : Urn!Component =
			if(tExistingComponent.isDefined()) then
				tExistingComponent
			else
				thisModule.createComponent(sComponentRef)
			endif;
		tPathNode : Urn!PathNode = OclUndefined;
	}
	to
		tComponentRef: Urn!ComponentRef(
			id <- thisModule.nextId().toString(),
			name <- 'ComponentRef' + tComponentRef.id,
			label <- tComponentLabel,
			diagram <- sComponentRef.map,
			contDef <- tRetrievedComponent
		),
		tComponentLabel: Urn!ComponentLabel
	do{
		thisModule.initComponentRef(sComponentRef, tComponentRef);
		thisModule.tUCMmap <- tComponentRef.diagram;
		
		for(elem in (sComponentRef.elements.including(sComponentRef.element)) -> select(e|e.oclIsTypeOf(Turn!LongBoundElement))){
			thisModule.updateComponentRefUsingLongBoundElement(elem.from, elem.to, tComponentRef, tComponentRef.diagram.nodes);
		}

		for(elem in (sComponentRef.elements.including(sComponentRef.element)) -> select(e|e.oclIsTypeOf(Turn!BoundElement))){
			tPathNode <- thisModule.retrieveNode(elem.elem);
			
			if(not tPathNode.isDefined()){
				tPathNode <- thisModule.resolveTemp(elem.elem, 'tComponentRef');
				tComponentRef.children <- tComponentRef.children.including(tPathNode);
			}
			else if(not tPathNode.contRef.isDefined() or tPathNode.contRef=tComponentRef.parent){
				tComponentRef.nodes <- tComponentRef.nodes.including(tPathNode);
			}
		}
	}
}

rule InBinding2InBinding{
	from
		sInBinding: Turn!InBinding
	to
		tInBinding: Urn!InBinding
	do{
		thisModule.initBinding(sInBinding, tInBinding);
	}
}

rule OutBinding2OutBinding{
	from
		sOutBinding: Turn!OutBinding
	to
		tOutBinding: Urn!OutBinding
	do{
		thisModule.initBinding(sOutBinding, tOutBinding);
	}
}

rule URNspec2URNspec{
	from 
		sURNspec: Turn!URNspec
	using{
		vElements : Sequence(Turn!IntentionalElement) = sURNspec.actors -> collect(actor|actor.elems) -> flatten();	
		vAllIntElements : Sequence(Turn!IntentionalElement) = vElements -> select(e|e.type.toString() <> 'belief');
		vIntElemRefs : Sequence(Urn!IntentionalElementRef) = vElements -> collect(e| thisModule.resolveTemp(e, 'tIntentionalElementRef'));
		vBeliefs : Sequence(Urn!Belief) = vElements -> select(e|e.type.toString() = 'belief') -> collect(b| thisModule.resolveTemp(b, 'tBelief'));
			
		vLinksSrc : Sequence(Turn!ElementLink) = vElements -> collect(e|e.linksSrc) -> flatten();
		vContributions : Sequence(Urn!Contribution) = vLinksSrc -> collect(l|thisModule.resolveTemp(l, 'tContribution'));
		vDecompositions : Sequence(Urn!Decomposition) = vLinksSrc -> collect(l|thisModule.resolveTemp(l, 'tDecomposition'));
		vDependencies : Sequence(Urn!Dependency) = vLinksSrc -> collect(l|thisModule.resolveTemp(l, 'tDependency'));
		
		vLinkRefs : Sequence(Urn!LinkRef) = vLinksSrc -> collect(m| thisModule.resolveTemp(m, 'tLinkRef'));
	}
	to
		tURNspec: Urn!URNspec(
			name <- sURNspec.name,
			metadata <- sURNspec.metadata,
			grlspec <- tGRLspec,
			ucmspec <- tUCMspec,
			urnLinks <- sURNspec.urnlinks,
			urndef <- tURNdef
		),
		tURNdef: Urn!URNdefinition(
			specDiagrams <- Sequence{tGRLSpecDiag}.union(sURNspec.ucmMaps -> collect(m|thisModule.resolveTemp(m, 'tUCMmap'))),
			concerns <- sURNspec.concerns,
			components <- Urn!Component.allInstances(),
			responsibilities <- Urn!Responsibility.allInstances()
		),
		tGRLspec: Urn!GRLspec(
			actors <- sURNspec.actors,
			intElements <- vAllIntElements -> collect(i|thisModule.resolveTemp(i, 'tIntentionalElement')),
			groups <- sURNspec.stratGroups,
			strategies <- sURNspec.strategies,
			contributionGroups <- sURNspec.contribContextGroups,
			contributionContexts <- sURNspec.contribContexts,
			KPIConversion <- sURNspec.indConversions -> select(c|c.oclIsTypeOf(Turn!QualToQMappings)),
			links <- vContributions.union(vDecompositions).union(vDependencies)
		),
		tGRLSpecDiag: Urn!GRLGraph(
			id <- thisModule.nextId().toString(),
		 	nodes <- vIntElemRefs.union(vBeliefs),
			contRefs <- sURNspec.actors -> collect(a|thisModule.resolveTemp(a, 'tActorRef')),
			connections <- vLinkRefs.union(vBeliefs -> collect(b|b.succ))
		),
		tUCMspec: Urn!UCMspec()
	do{
		if(sURNspec.info.isDefined()){
			tURNspec.description <- sURNspec.info.description;
			tURNspec.author <- sURNspec.info.author;
			tURNspec.created <- sURNspec.info.created;
			tURNspec.modified <- sURNspec.info.modified;
			tURNspec.specVersion <- sURNspec.info.specVersion;
			tURNspec.urnVersion <- sURNspec.info.urnVersion; 
		}
		
		if(sURNspec.metadata -> any(m|m.name='TURN-URN-nextGlobalID').isDefined()){
	 		thisModule.id <- sURNspec.metadata -> any(m|m.name='TURN-URN-nextGlobalID').value.toInteger();
		}
		
		tURNspec.nextGlobalID <- thisModule.id.toString();
	}
}
