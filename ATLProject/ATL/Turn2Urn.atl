-------------------------------------
-- TURN2URN
-------------------------------------
-- Author: Ruchika Kumar, 2016
-------------------------------------
-- Edited by: Saahil Hamayun, 2019
-------------------------------------

module Turn2Urn;
-- paths to metamodels for content assist
--@path Turn=/ATLProject/Metamodels/Turn.ecore
--@path Urn=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

create OUT : Urn from IN : Turn;

uses Connect;
uses Create;
uses Utilities;

-------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------
--	File: Turn2Urn.atl
-----------------------------------------------------------------------------
--	Description:
--		Contains the matched rules for the TUrn2Urn transformation. 
--      This file is the starting point for the model transformation.
--      Key node connection functionlaities take place in URNspec2URNspec.
-----------------------------------------------------------------------------
--	Contents:
--		1/3 GLOBAL VARIABLES
--		2/3 FREELY ORDERABLE MATCHED RULE
--          * rule Actor2Actor
--          * rule AndFork2AndFork
--          * rule AndJoin2AndJoin
--          * rule ComponentBinding2ComponentBinding
--          * rule ComponentRef2ComponentRef
--          * rule Concern2Concern
--          * rule Condition2Condition
--          * rule Contribution2Contribution
--          * rule ContributionChange2ContributionChange
--          * rule ContributionContext2ContributionContext
--          * rule ContributionContextGroup2ContributionContextGroup
--          * rule Decomposition2Decomposition
--          * rule Dependency2Dependency
--          * rule Evaluation2Evaluation
--          * rule FailurePoint2FailurePoint
--          * rule IntentionalElement2IntentionalElement
--          * rule IntentionalElement2Belief
--          * rule Metadata2Metadata
--          * rule OrFork2OrFork
--          * rule OrJoin2OrJoin
--          * rule PluginBinding2PluginBinding
--          * rule QMapping2QMapping
--          * rule QMappings2QMappings
--          * rule RespRef2Responsibility
--          * rule StartPoint2StartPoint
--          * rule Strategies2Strategies
--          * rule StrategiesGroup2StrategiesGroup
--          * rule Stub2Stub
--          * rule StubDeclaration2Stub
--          * rule Timer2Timer
--          * rule URNlink2URNlink
--          * rule URNspec2URNspec
--          * rule WaitingPlace2WaitingPlace
--		3/3 STRICTLY ORDERED MATCHED RULE
--          * rule UCMmap2UCMmap
--          * rule InBinding2InBinding
--          * rule OutBinding2OutBinding
-----------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------

--------------1/3 GLOBAL VARIABLES--------------
-- Global variables used throughout the files --
-- of this project.                           --
------------------------------------------------

helper def: id : Integer = 0;

helper def: endPointMap : Map(Turn!EndPoint, Urn!EndPoint) = Map{};

-- Map will contain entries as such: 
--   Integer -> Sequence{{fromNode1, toNode1},...}
helper def: stubIndexMap : Map(Integer, Sequence(Sequence(Urn!PathNode))) = Map{};

helper def: tUCMmap : Urn!UCMmap = OclUndefined;

-------------------------------------------------------------------------------------------------------------------------------

---------------2/3 FREELY ORDERABLE MATCHED RULES---------------
-- The order these matched rules are placed in  with respect
-- to each other should not impact anything more than the
-- order in which the IDs have been distributed.
----------------------------------------------------------------

rule Actor2Actor{
	from 
		sActor: Turn!Actor
	to 
		tActor: Urn!Actor(
			id <- thisModule.nextId().toString(),
			name <- sActor.turnGetLongestName(),
			importanceQuantitative <- sActor.importanceQuantitative
		),
		tActorRef: Urn!ActorRef(
			id <- thisModule.nextId().toString(),
			name <- 'ActorRef' + tActorRef.id,
			contDef <- tActor,
			nodes <- sActor.getNodes(),
			label <- tCompLabel
		),
		tCompLabel: Urn!ComponentLabel
}

rule AndFork2AndFork{
	from
		sAndFork: Turn!AndFork
	using{
		vLabel : Urn!Label =
			if(sAndFork.turnGetLongestName().isDefined()) then
				thisModule.createLabel()
			else
				OclUndefined
			endif;
	}
	to
		tAndFork: Urn!AndFork (
			id <- thisModule.nextId().toString(),
			name <- tAndFork.getName(sAndFork),
			label <- vLabel,
			diagram <- thisModule.tUCMmap
		)
}

rule AndJoin2AndJoin{
	from 	
		sAndJoin: Turn!AndJoin
	to
		tAndJoin: Urn!AndJoin(
			id <- thisModule.nextId().toString(),
			name <- sAndJoin.turnGetLongestName(),
			label <- tNodeLabel
		),
		tNodeLabel: Urn!NodeLabel
}

rule ComponentBinding2ComponentBinding{
	from
		sComponentBinding: Turn!ComponentBinding
	to
		tComponentBinding: Urn!ComponentBinding(
			pluginComponent <- thisModule.resolveTemp(sComponentBinding.componentIn, 'tComponentRef'),
			parentComponent <- thisModule.resolveTemp(sComponentBinding.componentOut, 'tComponentRef')
		)
}

rule ComponentRef2ComponentRef {
	from 
		sComponentRef: Turn!ComponentRef
	to
		tComponentRef: Urn!ComponentRef(
			id <- thisModule.nextId().toString(),
			name <- 'ComponentRef' + tComponentRef.id,
			label <- tComponentLabel,
			diagram <- sComponentRef.map,
			contDef <- thisModule.getOrCreateReferencedComponent(sComponentRef),
			parent <- sComponentRef.getBoundTo()
		),
		tComponentLabel: Urn!ComponentLabel
}

rule Concern2Concern{
	from 
		sConcern: Turn!Concern
	to 
		tConcern: Urn!Concern(
			id <- thisModule.nextId().toString(),
			name <- sConcern.turnGetLongestName(),
		 	elements <- sConcern.elements,
			condition <- sConcern.condition
		)
}

rule Condition2Condition{
	from 
		sCondition: Turn!Condition
	to 
		tCondition: Urn!Condition(
			expression <- sCondition.expression.asString(),
			label <- sCondition.expression.asString()
		)
	
}

rule Contribution2Contribution{
	from 
		sContribution: Turn!Contribution(sContribution.link.type.toString() <> 'belief')
	to 
		tContribution: Urn!Contribution(
			id <- thisModule.nextId().toString(),
			name <- sContribution.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(sContribution.dest, 'tIntentionalElement'),
			refs <- tLinkRef,
	 		correlation <- sContribution.correlation,
			contribution <- sContribution.getContributionType(),
			quantitativeContribution <- sContribution.getQuantitativeContribution()
		),
		tLinkRef: Urn!LinkRef(
			link <- tContribution,
			target <- thisModule.resolveTemp(sContribution.dest, 'tIntentionalElementRef')
		)
}

rule ContributionChange2ContributionChange{
	from
		sContributionChange: Turn!ContributionChange
	to
		tContributionChange: Urn!ContributionChange(
			contribution <- sContributionChange.contribution,
			newQuantitativeContribution <- sContributionChange.newQuantitativeContribution,
			newContribution <- sContributionChange.getNewContribution()
		)
}

rule ContributionContext2ContributionContext{
	from
		sContributionContext: Turn!ContributionContext
	to
		tContContext: Urn!ContributionContext(
			id <- thisModule.nextId().toString(),
			name <- sContributionContext.turnGetLongestName(),
			changes <- sContributionContext.changes,
			includedContexts <- sContributionContext.includedContexts
		)
}

rule ContributionContextGroup2ContributionContextGroup{
	from
		sContributionContextGroup: Turn!ContributionContextGroup
	to
		tContribGroups: Urn!ContributionContextGroup(
			id <- thisModule.nextId().toString(),
			name <- sContributionContextGroup.turnGetLongestName(),
			contribs <- sContributionContextGroup.contribs.including(sContributionContextGroup.contrib)
		)
}
	
rule Decomposition2Decomposition{
	from 
		sDecomposition: Turn!Decomposition(sDecomposition.link.type.toString() <> 'belief')
	to 
		tDecomposition: Urn!Decomposition(
			id <- thisModule.nextId().toString(),
			name <- sDecomposition.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(sDecomposition.dest, 'tIntentionalElement'),
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef(
			link <- tDecomposition,
			target <- thisModule.resolveTemp(sDecomposition.dest, 'tIntentionalElementRef')
		)
}

rule Dependency2Dependency{
	from 
		sDependency: Turn!Dependency(sDependency.link.type.toString() <> 'belief')
	to 
		tDependency: Urn!Dependency(
			id <- thisModule.nextId().toString(),
			name <- sDependency.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(sDependency.dest, 'tIntentionalElement'),
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef(
			link <- tDependency,
			target <- thisModule.resolveTemp(sDependency.dest, 'tIntentionalElementRef')
		)
}

rule Evaluation2Evaluation{
	from
		sEvaluation: Turn!Evaluation
 	to 
		tEvaluation: Urn!Evaluation(
		 	exceeds <- sEvaluation.exceeds,
		 	intElement <- thisModule.resolveTemp(sEvaluation.intElement, 'tIntentionalElement'),
			evaluation <- sEvaluation.evaluation,
			qualitativeEvaluation <- sEvaluation.qualitativeEvaluation.toString().capitalize(),
			kpiEvalValueSet <- thisModule.getOrCreateKPIEvalValueSet(sEvaluation.conversion)
		)
}

rule FailurePoint2FailurePoint{
	from		
		sFailurePoint: Turn!FailurePoint
	to
		tFailurePoint: Urn!FailurePoint (
			id <- thisModule.nextId().toString(),
			name <- sFailurePoint.turnGetLongestName(),
			succ <- tNodeConnection,
			label <- tNodeLabel,
			expression <- sFailurePoint.getFailExpression()
		),
		tNodeConnection: Urn!NodeConnection(
			condition <- sFailurePoint.condition
		),
		tNodeLabel: Urn!NodeLabel
}

rule IntentionalElement2Belief{
	from
		sIntentionalElement: Turn!IntentionalElement(sIntentionalElement.type.toString() = 'belief')
	to 
	 	tBelief: Urn!Belief(
	 		id <- thisModule.nextId().toString(),
	 		name <- sIntentionalElement.name,
			description <- sIntentionalElement.name,
			succ <- sIntentionalElement.linksSrc -> collect(sLink| thisModule.createBeliefLink(sLink))
	 	)
}

rule IntentionalElement2IntentionalElement{
	from 
		sIntentionalElement: Turn!IntentionalElement(sIntentionalElement.type.toString() <> 'belief')
	to 
		tIntentionalElementRef: Urn!IntentionalElementRef(
			id <- thisModule.nextId().toString(),
			name <- tIntentionalElementRef.getName(sIntentionalElement),
			def <- tIntentionalElement,
			succ <- sIntentionalElement.linksSrc -> collect(c|thisModule.resolveTemp(c, 'tLinkRef'))
		),
		tIntentionalElement: Urn!IntentionalElement(
			id <- thisModule.nextId().toString(),
			name <- sIntentionalElement.turnGetLongestName(),
			linksSrc <- sIntentionalElement.linksSrc,
			decompositionType <- sIntentionalElement.getDecompositionType(),
			type <- sIntentionalElement.getType(),
			importance <- sIntentionalElement.getImportance(),
			importanceQuantitative <- sIntentionalElement.importanceQuantitative,
			metadata <- tMetadata
		),
		tMetadata: Urn!Metadata(
 			name <- 'TURN-URN-NAME',
 			value <- sIntentionalElement.name 
		)
}

rule Metadata2Metadata{
	from 
		sMetadata: Turn!Metadata
	to 
		tMetadata: Urn!Metadata(
			name <- sMetadata.name
		)
}

rule OrFork2OrFork{
	from
		sOrFork: Turn!OrFork
	using{
		vLabel : Urn!Label =
			if(sOrFork.turnGetLongestName().isDefined()) then
				thisModule.createLabel()
			else
				OclUndefined
			endif;		
	}
	to
		tOrFork: Urn!OrFork(
			id <- thisModule.nextId().toString(),
			name <- tOrFork.getName(sOrFork),
			label <- vLabel,
			diagram <- thisModule.tUCMmap
		)
}

rule OrJoin2OrJoin{
	from 	
		sOrJoin: Turn!OrJoin
	to
		tOrJoin: Urn!OrJoin(
			id <- thisModule.nextId().toString(),
			name <- sOrJoin.turnGetLongestName(),
			label <- tNodeLabel
		),
		tNodeLabel: Urn!NodeLabel
}

rule PluginBinding2PluginBinding{
	from 
		sPluginBinding: Turn!PluginBinding	
	to
		tPluginBinding: Urn!PluginBinding(
			-- this could be other way round, binding could be inBinding or OutBinding and vice-versa.
			in <- sPluginBinding.getInBindings(),
			out <- sPluginBinding.getOutBindings(),
			components <- sPluginBinding.bindings -> collect(b|thisModule.resolveTemp(b,'tComponentBinding')),
			plugin <- thisModule.resolveTemp(sPluginBinding.map, 'tUCMmap'),
			precondition <- thisModule.resolveTemp(sPluginBinding.condition, 'tCondition'),
			replicationFactor <- sPluginBinding.replication
		)
}

rule QMapping2QMapping{
	from 
		sQualToQMapping: Turn!QualToQMapping
	to
		tQualitativeMapping: Urn!QualitativeMapping(
			realWorldLabel <- sQualToQMapping.realWorldLabel,
			exceeds	<- sQualToQMapping.exceeds,
			evaluation <- sQualToQMapping.evaluation,
			qualitativeEvaluation <- sQualToQMapping.qualitativeEvaluation.toString().capitalize()
		)
}

rule QMappings2QMappings{
	from
		sQualToQMappings: Turn!QualToQMappings
	to
		tQualitativeMappings: Urn!QualitativeMappings(
			id <- thisModule.nextId().toString(),
			name <- sQualToQMappings.turnGetLongestName(),
			mapping <- sQualToQMappings.mappings
		)
}

rule RespRef2Responsibility{
	from
		sRespRef: Turn!RespRef
	to
		tRespRef: Urn!RespRef(
			id <- thisModule.nextId().toString(),
			name <- 'RespRef' + tRespRef.id,
			label <- tNodeLabel,
			respDef <- thisModule.getOrCreateReferencedResponsibility(sRespRef)
		),
		tNodeLabel: Urn!NodeLabel
}

rule StartPoint2StartPoint{
	from
		sStartPoint: Turn!StartPoint
	to
		tStartPoint: Urn!StartPoint(
			id <- thisModule.nextId().toString(),
			name <- sStartPoint.turnGetLongestName(),
			label <- tNodeLabel,
			precondition <- thisModule.getOrCreateStartPointPrecondition(sStartPoint),
			failureKind <- sStartPoint.getFailKind()
		),
		tNodeLabel: Urn!NodeLabel
}

rule Strategies2Strategies{
	from
		sEvaluationStrategy: Turn!EvaluationStrategy
	to
		tEvaluationStrategy: Urn!EvaluationStrategy(
			id <- thisModule.nextId().toString(),
			name <- sEvaluationStrategy.turnGetLongestName(),
			evaluations <- sEvaluationStrategy.evaluations,
			includedStrategies <- sEvaluationStrategy.includedStrategies,
			author <- sEvaluationStrategy.getAuthor()
		)
}

rule StrategiesGroup2StrategiesGroup{
	from
		sStrategiesGroup: Turn!StrategiesGroup
	to
		tStrategiesGroup: Urn!StrategiesGroup(
			id <- thisModule.nextId().toString(),
			name <- sStrategiesGroup.turnGetLongestName(),
			strategies <- sStrategiesGroup.evalStrategies.including(sStrategiesGroup.evalStrategy)
		)
}

rule Stub2Stub{
	from
		sStub: Turn!Stub(not sStub.stubRef.isDefined())
	to
		tStub: Urn!Stub(
			id <- thisModule.nextId().toString(),
			name <- sStub.turnGetLongestName(),
			diagram <- thisModule.tUCMmap,
			label <- tNodeLabel,
			blocking <- sStub.isBlocking(),
			synchronization <- sStub.isSynchronizing(),
			dynamic <- sStub.isDynamic(),
			bindings <- sStub.params.plugin-> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'))
		),
		tNodeLabel: Urn!NodeLabel
}

rule StubDeclaration2Stub{
	from
		sStubDeclaration: Turn!StubDeclaration
	to
		tStub: Urn!Stub(id <- thisModule.nextId().toString(),
			name <- sStubDeclaration.turnGetLongestName(),
			label <- tNodeLabel,
			diagram <- thisModule.tUCMmap,
			bindings <- sStubDeclaration.params.plugin-> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'))
		),
		tNodeLabel: Urn!NodeLabel
}

rule Timer2Timer{
	from
		sTimer: Turn!Timer
	to
		tTimer: Urn!Timer(
			id <- thisModule.nextId().toString(),
			name <- sTimer.turnGetLongestName(),
			succ <- tNodeConnection,
			diagram <- thisModule.tUCMmap,
			label <- tNodeLabel,
			waitType <- sTimer.kind.toString().capitalize()
		),
		tNodeConnection: Urn!NodeConnection(
			condition <- sTimer.condition
		),
		tNodeLabel: Urn!NodeLabel
}

rule UCMmap2UCMmap{
	from
		sUCMmap: Turn!UCMmap
	to
		tUCMmap: Urn!UCMmap(
			id <- thisModule.nextId().toString(),
			name <- sUCMmap.turnGetLongestName(),
			contRefs <- sUCMmap.components -> collect(c|thisModule.resolveTemp(c, 'tComponentRef')),
			nodes <- sUCMmap.paths -> flatten() -> collect(p|p.startPoint) -> flatten() -> collect(p|thisModule.resolveTemp(p, 'tStartPoint')),
			connections <- sUCMmap.paths -> flatten() -> collect(p|p.startPoint) -> flatten() -> collect(p|thisModule.resolveTemp(p, 'tNodeConnection'))
		)
}

rule URNlink2URNlink{
	from 
		sURNlink: Turn!URNlink
	to 
		tURNlink: Urn!URNlink(
			type <- sURNlink.type,
			fromElem <- sURNlink.fromElem,
			toElem <- sURNlink.toElem
		)
}

rule WaitingPlace2WaitingPlace{
	from		
		sWaitingPlace: Turn!WaitingPlace
	to
		tWaitingPlace: Urn!WaitingPlace(
			id <- thisModule.nextId().toString(),
			name <- sWaitingPlace.turnGetLongestName(),
			succ <- tNodeConnection,
			label <- tNodeLabel,
			waitType <- sWaitingPlace.kind.toString().capitalize()
		),
		tNodeConnection: Urn!NodeConnection (
			condition <- sWaitingPlace.condition
		),
		tNodeLabel: Urn!NodeLabel
}

-------------------------------------------------------------------------------------------------------------------------------

----------------------3/3 STRICTLY ORDERED MATCHED RULES----------------------
-- These rules must maintain their order with respect to each other.
-- The order of InBinding2InBinding/OutBinding2OutBinding with respect
-- to each other does not matter, but they must be after URNspec2URNspec.
-- URNspec2URNspec must be after all the other matched rules in the
-- section above.
------------------------------------------------------------------------------


rule URNspec2URNspec{
	from 
		sURNspec: Turn!URNspec
	using{
		tComponentRef : Urn!ComponentRef = OclUndefined;		
	}
	to
		tURNspec: Urn!URNspec(
			name <- sURNspec.name,
			metadata <- sURNspec.metadata,
			grlspec <- tGRLspec,
			ucmspec <- tUCMspec,
			urnLinks <- sURNspec.urnlinks,
			urndef <- tURNdef
		),
		tURNdef: Urn!URNdefinition(
			specDiagrams <- tGRLSpecDiag,
			concerns <- sURNspec.concerns,
			components <- Urn!Component.allInstances(),
			responsibilities <- Urn!Responsibility.allInstances()
		),
		tGRLspec: Urn!GRLspec(
			actors <- sURNspec.actors,
			intElements <- sURNspec.getTargetIntentionalElements(),
			groups <- sURNspec.stratGroups,
			strategies <- sURNspec.strategies,
			contributionGroups <- sURNspec.contribContextGroups,
			contributionContexts <- sURNspec.contribContexts,
			KPIConversion <- sURNspec.indConversions -> select(c|c.oclIsTypeOf(Turn!QualToQMappings)),
			links <- sURNspec.getTargetLinks()
		),
		tGRLSpecDiag: Urn!GRLGraph(
			id <- thisModule.nextId().toString(),
		 	nodes <- sURNspec.getTargetIntentionalElementRefs().union(sURNspec.getTargetBeliefs()),
			contRefs <- sURNspec.actors -> collect(a|thisModule.resolveTemp(a, 'tActorRef')),
			connections <- sURNspec.getTargetLinkRefs().union(sURNspec.getTargetBeliefs() -> collect(b|b.succ))
		),
		tUCMspec: Urn!UCMspec
	do{
		if(sURNspec.info.isDefined()){
			tURNspec.description <- sURNspec.info.description;
			tURNspec.author <- sURNspec.info.author;
			tURNspec.created <- sURNspec.info.created;
			tURNspec.modified <- sURNspec.info.modified;
			tURNspec.specVersion <- sURNspec.info.specVersion;
			tURNspec.urnVersion <- sURNspec.info.urnVersion; 
		}
		
		if(sURNspec.metadata -> any(m|m.name='TURN-URN-nextGlobalID').isDefined()){
	 		thisModule.id <- sURNspec.metadata -> any(m|m.name='TURN-URN-nextGlobalID').value.toInteger();
		}
		
		-- Connect all UCMmap nodes
		for(sUCMmap in sURNspec.ucmMaps){
			thisModule.tUCMmap <- thisModule.resolveTemp(sUCMmap, 'tUCMmap');
			tURNdef.specDiagrams <- tURNdef.specDiagrams.including(thisModule.tUCMmap);
			thisModule.connectUCMmap(thisModule.tUCMmap, sUCMmap.paths);
		}
		
		-- Handle component refs once UCMmap nodes are connected
		for(sComponentRef in sURNspec.ucmMaps -> collect(sUCMmap|sUCMmap.components) -> flatten()){
			tComponentRef <- thisModule.resolveTemp(sComponentRef, 'tComponentRef');
			
			tComponentRef.contDef.kind <- sComponentRef.getKind();
			tComponentRef.contDef.protected <- sComponentRef.protected;

			thisModule.tUCMmap <- tComponentRef.diagram;
			
			for(sLongBoundElement in (sComponentRef.elements.including(sComponentRef.element)) -> select(e|e.oclIsTypeOf(Turn!LongBoundElement))){
				thisModule.addLongBoundElementNodesToComponentRef(sLongBoundElement, tComponentRef);
			}
	
			for(sBoundElement in (sComponentRef.elements.including(sComponentRef.element)) -> select(e|e.oclIsTypeOf(Turn!BoundElement))){
				thisModule.addBoundElementNodeToComponentRef(sBoundElement, tComponentRef);
			}
		}
		
		tURNspec.nextGlobalID <- thisModule.id.toString();
	}
}

rule InBinding2InBinding{
	from
		sInBinding: Turn!InBinding
	to
		tInBinding: Urn!InBinding(
			startPoint <- thisModule.resolveTemp(sInBinding.mapStart, 'tStartPoint'),
			stubEntry <- sInBinding.getStub().pred -> at(sInBinding.index)
		)
}

rule OutBinding2OutBinding{
	from
		sOutBinding: Turn!OutBinding
	to
		tOutBinding: Urn!OutBinding(
			endPoint <- thisModule.getTargetNode(sOutBinding.mapEnd),
			stubExit <- sOutBinding.getStub().succ -> at(sOutBinding.index)
		)
}