module Turn2Urn;
-- paths to metamodels for content assist
--@path Turn=/ATLProject/Metamodels/Turn.ecore
--@path Urn=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

create OUT : Urn from IN : Turn;

--This helper initializes the value of id
-- CONTEXT: thisModule
-- RETURN: Integer

uses ConnectNodes;

helper def: id : Integer = 0;

-- This helper creates an increment method for id
-- CONTEXT: Integer
-- RETURN: Integer
helper context Integer def : inc() : Integer = self + 1;

-- This helper checks if metadata already exists for a given parameter
-- CONTEXT: Turn!URNmodelElement
-- RETURN: Boolean
helper context Turn!URNmodelElement def: metadataExists(param : String) : Boolean = 
	self.metadata -> select(m| m.name.indexOf(param) <> -1 ) -> notEmpty();

helper def: nodeCollector : Sequence(OclAny) = Sequence(OclAny) ;

helper def: counter : Integer = 1;

helper def: nodeCounter : Integer = 1;

helper def: orForkMap : Map(Turn!OrFork, Urn!OrFork) = Map{};

helper def: connectMap : Map(Turn!Connect, Urn!Connect) = Map{};

helper def: orForkNodeConnCounter : Integer = 1;

helper def: andForkMap : Map(Turn!OrFork, Urn!OrFork) = Map{};

helper def: endPointMap : Map(Turn!EndPoint, Urn!EndPoint) = Map{};

helper def: timerMap : Map(Turn!Timer, Urn!Timer) = Map{};

helper def: stubMap : Map(Turn!Stub, Urn!Stub) = Map{};

helper def: andForkNodeConnCounter : Integer = 1;

helper context Turn!URNspec def: getActorElements() : Sequence(OclAny) = 
	self.actors -> collect(actor|actor.elems) -> flatten();

-- imperative-method-like rules below
-- (sorry, spirit of declarative programming)

-- method used to initialize an object and assign it a unique id
rule initNextObject(obj: OclAny){
	do{
		thisModule.id <- thisModule.id.inc();
		obj.id <- thisModule.id.toString();
		obj;
	}
}

-- method used to initialize an object and assign it a unique id
-- and then to prepend a 'name' to this id
rule initNextObjectWithName(obj: OclAny, name: String){
	do{
		thisModule.initNextObject(obj);
		obj.name <- name+obj.id;
		obj;
	}
}

rule initObjectNameFromObject(targetObject: OclAny, sourceObject: OclAny){
	do{
		-- personal TODO: determine why this is "s.longname.longname" rather than merely "s.longname"
		-- note: ATL does not support short-circuit evalaution of conditions so this had to be implemented in an ugly manner

		--may need to split this into two methods if there is no way to test if a property exists in some model element beforehand.
		--alternative is to hard code in the list of methods that should go directly to the "else"
		if(not sourceObject.longname.oclIsUndefined() and not sourceObject.longname.oclIsTypeOf(String)){
			if(not sourceObject.longname.longname.oclIsUndefined()){
				targetObject.name <- sourceObject.longname.longname;
			}
			else{
				targetObject.name <- sourceObject.name;	
			}
		}
		else{
			targetObject.name <- sourceObject.name;	
		}
	}
}

-- called rules below

rule createMetadata(name: String, value: String) {
	to 
     targetMetadata: Urn!Metadata(
     	name <- name,
     	value <- value    
     )
	do{
	 	targetMetadata;
	}
}

rule createNodeConns(){
	to
	 	targetNodeConn: Urn!NodeConnection
	do{
		targetNodeConn;	
	}		
}

rule createComponent(s: Turn!ComponentRef){
	to
		tComp: Urn!Component
	do{
		thisModule.initNextObject(tComp);
		thisModule.initObjectNameFromObject(tComp, s);
		tComp;	
	}
}

rule createKpiEvalValueSet(s: Turn!LinearConversion) {
	to
		tkpiEvalValueSet: Urn! KPIEvalValueSet(
			unit <- s.unit,
			targetValue <- s.targetValue,
			thresholdValue <- s.thresholdValue,
			worstValue <- s.worstValue
		)
	do{ 
		tkpiEvalValueSet;
	}
}

rule createQMapKpiEvalValueSet(conv: Turn!QualToQMappings){
	to		
		tkpiEvalValueSet: Urn!KPIEvalValueSet(
			kpiConv <- conv	
		)
	do{ 
		tkpiEvalValueSet;
	}
}

rule createOrJoin(tUCMmap: Urn!UCMmap){
	to
		tOrJoin: Urn!OrJoin(
			succ <- tConn,
			diagram <- tUCMmap
		),
		tConn: Urn!NodeConnection
	do{
		thisModule.initNextObjectWithName(tOrJoin, 'OrJoin');
		tOrJoin;
	}
}

rule createAndJoin(tUCMmap: Urn!UCMmap){
	to
		tAndJoin: Urn!AndJoin(
			succ <- tConn,
			diagram <- tUCMmap
		),
		tConn: Urn!NodeConnection
	do{
		thisModule.initNextObjectWithName(tAndJoin, 'AndJoin');
		tAndJoin;
	}
}

rule createConnect(tUCMmap: Urn!UCMmap){
	to
		tConnect: Urn!Connect(
			succ <- tConn,
			diagram <- tUCMmap
		),
		tConn: Urn!NodeConnection
	do{
		thisModule.initNextObjectWithName(tConnect, 'Connect');
		tConnect;	
	}
}

rule createCondition(sourceExpression: String){
	to
	 	targetCondition: Urn!Condition(
	 		expression <- sourceExpression,
			label <- sourceExpression
	 	)
	do{
		targetCondition;
	}		
}

rule createOrForkNodeConns(ref: Turn!RegularOrFork,  tUCMmap: Urn!UCMmap){
	to
	 	targetNodeConn: Urn!NodeConnection
	do{
		if(ref <> OclAny){
			targetNodeConn.condition <- thisModule.resolveTemp(ref.condition,'tCondition');
		}
		targetNodeConn;	
	}	
}

rule createAndForkNodeConns(ref: Turn!PathBodyNodes,  tUCMmap: Urn!UCMmap){
	to
	 	targetNodeConn: Urn!NodeConnection
	do{
		targetNodeConn;	
	}	
}

rule createResponsibility(s: Turn!RespRef){
	to
		tResp: Urn!Responsibility()
	do{
		thisModule.initObjectNameFromObject(tResp, s);
		thisModule.initNextObject(tResp);
		tResp;
	}
}

rule createLabel(){
	to
		tNodeLabel: Urn!NodeLabel(
		)
	do{
		tNodeLabel;
	}
}

--regular rules

rule addMetadata(value: String) {
   to 
     t : Urn!Metadata (
     	name <- 'TURN-URN-NAME',
     	value <- value    
     )
	 do{
	 	t; 
	}
}

rule URNspec2URNspec{
	from 
		sURNspec: Turn!URNspec
	to
		tURNspec: Urn!URNspec(
			name <- sURNspec.name,
			metadata <- sURNspec.metadata,
			grlspec <- tGRLSpec,
			ucmspec <- tUcmspec,
			urnLinks <- sURNspec.urnlinks,
			urndef <- tURNdef
		),
		tURNdef: Urn!URNdefinition(
			specDiagrams <- tGRLSpecDiag,
			specDiagrams <- sURNspec.ucmMaps -> collect(m|thisModule.resolveTemp(m,'tUCMmap')),
			concerns <- sURNspec.concerns
		),
		tGRLSpec: Urn!GRLspec(
			actors <- sURNspec.actors,
			intElements <- sURNspec.getActorElements() -> select(e|e.type.toString() <> 'belief'),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tCont')),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tDecomp')),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tDep')),
			groups <- sURNspec.stratGroups,
			strategies <- sURNspec.strategies,
			contributionGroups <- sURNspec.contribContextGroups,
			contributionContexts <- sURNspec.contribContexts,
			KPIConversion <- sURNspec.indConversions -> select(c|c.oclIsTypeOf(Turn!QualToQMappings))
		),
		tGRLSpecDiag: Urn!GRLGraph(
		  	nodes <- sURNspec.getActorElements() -> collect(e| thisModule.resolveTemp(e, 'tIntElemRef')),
			nodes <- Urn!Belief.allInstances(),
			contRefs <- sURNspec.actors -> collect(a| thisModule.resolveTemp(a, 'tActorRef')),
		    connections <- sURNspec.getActorElements() ->  collect(l|l.linksSrc) -> flatten() -> collect(m| thisModule.resolveTemp(m,'tLinkRef')),  
	    	connections <- sURNspec.getActorElements() ->  collect(m| thisModule.resolveTemp(m,'tBeliefLink')) 
		),
		tUcmspec: Urn!UCMspec
	do{
		if(sURNspec.metadata -> select(m| m.name.indexOf('TURN-URN') <> -1 ) -> notEmpty()){
	 		if (sURNspec.metadata -> select(m|m.name.indexOf('nextGlobalID') <> -1 ) -> notEmpty())
	 			thisModule.id <- sURNspec.metadata -> any(m|m.name = 'TURN-URN-nextGlobalID').value.toInteger();
		}
		
		tURNdef.components <- Urn!Component.allInstances();
		tURNdef.responsibilities <- Urn!Responsibility.allInstances();
		
		if (not sURNspec.info.oclIsUndefined()){
			tURNspec.description <- sURNspec.info.description;
			tURNspec.author <- sURNspec.info.author;
			tURNspec.created <- sURNspec.info.created;
			tURNspec.modified <- sURNspec.info.modified;
			tURNspec.specVersion <- sURNspec.info.specVersion;
			tURNspec.urnVersion <- sURNspec.info.urnVersion; 
		}
		
		tURNspec.nextGlobalID <- thisModule.id.toString();
	}
}

rule Metadata2Metadata{
	from 
		sourceMetadata: Turn!Metadata
	to 
		targetMetadata: Urn!Metadata(
			name <- sourceMetadata.name
		)
}

rule Belief2Belief {
	from
		s: Turn!IntentionalElement(
			s.type.toString() = 'belief'
		)
    to 
     	tBelief: Urn!Belief(
     		name <- s.name,
			description <- s.name,
			succ <- tBeliefLink
     	),
		tBeliefLink: Urn!BeliefLink(
			target <- s.linksSrc -> collect(l|l.dest) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tIntElemRef')) -> first()
		)
	 do{
	 	thisModule.initNextObject(tBelief);
	 	tBelief;
	 }
}

rule Actor2Actor{
	from 
		s: Turn!Actor
	to 
		tActor: Urn!Actor (
			importanceQuantitative <- s.importanceQuantitative
		),
		tActorRef: Urn!ActorRef (
			contDef <- tActor,
			nodes <- s.elems -> collect(e|thisModule.resolveTemp(e,'tIntElemRef')),
			nodes <- s.elems -> collect(e|thisModule.resolveTemp(e,'tBelief')),
			label <- tCompLabel
		),
		tCompLabel: Urn!ComponentLabel()
	 do{
	 	thisModule.initNextObject(tActor);
	 	thisModule.initObjectNameFromObject(tActor, s);
	 	
	 	thisModule.initNextObjectWithName(tActorRef, 'ActorRef');
	 }	
}

rule Decomposition2Decomposition{
	from 
		s: Turn!Decomposition (not (s.link.type.toString() = 'belief'))
	to 
		tDecomp: Urn!Decomposition (
		    dest <- s.dest,
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef (
			link <- tDecomp,
			target <- thisModule.resolveTemp(s.dest,'tIntElemRef')
		)
	do{
		thisModule.initNextObject(tDecomp);
		thisModule.initObjectNameFromObject(tDecomp, s);
	}
}

rule Dependency2Dependency{
	from 
		s: Turn!Dependency (not (s.link.type.toString() = 'belief'))
	to 
		tDep: Urn!Dependency (
		    dest <- s.dest,
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef (
			link <- tDep,
			target <- thisModule.resolveTemp(s.dest,'tIntElemRef')
		)
	do{
		thisModule.initNextObject(tDep);
		thisModule.initObjectNameFromObject(tDep, s);
	}
}

rule Strategies2Strategies{
	from
		s: Turn!EvaluationStrategy
	to
		tStrategies: Urn!EvaluationStrategy (
			author <- s.info.author,
			evaluations <- s.evaluations,
			includedStrategies <- s.includedStrategies
		)
	do{
		thisModule.initNextObject(tStrategies);
		thisModule.initObjectNameFromObject(tStrategies, s);
	}
}

rule ContributionContext2ContributionContext{
	from
		s: Turn!ContributionContext
	to
		tContContext: Urn!ContributionContext (
			changes <- s.changes,
			includedContexts <- s.includedContexts
		)
	do{
		thisModule.initNextObject(tContContext);
		thisModule.initObjectNameFromObject(tContContext, s);
	}
}

rule ContributionContextGroup2ContributionContextGroup{
	from
		s: Turn!ContributionContextGroup
	to
		tContribGroups: Urn!ContributionContextGroup (
			contribs <- s.contrib,
			contribs <- s.contribs
		)
	do{
		thisModule.initNextObject(tContribGroups);
		thisModule.initObjectNameFromObject(tContribGroups, s);
	}
}

rule QMappings2QMappings {
	from
		s: Turn!QualToQMappings
	to
		tQMappings: Urn!QualitativeMappings (
			mapping <- s.mappings
			--kpiEvalValueSet <- tQMapkpiEvalValueSet
		)
		
	do{
		thisModule.initNextObject(tQMappings);
		thisModule.initObjectNameFromObject(tQMappings, s);
	}
}

rule Concern2Concern{
	from 
		s: Turn!Concern
	to 
		tConcern: Urn!Concern (
		    elements <- s.elements,
			condition <- s.condition,
			metadata <- s.metadata
		)
	do{
		thisModule.initNextObject(tConcern);
		thisModule.initObjectNameFromObject(tConcern, s);
	}
}

rule WaitingPlace2WaitingPlace{
	from		
		s: Turn!WaitingPlace
	to
		tWtPlace: Urn!WaitingPlace (
			succ <- tNodeConn,
			label <- tNodeLabel,
			waitType <- s.kind.toString().substring(1,1).toUpper()+s.kind.toString().substring(2,s.kind.toString().size())
		),
		tNodeConn: Urn!NodeConnection (
			condition <- s.condition
		),
		tNodeLabel: Urn!NodeLabel()
	do{
		thisModule.initNextObject(tWtPlace);
		thisModule.initObjectNameFromObject(tWtPlace, s);
	}
}

rule FailurePoint2FailurePoint{
	from		
		s: Turn!FailurePoint
	to
		tFailPt: Urn!FailurePoint (
			succ <- tNodeConn,
			label <- tNodeLabel
		),
		tNodeConn: Urn!NodeConnection (
			condition <- s.condition
		),
		tNodeLabel: Urn!NodeLabel()
	do{
		thisModule.initNextObject(tFailPt);
		thisModule.initObjectNameFromObject(tFailPt, s);

		if(not s.failLabel.oclIsUndefined())
			tFailPt.expression <- s.failLabel.failure;
	}
}

rule StartPoint2StartPoint{
	from
		s: Turn!StartPoint
	to
		tStartPoint: Urn!StartPoint (
			succ <- tNodeConn,
			label <- tNodeLabel,
			diagram <- s.path.map,
			precondition <- s.precondition
		),
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel
	do{
		thisModule.initNext(tStartPoint);
		thisModule.initObjectNameFromObject(tStartPoint, s);
		
		if(not s.boundTo.oclIsUndefined()){
				if (not s.boundTo.comp.oclIsUndefined()){
					tStartPoint.contRef <-  thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
				}
				else{
					tStartPoint.contRef <-  thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
				}
		}
		
		if(not s.failKind.oclIsUndefined()){
			tStartPoint.failureKind <- s.failKind.toString().substring(1,1).toUpper()+s.failKind.toString().substring(2,s.failKind.toString().size());
		}
	}
}

rule AndJoin2AndJoin{
	from 	
		s: Turn!AndJoin
	to
		tAndJoin: Urn!AndJoin(
			succ <- tNodeConn,
			label <- tNodeLabel
		),
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel
	do{
		thisModule.initNextObject(tAndJoin);
		thisModule.initObjectNameFromObject(tAndJoin, s);
		
		if(not s.boundTo.oclIsUndefined()){
				if(not s.boundTo.comp.oclIsUndefined())
					tAndJoin.contRef <-  thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
				else
					tAndJoin.contRef <- thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
		}
	}
}

rule OrJoin2OrJoin{
	from 	
		s: Turn!OrJoin
	to
		tOrJoin: Urn!OrJoin(
			succ <- tNodeConn,
			label <- tNodeLabel
		),
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel
	do{
		thisModule.initNextObject(s);
		thisModule.initObjectNameFromObject(tOrJoin, s);
		
		if(not s.boundTo.oclIsUndefined()){
				if(not s.boundTo.comp.oclIsUndefined())
					tOrJoin.contRef <-  thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
				else
					tOrJoin.contRef <-  thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
		}
		
	}
}

rule InBinding2InBinding{
	from
		s:Turn!InBinding
	to
		tInBinding: Urn!InBinding(
			startPoint <- thisModule.resolveTemp(s.mapStart,'tStartPoint')
		)
	do{
		if(not s.binding.oclIsUndefined()){
			if(not s.binding.stubParam.stubDec.oclIsUndefined())
				tInBinding.stubEntry <- thisModule.stubMap.get(s.binding.stubParam.stubDec.stub).pred -> at(s.index);
			else
				tInBinding.stubEntry <- thisModule.stubMap.get(s.binding.stubParam.stub).pred -> at(s.index);
		}
		else if(not s.bindings.oclIsUndefined()){
			if(not s.bindings.stubParam.stubDec.oclIsUndefined())
				tInBinding.stubEntry <- thisModule.stubMap.get(s.bindings.stubParam.stubDec.stub).pred -> at(s.index);
			else
				tInBinding.stubEntry <- thisModule.stubMap.get(s.bindings.stubParam.stub).pred -> at(s.index);	
		}
	}
}

rule OutBinding2OutBinding{
	from
		s:Turn!OutBinding
	to
		tOutBinding: Urn!OutBinding(
			endPoint <- thisModule.endPointMap.get(s.mapEnd)
		)
	do{ 
		if(not s.bindings.oclIsUndefined()){
			if(not s.bindings.stubParam.stubDec.oclIsUndefined())
				tOutBinding.stubExit <- thisModule.stubMap.get(s.bindings.stubParam.stubDec.stub).pred -> at(s.index);
			else
				tOutBinding.stubExit <- thisModule.stubMap.get(s.bindings.stubParam.stub).succ -> at(s.index);
		}
		else if(not s.binding.oclIsUndefined()){
			if(not s.binding.stubParam.stubDec.oclIsUndefined())
				tOutBinding.stubExit <- thisModule.stubMap.get(s.binding.stubParam.stubDec.stub).pred -> at(s.index);
			else 
				tOutBinding.stubExit <- thisModule.stubMap.get(s.binding.stubParam.stub).succ -> at(s.index);	
		}
	}
}

rule IntElements2IntElements{
	from 
		s: Turn!IntentionalElement (s.type.toString() <> 'belief')
	to 
		tIntElem: Urn!IntentionalElement (
		   linksSrc <- s.linksSrc
		),
		tIntElemRef: Urn!IntentionalElementRef (
			def <- tIntElem,
			succ <- s.linksSrc -> collect(c|thisModule.resolveTemp(c,'tLinkRef'))
			
		)
	 do{
		 thisModule.initNextObjectWithName(tIntElemRef, 'IntentionalElementRef');
		 thisModule.initObjectNameFromObject(tIntElemRef, s); 
		 --TODO: determine if this is redundant - we init with name then set the name
		 
		 if(Turn!Decomposition -> allInstances() -> select(d|d.dest=s) -> size() > 0)
		 	tIntElem.decompositionType <-Turn!Decomposition -> allInstances() -> select(d|d.dest=s) -> collect(a|a.decompositionType.toString().substring(1,1).toUpper()+a.decompositionType.toString().substring(2,a.decompositionType.toString().size()))-> first();
		 
		 tIntElem.type <- s.type.toString().substring(1,1).toUpper()+s.type.toString().substring(2,s.type.toString().size());
		 
		 --Added because the default value in enum is considered always.
		if(s.importance.toString().equals('none'))
			tIntElem.importanceQuantitative <- s.importanceQuantitative;
		else
			tIntElem.importance <- s.importance.toString().substring(1,1).toUpper()+s.importance.toString().substring(2,s.importance.toString().size());
	 	 	thisModule.initNextObject(tIntElem);
		 	thisModule.initObjectNameFromObject(tIntElem, s);	
		 	tIntElem.metadata <- thisModule.createMetadata('TURN-URN-NAME', s.name);
	}
}

rule Contribution2Contribution{
	from 
		s: Turn!Contribution (not (s.link.type.toString() = 'belief'))
	to 
		tCont: Urn!Contribution (
		    dest <- s.dest,
			refs <- tLinkRef,
	        correlation <- s.correlation
		),
		tLinkRef: Urn!LinkRef (
			link <- tCont,
			target <- thisModule.resolveTemp(s.dest,'tIntElemRef')
		)
		do{
			thisModule.initNextObject(tCont);
			thisModule.initObjectNameFromObject(tCont, s);
	
			--Added because the default value in enum is considered always.
			if(s.contribution.toString().equals('undefined')){
				tCont.quantitativeContribution <- s.quantitativeContribution;
				if(s.quantitativeContribution <= -1)
					tCont.contribution <- 'Hurt';
				else if(s.quantitativeContribution < -49)
					tCont.contribution <- 'SomeNegative';
				else if(s.quantitativeContribution = -100)
					tCont.contribution <- 'Break';
				else if(s.quantitativeContribution = 0)
					tCont.contribution <- 'Unknown';
				else if(s.quantitativeContribution < 50)
					tCont.contribution <- 'Help';
				else if (s.quantitativeContribution <= 99)
					tCont.contribution <- 'SomePositive';
				else if (s.quantitativeContribution = 100)
					tCont.contribution <- 'Make';
			}
			else
				tCont.contribution <- s.contribution.toString().substring(1,1).toUpper()+s.contribution.toString().substring(2,s.contribution.toString().size());
	}
}

rule Evaluation2Evaluation {
	from
		s: Turn!Evaluation
   	to 
	    tEval : Urn!Evaluation (
	     	exceeds <- s.exceeds,
	     	intElement <- s.intElement,
			evaluation <- s.evaluation,
			qualitativeEvaluation <- s.qualitativeEvaluation.toString().substring(1,1).toUpper()+s.qualitativeEvaluation.toString().substring(2,s.qualitativeEvaluation.toString().size())
	    )
	do	{
		if(not s.conversion.oclIsUndefined()){
			if(s.conversion.oclIsTypeOf(Turn!QualToQMappings))
				tEval.kpiEvalValueSet <- thisModule.createQMapKpiEvalValueSet(s.conversion);
			else{
				tEval.kpiEvalValueSet <- thisModule.createKpiEvalValueSet(s.conversion);}
		}
	}
}

rule ContributionChange2ContributionChange{
	from
		s: Turn!ContributionChange
	to
		t: Urn!ContributionChange (
			contribution <- s.contribution,
			newQuantitativeContribution <- s.newQuantitativeContribution
		)
	do{
		if(not s.newContribution.toString().equals('undefined'))
			t.newContribution <- s.newContribution.toString().substring(1,1).toUpper()+s.newContribution.toString().substring(2,s.newContribution.toString().size());
	}
}

rule QMapping2QMapping {
	from 
		s: Turn!QualToQMapping
	to
		tQMapping: Urn!QualitativeMapping (
			realWorldLabel <- s.realWorldLabel,
			exceeds	<- s.exceeds,
			evaluation <- s.evaluation,
			qualitativeEvaluation <- s.qualitativeEvaluation.toString().substring(1,1).toUpper()+s.qualitativeEvaluation.toString().substring(2,s.qualitativeEvaluation.toString().size())
		)
}

rule URNlink2URNlink{
	from 
		s: Turn!URNlink
	to 
		tCon: Urn!URNlink (
			type <- s.type,
		    fromElem <- s.fromElem,
			toElem <- s.toElem
		)
}

rule Condition2Condition{
	from 
		s: Turn!Condition
	to 
		tCondition: Urn!Condition
	do{
		thisModule.condExpression <- '';
		for(exp in s.expression.content){
			thisModule.condExpression <- thisModule.condExpression + exp;	
		}
		tCondition.expression <- thisModule.condExpression; 
	}
}

rule StrategiesGroup2StrategiesGroup{
	from
		s: Turn!StrategiesGroup
	to
		tStrategiesGroup: Urn!StrategiesGroup (
			strategies <- s.evalStrategy,
			strategies <- s.evalStrategies
		)
	do{
		thisModule.initNextObject(tStrategiesGroup);
		thisModule.initObjectNameFromObject(tStrategiesGroup, s);
	}
}

rule Component2Component{
	from 
		s:Turn!ComponentRef 
	to
		tCompRef: Urn!ComponentRef(
			label <- tCompLabel,
			diagram <- s.map
		),
		tCompLabel: Urn!ComponentLabel
	do{
		thisModule.initNextObjectWithName(tCompRef, 'ComponentRef');
		
		if(Urn!Component.allInstances() -> any(c|c.name = s.name).oclIsUndefined()){
			thisModule.comp <- thisModule.createComponent(s);
			tCompRef.contDef <- thisModule.comp;	
		}
		else 
			tCompRef.contDef <- Urn!Component.allInstances() -> any(c|c.name = s.name);	

		if(not s.kind.oclIsUndefined() and s.kind.toString() <> 'parent')
			tCompRef.contDef.kind <- s.kind.toString().substring(1,1).toUpper()+s.kind.toString().substring(2,s.kind.toString().size());
		else if(s.kind <> 'parent')
			tCompRef.contDef.kind <- 'Team';
		
		tCompRef.contDef.protected <- s.protected;
		if(not s.boundTo.oclIsUndefined()){
				if(not s.boundTo.comp.oclIsUndefined())
					tCompRef.parent <-  thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
				else
					tCompRef.parent <-  thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
		}
		
		if(s.element.oclIsTypeOf(Turn!LongBoundElement)){
			tCompRef.metadata <- thisModule.createMetadata('from',s.element.from);
			tCompRef.metadata <- thisModule.createMetadata('to',s.element.to);
		}
		if(s.elements -> size() <> 0){
			for(elem in s.elements){
				if(elem.oclIsTypeOf(Turn!LongBoundElement)){
					tCompRef.metadata <- thisModule.createMetadata('from',elem.from);
					tCompRef.metadata <- thisModule.createMetadata('to',elem.to);
				}
			}
		}
	}
}

rule Responsibility2Responsibility{
	from
		s: Turn!RespRef 
	to
		tRespRef: Urn!RespRef (
			succ <- tNodeConn,
			label <- tNodeLabel
		),
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel
	do{
		
		if(not s.longName.longname.oclIsUndefined())
			thisModule.respName <- s.longName.longname;
		else
			thisModule.respName <- s.name;
		
		if(Urn!Responsibility.allInstances() -> any(r|r.name = thisModule.respName).oclIsUndefined()){
			thisModule.resp <- thisModule.createResponsibility(s);
			tRespRef.respDef <- thisModule.resp;
		}
		else{
			tRespRef.respDef  <- Urn!Responsibility.allInstances() -> any(r|r.name = thisModule.respName);
		}
		
		--component bindings added
		if (not s.boundTo.oclIsUndefined()){
				if (not s.boundTo.comp.oclIsUndefined())
					tRespRef.contRef <- thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
				else
					tRespRef.contRef <- thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
		}
		
		thisModule.initNextObjectWithName(tRespRef);
	}
}

--Remaining rules: (found in Turn2UrnTemporarilyRemovedCode.txt)

--rule createOrFork(obj:Turn!OrFork, tUCMmap: Urn!UCMmap)
--rule connectOrForkEndPoints(obj: Turn!OrFork, nextNode: Urn!PathNode, tUCMmap: Urn!UCMmap, expression: String)
--rule createAndFork(obj:Turn!AndFork, tUCMmap: Urn!UCMmap)
--rule createStub(stubObj:Turn!Stub, tUCMmap: Urn!UCMmap)
--rule createEndPoint(ep: Turn!EndPoint, tUCMmap: Urn!UCMmap)
--rule backLinksToOrFork(ep: Turn!EndPoint, tEndPoint: Urn!EndPoint)
--rule OrJoin2OrJoin
--rule connectOrForkNodes(pathend : Turn!PathEnd, tUCMmap: Urn!UCMmap)
--rule connectAndForkNodes(pathend : Turn!PathEnd, tUCMmap: Urn!UCMmap)
--rule createEmptyPt(tUCMmap: Urn!UCMmap, node: Turn!PathBodyNode, asynch: Boolean)
--rule connectTimerNodes(timerObj:Turn!Timer, tUCMmap:Urn!UCMmap)
--rule createStubOutNodes(stubObj:Turn!Stub, tUCMmap:Urn!UCMmap)
--rule PluginBinding2PluginBinding