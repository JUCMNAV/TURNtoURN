module Turn2Urn;
-- paths to metamodels for content assist
--@path Turn=/ATLProject/Metamodels/Turn.ecore
--@path Urn=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

create OUT : Urn from IN : Turn;

--This helper initializes the value of id
-- CONTEXT: thisModule
-- RETURN: Integer

uses ConnectNodes;

----------------------helper variables-------------------------------

helper def: id : Integer = 0;

helper def: nodeCollector : Sequence(OclAny) = Sequence(OclAny) ;

helper def: counter : Integer = 1;

helper def: nodeCounter : Integer = 1;

helper def: orForkMap : Map(Turn!OrFork, Urn!OrFork) = Map{};

helper def: connectMap : Map(Turn!Connect, Urn!Connect) = Map{};

helper def: orForkNodeConnCounter : Integer = 1;

helper def: andForkMap : Map(Turn!OrFork, Urn!OrFork) = Map{};

helper def: endPointMap : Map(Turn!EndPoint, Urn!EndPoint) = Map{};

helper def: timerMap : Map(Turn!Timer, Urn!Timer) = Map{};

helper def: stubMap : Map(Turn!Stub, Urn!Stub) = Map{};

helper def: andForkNodeConnCounter : Integer = 1;

---------------helper methods-------------------------------------------

-- This helper creates an increment method for id
-- CONTEXT: Integer
-- RETURN: Integer
helper context Integer def : inc() : Integer = self + 1;

-- This helper checks if metadata already exists for a given parameter
-- CONTEXT: Turn!URNmodelElement
-- RETURN: Boolean
helper context Turn!URNmodelElement def: metadataExists(param : String) : Boolean = 
	self.metadata -> select(m| m.name.indexOf(param) <> -1 ) -> notEmpty();

helper context Turn!URNspec def: getActorElements() : Sequence(OclAny) = 
	self.actors -> collect(actor|actor.elems) -> flatten();

helper context Turn!UCMmap def: getPathNodes() : Sequence(OclAny) =
	self.paths -> flatten() -> collect(p|p.pathBody) -> flatten() -> collect(pb|pb.pathNodes) -> flatten();

helper context String def : capitalize(): String = self.substring(1,1).toUpper() + self.substring(2, self.size());

--This should only be called on TURN objects; I haven't been able to determine how to express that restriction using OCL, though.
helper context OclAny def : turnGetLongestName() : String = 
	if(not self.longName.oclIsUndefined())
	then
		if(not self.longName.longname.oclIsUndefined())
		then
			self.longName.longname
		else
			self.name	
		endif
	else
			self.name	
	endif;

helper context Turn!OrFork def : getPathBodies() : Turn!PathBody =
	self.body.regularBody -> collect(pb|pb.pathBody) -> flatten();

---------------imperative-method-like rules (sorry, spirit of declarative programming)-------------

rule nextId(){
	do{
		thisModule.id <- thisModule.id.inc();
		thisModule.id;
	}
}

rule processPathNode(node: OclAny, tUCMmap: Urn!UCMmap){
	do{
		if(node.oclIsTypeOf(Turn!Timer)){
			thisModule.connectTimerNodes(node, tUCMmap);
		}
		else if(node.oclIsTypeOf(Turn!AndFork)){
			thisModule.connectAndForkNodes(node, tUCMmap);
		}
		else if(node.oclIsTypeOf(Turn!OrFork)){
			thisModule.connectOrForkNodes(node, tUCMmap);
		}
		else if(node.oclIsTypeOf(Turn!Stub)){
			thisModule.createStubOutNodes(node, tUCMmap);
		}
	}
}

--Dictionary. Had to use called rule as elseif is not supported in helpers
rule contributionNumberToKeyword(quantitativeContribution: Integer){
	do{
		thisModule.contribution <- 'Invalid';
		
		if (quantitativeContribution <= -1)
			thisModule.contribution <- 'Hurt';
		else if (quantitativeContribution < -49)
			thisModule.contribution <- 'SomeNegative';
		else if (quantitativeContribution = -100)
			thisModule.contribution <- 'Break';
		else if (quantitativeContribution = 0)
			thisModule.contribution <- 'Unknown';
		else if (quantitativeContribution < 50)
			thisModule.contribution <- 'Help';
		else if (quantitativeContribution <= 99)
			thisModule.contribution <- 'SomePositive';
		else if (quantitativeContribution = 100)
			thisModule.contribution <- 'Make';
		
		thisModule.contribution;
	}
}

rule joinStringSequence(s: String, delim: String){
	do{
		thisModule.joinedString <-'';
		for(currentString in s.content){
			thisModule.joinedString <- thisModule.joinedString + currentString + delim;	
		}
		thisModule.joinedString;
	}
}

rule connectOrForkNodes(pathend : Turn!PathEnd, tUCMmap: Urn!UCMmap){
	do{
		thisModule.counter <- 1;
		if(not pathend.body.oclIsUndefined()){
			for(regularbody in pathend.body.regularBody -> flatten()){
				if(not regularbody.pathBody.referencedEnd.oclIsUndefined()){
					tUCMmap.nodes -> any(n|n.name=regularbody.pathBody.referencedEnd.name).pred <- tUCMmap.nodes -> any(n|n.name=pathend.name).succ -> at(thisModule.counter);
				}
				else{
					--if pathNodes exist
					if(regularbody.pathBody.oclIsTypeOf(Turn!PathBodyNodes)){
						if(not (regularbody.pathBody.pathNodes -> isEmpty())){
							thisModule.connectNodes(regularbody.pathBody, pathend, tUCMmap, thisModule.orForkMap.get(pathend));
						}	
					}

					if(regularbody.pathBody.pathEnd.oclIsTypeOf(Turn!Stub)){
						thisModule.createStubOutNodes(pathend, tUCMmap);
					}
					else{
						thisModule.processPathNode(regularbody.pathBody.pathEnd, tUCMmap);
					}
				}
			}		
			thisModule.counter <- thisModule.counter.inc();
		}
	}
}

rule connectOrForkEndPoints(obj: Turn!OrFork, nextNode: Urn!PathNode, tUCMmap: Urn!UCMmap, expression: String){
	do{
		thisModule.nextNodeSucc <- '';
		
		if(nextNode.oclIsTypeOf(Urn!OrFork)){
			thisModule.nextNodeSucc <- nextNode.succ -> any(s|s.condition.expression = expression);
		}
		else{
			thisModule.nextNodeSucc <- nextNode.succ -> any(s|s.target.oclIsUndefined());
		}
		
		if(obj.connectingOrBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
	 		tUCMmap.nodes -> any(n|n.name = obj.connectingOrBody.pathEnd.regularEnd.name).pred <- thisModule.nextNodeSucc;
		}
		else if(obj.connectingOrBody.pathEnd.oclIsTypeOf(Turn!Stub)){
			tUCMmap.nodes -> any(n|n.name = obj.connectingOrBody.pathEnd.name).pred <- thisModule.nextNodeSucc;
		}
		else if(obj.connectingOrBody.pathEnd.oclIsTypeOf(Turn!OrFork)){
			thisModule.orForkMap.get(obj.connectingOrBody.pathEnd).pred <- thisModule.nextNodeSucc;
		}
		else if(obj.connectingOrBody.pathEnd.oclIsTypeOf(Turn!AndFork)){
			thisModule.andForkMap.get(obj.connectingOrBody.pathEnd).pred <- thisModule.nextNodeSucc;
		}
	
		if(not obj.connectingOrBody.referencedEnd.oclIsUndefined()){
			--added now
			if(obj.connectingOrBody.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(not obj.connectingOrBody.pathNodes -> at(thisModule.nodeCounter).oclIsTypeOf(Turn!Connect)){
					if(tUCMmap.nodes -> any(n|obj.connectingOrBody.referencedEnd.name=n.name).pred -> collect(s|s.source) -> isEmpty()){
						tUCMmap.nodes -> any(n|obj.connectingOrBody.referencedEnd.name=n.name).pred <- thisModule.nextNodeSucc;
					}
				}
			}
			else if(obj.connectingOrBody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
				Urn!Responsibility.allInstances() -> any(n|obj.connectingOrBody.referencedEnd.name=n.name).respRefs -> any(r|r.diagram.name = tUCMmap.name).pred  <- thisModule.nextNodeSucc; 
			}
			else {
				tUCMmap.nodes -> any(n|obj.connectingOrBody.referencedEnd.name=n.name).pred <- thisModule.nextNodeSucc;
			}
				
		}--here ends
		else if(not obj.connectingOrBody.referencedStub.oclIsUndefined()){
			if(tUCMmap.nodes -> any(n|obj.connectingOrBody.referencedStub.name=n.name).pred -> size() >= obj.connectingOrBody.index){
				thisModule.firstPred <-  tUCMmap.nodes -> any(n|obj.connectingOrBody.referencedStub.name=n.name).pred -> first().source;
				thisModule.oj <- thisModule.createOrJoin(tUCMmap);
				thisModule.oj.pred <- thisModule.nextNodeSucc;
				thisModule.oj.pred <- thisModule.firstPred.succ;
				tUCMmap.nodes -> any(n|obj.connectingOrBody.referencedStub.name=n.name).pred <- thisModule.oj.succ;
			}
			else{
				tUCMmap.nodes -> any(n|obj.connectingOrBody.referencedStub.name=n.name).pred <-  thisModule.nextNodeSucc;
			}
		}
	}
}

rule connectAndForkNodes(pathend : Turn!PathEnd, tUCMmap: Urn!UCMmap){
	do{
		thisModule.counter <- 1;
		for(pathbody in pathend.pathbody -> flatten()){
			if(not pathbody.referencedEnd.oclIsUndefined()){
				tUCMmap.nodes -> any(n|n.name=pathbody.referencedEnd.name).pred <- thisModule.andForkMap.get(pathend).succ -> at(thisModule.counter);
			}
			else{
				--if pathNodes exist
				if(pathbody.oclIsTypeOf(Turn!PathBodyNodes)){
					if(pathbody.pathNodes -> size() > 0){
						thisModule.connectNodes(pathbody, pathend, tUCMmap);
					}	
					--if no pathNodes exist
					else { 
						if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
							tUCMmap.nodes -> any(n|pathbody.pathEnd.regularEnd.name=n.name).pred <- thisModule.andForkMap.get(pathend).succ -> at(thisModule.counter);
						}
					}
				}
				thisModule.processPathNode(pathbody.pathEnd, tUCMmap);
			}
			thisModule.counter <- thisModule.counter.inc();
		}
	}
}

rule connectTimerNodes(timerObj:Turn!Timer, tUCMmap:Urn!UCMmap){
	do{
		--if pathNodes exist  NOT SURE IF REQUIRED AS THERE IS NO PATHNODES TO TIMEOUT PATH
		if(not (timerObj.timeoutPath.pathNodes -> isEmpty())){
			--THIS WILL ALWAYS BE AT(2)
			tUCMmap.nodes -> any(n|timerObj.timeoutPath.pathNodes -> first().name=n.name).pred <- tUCMmap.nodes -> any(n|timerObj.name=n.name).succ -> at(2);
			thisModule.connectNodes(timerObj.timeoutPath, timerObj, tUCMmap, OclAny);
		}
		
		if(not timerObj.timeoutPath.referencedEnd.oclIsUndefined()){
			if(timerObj.timeoutPath.referencedEnd.oclIsTypeOf(Turn!RespRef)){
				--THIS WILL ALWAYS BE AT(2)
				Urn!Responsibility.allInstances() -> any(n|timerObj.timeoutPath.referencedEnd.name = n.name).respRefs -> first().pred <- tUCMmap.nodes -> any(n|timerObj.name=n.name).succ -> at(2);
			}
			--ADD MORE CODE
		}
		
		thisModule.processPathNode(timerObj.timeoutPath.pathEnd, tUCMmap);
	}
}

rule backLinksToOrFork(ep: Turn!EndPoint, tEndPoint: Urn!EndPoint){
	do{
		if(ep.epConnect.pbody.pathNodes -> isEmpty()){
			if(not ep.epConnect.pbody.orFork.oclIsUndefined()){
				thisModule.condExpression <- thisModule.joinStringSequence(ep.epConnect.pbody.orFork.condition.expression, '');
				tEndPoint.pred <- thisModule.orForkMap.get(ep.epConnect.pbody.orFork.orBody.orFork).succ -> any(s|s.condition.expression = thisModule.condExpression);
			}
		}
	}
}

rule createMetadata(name: String, value: String) {
	to 
     targetMetadata: Urn!Metadata(
     	name <- name,
     	value <- value    
     )
	do{
	 	targetMetadata;
	}
}

rule createNodeConns(){
	to
	 	targetNodeConn: Urn!NodeConnection
	do{
		targetNodeConn;	
	}		
}

rule createComponent(s: Turn!ComponentRef){
	to
		tComp: Urn!Component(
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName()
		)
	do{
		tComp;	
	}
}

rule createKpiEvalValueSet(s: Turn!LinearConversion) {
	to
		tkpiEvalValueSet: Urn! KPIEvalValueSet(
			unit <- s.unit,
			targetValue <- s.targetValue,
			thresholdValue <- s.thresholdValue,
			worstValue <- s.worstValue
		)
	do{ 
		tkpiEvalValueSet;
	}
}

rule createQMapKpiEvalValueSet(conv: Turn!QualToQMappings){
	to		
		tkpiEvalValueSet: Urn!KPIEvalValueSet(
			kpiConv <- conv	
		)
	do{ 
		tkpiEvalValueSet;
	}
}

rule createOrJoin(tUCMmap: Urn!UCMmap){
	to
		tOrJoin: Urn!OrJoin(
			id <- thisModule.nextId().toString(),
			name <- 'OrJoin' + tOrJoin.id,
			succ <- tConn,
			diagram <- tUCMmap
		),
		tConn: Urn!NodeConnection()
	do{
		tOrJoin;
	}
}

rule createAndJoin(tUCMmap: Urn!UCMmap){
	to
		tAndJoin: Urn!AndJoin(
			id <- thisModule.nextId().toString(),
			name <- 'AndJoin' + tAndJoin.id,
			succ <- tConn,
			diagram <- tUCMmap
		),
		tConn: Urn!NodeConnection()
	do{
		tAndJoin;
	}
}

rule createConnect(tUCMmap: Urn!UCMmap){
	to
		tConnect: Urn!Connect(
			id <- thisModule.nextId().toString(),
			name <- 'Connect' + tConnect.id,
			succ <- tConn,
			diagram <- tUCMmap
		),
		tConn: Urn!NodeConnection()
	do{
		tConnect;	
	}
}

rule createCondition(sourceExpression: String){
	to
	 	targetCondition: Urn!Condition(
	 		expression <- sourceExpression,
			label <- sourceExpression
	 	)
	do{
		targetCondition;
	}		
}

rule createOrForkNodeConns(ref: Turn!RegularOrFork,  tUCMmap: Urn!UCMmap){
	to
	 	targetNodeConn: Urn!NodeConnection
	do{
		if(ref <> OclAny){
			targetNodeConn.condition <- thisModule.resolveTemp(ref.condition,'tCondition');
		}
		targetNodeConn;	
	}	
}

rule createAndForkNodeConns(ref: Turn!PathBodyNodes,  tUCMmap: Urn!UCMmap){
	to
	 	targetNodeConn: Urn!NodeConnection
	do{
		targetNodeConn;	
	}	
}

rule createResponsibility(s: Turn!RespRef){
	to
		tResp: Urn!Responsibility(
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName()
		)
	do{
		tResp;
	}
}

rule createLabel(){
	to
		tNodeLabel: Urn!NodeLabel()
	do{
		tNodeLabel;
	}
}

rule createOrFork(obj:Turn!OrFork, tUCMmap: Urn!UCMmap){
	to
		tOrFork: Urn!OrFork (
			id <- thisModule.nextId().toString(),
			name <- obj.turnGetLongestName(),
			diagram <- tUCMmap
		)
	do{
		if(tOrFork.name.oclIsUndefined()){
			tOrFork.name <- 'OrFork'+tOrFork.id;
		}
		else{
			tOrFork.label <- thisModule.createLabel(obj);
		}
		
		if(not obj.body.oclIsUndefined()){
			for(elem in obj.body.regularBody){
				tOrFork.succ <- thisModule.createOrForkNodeConns(elem, tUCMmap);
			}
		}
		else if(not obj.connectingOrBody.oclIsUndefined()){
			tOrFork.succ <- thisModule.createOrForkNodeConns(obj, tUCMmap);
		}
			
		thisModule.orForkMap <-  thisModule.orForkMap.including(obj,tOrFork);
		--Connecting nodes before OrFork in case it is a stub
		if(not obj.pbody.parentStub.oclIsUndefined()){
			tOrFork.pred <- tUCMmap.nodes -> any(n|n.name = obj.pbody.parentStub.parentStub.name).succ ;
		}
		
		thisModule.nodeCollector <- Sequence{};
		
		if(not obj.body.oclIsUndefined()) {
			tUCMmap.nodes <- obj.getPathBodies() -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tRespRef'));
			tUCMmap.nodes <- obj.getPathBodies() -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tOrJoin')) ;
			tUCMmap.nodes <- obj.getPathBodies() -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tAndJoin')) ;
			tUCMmap.nodes <- obj.getPathBodies() -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tFailPt'));
			tUCMmap.nodes <- obj.getPathBodies() -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tWtPlace'));
			
			for (pathbody in obj.getPathBodies()){
				if(pathbody.pathEnd.oclIsTypeOf(Turn!OrFork)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createOrFork(pathbody.pathEnd, tUCMmap));
				}
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!Stub)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createStub(pathbody.pathEnd, tUCMmap));
					thisModule.createStubOutNodes(pathbody.pathEnd, tUCMmap);
				}
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createAndFork(pathbody.pathEnd, tUCMmap));
				}
				else if(pathbody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
					if(tUCMmap.nodes -> any(n|n.name = pathbody.pathEnd.regularEnd.name).oclIsUndefined()){
						thisModule.createEndPoint(pathbody.pathEnd.regularEnd, tUCMmap);
					}
					else{
						thisModule.backLinksToOrFork(pathbody.pathEnd.regularEnd, tUCMmap.nodes -> any(n|n.name = pathbody.pathEnd.regularEnd.name));
					}
				}
			}

			--Orforks with only one pathbody
			if(obj.getPathBodies() -> size() = 1){
				--creating a node connection with a negated condition
				thisModule.createdOrForkNodeConnection <- thisModule.createOrForkNodeConns(OclAny, tUCMmap);
				
				-- TODO: determine if removing the line below will cause any issues
				thisModule.condition <- '';
				if(obj.getPathBodies().first().pathEnd.oclIsUndefined()){
					thisModule.condition <- thisModule.joinStringSequence(obj.getPathBodies().first().orFork.condition.expression, '');
				}
				thisModule.createdOrForkNodeConnection.condition <- thisModule.createCondition('!'+thisModule.condition);
				
				--creating an empty end point
				if(obj.body.elseBody.oclIsUndefined()){
					thisModule.createdOrForkNodeConnection.target <- thisModule.createEndPoint(obj, tUCMmap) -> first();
				}
				
				tOrFork.succ <- thisModule.createdOrForkNodeConnection;
			}
		}
		else{
			thisModule.condition <- thisModule.joinStringSequence(obj.condition.expression, '');
			thisModule.createdOrForkNodeConnection <- thisModule.createOrForkNodeConns(OclAny, tUCMmap);
			thisModule.createdOrForkNodeConnection.condition <- thisModule.createCondition('!'+thisModule.condition);
			thisModule.createdOrForkNodeConnection.target <- thisModule.createEndPoint(obj, tUCMmap) -> first();
			
			tOrFork.succ <- thisModule.createdOrForkNodeConnection;
		}
		
		if(not obj.connectingOrBody.oclIsUndefined()){
			
			tUCMmap.nodes <- obj.connectingOrBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tRespRef'));
			tUCMmap.nodes <- obj.connectingOrBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tOrJoin'));
			tUCMmap.nodes <- obj.connectingOrBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tAndJoin'));
			tUCMmap.nodes <- obj.connectingOrBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tFailPt'));
			tUCMmap.nodes <- obj.connectingOrBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tWtPlace'));
			
			thisModule.numberOfterminatingNodes <- 0;
			if(not obj.body.oclIsUndefined()){
				for (pathbody in obj.body.regularBody -> collect(pb|pb.pathBody)){
					if(pathbody.pathEnd.oclIsUndefined()){
						thisModule.numberOfterminatingNodes <- thisModule.numberOfterminatingNodes.inc();
					}
				}
			}
			if(obj.connectingOrBody.pathEnd.oclIsTypeOf(Turn!OrFork)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createOrFork(obj.connectingOrBody.pathEnd, tUCMmap) );
			}
			else if(obj.connectingOrBody.pathEnd.oclIsTypeOf(Turn!Stub)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createStub(obj.connectingOrBody.pathEnd, tUCMmap));
				thisModule.createStubOutNodes(obj.connectingOrBody.pathEnd, tUCMmap);
			}
			else if(obj.connectingOrBody.pathEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createAndFork(obj.connectingOrBody.pathEnd, tUCMmap));
			}
			else if(obj.connectingOrBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(tUCMmap.nodes -> any(n|n.name = obj.connectingOrBody.pathEnd.regularEnd.name).oclIsUndefined()){
					thisModule.createEndPoint(obj.connectingOrBody.pathEnd.regularEnd, tUCMmap);
				}
				else{
					thisModule.backLinksToOrFork(obj.connectingOrBody.pathEnd.regularEnd, tUCMmap.nodes -> any(n|n.name = obj.connectingOrBody.pathEnd.regularEnd.name));
				}
			}
			
			thisModule.nextNode <- tOrFork;
			
			if(thisModule.numberOfterminatingNodes = 2){
				thisModule.oj <- thisModule.createOrJoin(tUCMmap);
				thisModule.oj.pred <- tOrFork.succ -> any(s|s.target.oclIsUndefined());
				thisModule.nextNode <- thisModule.oj;
			}
			else if(thisModule.numberOfterminatingNodes = 1 and not obj.connectingOrBody.pathNodes -> first().oclIsUndefined()){
				if(not obj.connectingOrBody.pathNodes -> first().oclIsTypeOf(Turn!Connect)){
					if(not obj.connectingOrBody.pathNodes -> first().name.oclIsUndefined()){
						thisModule.nextNode <- tUCMmap.nodes -> any(n|n.name = obj.connectingOrBody.pathNodes -> first().name);
					}
				}
			}
			
			if(obj.connectingOrBody.pathNodes -> isEmpty()){
				if(not obj.body.oclIsUndefined()){
					if(not obj.body.elseBody.oclIsUndefined()){
						thisModule.connectOrForkEndPoints(obj, thisModule.nextNode, tUCMmap, thisModule.createdCondition.expression);
					}
					
					for (pathbody in obj.body.regularBody -> collect(b|b.pathBody) -> flatten()){
						thisModule.condition <- '';
						if(pathbody.pathEnd.oclIsUndefined()){
							thisModule.condition <- thisModule.joinStringSequence(pathbody.orFork.condition.expression, '');
						}
						thisModule.connectOrForkEndPoints(obj, thisModule.nextNode, tUCMmap, thisModule.condition);
					}
				}
				else{
					thisModule.condition <- thisModule.joinStringSequence(obj.condition.expression, '');
					thisModule.connectOrForkEndPoints(obj, thisModule.nextNode, tUCMmap, thisModule.condition);
				}
			}
				
			thisModule.counter <- 1;
			thisModule.connectNodes(obj.connectingOrBody, obj, tUCMmap, thisModule.nextNode);
			
			if(not obj.body.oclIsUndefined()){
				for (pathbody in obj.getPathBodies()){
					thisModule.condition <- '';
					if(pathbody.pathEnd.oclIsUndefined()){
						thisModule.condition <- thisModule.joinStringSequence(pathbody.orFork.condition.expression, '');
					}
				}
			}
			else{
				thisModule.condition <- thisModule.joinStringSequence(obj.condition.expression);
			}
		}
		
		--Connecting nodes after OrFork
		thisModule.count <- 1;
		if(not obj.body.oclIsUndefined()){
			for(pathbody in obj.getPathBodies()){
				if(pathbody.pathNodes -> first().oclIsTypeOf(Turn!RespRef)){
					thisModule.resolveTemp(pathbody.pathNodes -> first(),'tRespRef').pred <- tOrFork.succ -> at(thisModule.count);
				}
				thisModule.count <- thisModule.count.inc(); 			
			}
		}
		
		if (not obj.boundTo.oclIsUndefined()){
			if (not obj.boundTo.comp.oclIsUndefined()){
				tOrFork.contRef <-  thisModule.resolveTemp(obj.boundTo.comp, 'tCompRef');
			}
			else{
				tOrFork.contRef <-  thisModule.resolveTemp(obj.boundTo.comp2, 'tCompRef');
			}
		}
		
		--Using backlinks to connect orForks
		if(not obj.pbody.orFork.oclIsUndefined()){
			if(obj.pbody.pathNodes -> isEmpty()){
				tOrFork.pred <- thisModule.orForkMap.get(obj.pbody.orFork.orBody.orFork).succ -> at(thisModule.orForkNodeConnCounter);
				if(thisModule.orForkMap.get(obj.pbody.orFork.orBody.orFork).succ -> size() = thisModule.orForkNodeConnCounter){
					thisModule.orForkNodeConnCounter <- 1;
				}
				else{
					thisModule.orForkNodeConnCounter <- thisModule.orForkNodeConnCounter.inc();
				}
			}
		}
		thisModule.nodeCollector;
	}
}

rule createStub(stubObj:Turn!Stub, tUCMmap: Urn!UCMmap){
	to
		tStub: Urn!Stub (
			id <- thisModule.nextId().toString(),
			name <- stubObj.turnGetLongestName(),
			diagram <- tUCMmap,
			label <- tNodeLabel
		),
		tNodeLabel: Urn!NodeLabel()
	do{
		if(not stubObj.params.oclIsUndefined()){
			tStub.dynamic <- stubObj.params.plugin ->  flatten() -> size() >= 2;
			tStub.bindings <- stubObj.params.plugin -> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'));
		}
		else{
			tStub.bindings <- Turn!UCMmap.allInstances() -> any(m|m.name = tUCMmap.name).stubs -> collect(s|s.params.plugin) -> flatten() -> collect(p|thisModule.resolveTemp(p, 'tPluginBinding'));
		}
			
		if(not stubObj.stubType.oclIsUndefined()){
			if(stubObj.stubType.toString() = ('blocking').toString()){
				tStub.blocking <- true;
				tStub.dynamic <- true;
				tStub.synchronization <- true;
			}
			--original of the line below had no braces around the body of this conditional; was this a bug? 
			else if(stubObj.stubType.toString() = ('synchronizing').toString()){
				tStub.synchronization <- true;
				tStub.dynamic <- true;
			}
		}
		
		if(not stubObj.boundTo.oclIsUndefined()){
			--TODO: the two paths here do the same thing; is this accidental?
			if(not stubObj.boundTo.comp.oclIsUndefined()){
				tStub.contRef <- thisModule.resolveTemp(stubObj.boundTo.comp, 'tCompRef');
			}
			else{
				tStub.contRef <- thisModule.resolveTemp(stubObj.boundTo.comp, 'tCompRef');
			}
		}
		
		for(outPath in stubObj.outPaths -> flatten()){
			thisModule.stubOutPathNC <- thisModule.createNodeConns();
			tStub.succ <- thisModule.stubOutPathNC;
			if(outPath.threshold <> 0){
				thisModule.stubOutPathNC.threshold <- outPath.threshold.toString();
			}
		}
		
		thisModule.nodeCollector <- Sequence{};
		--collect referenced ends
		tUCMmap.nodes <- stubObj.outPaths -> flatten() -> collect(op|op.path) -> flatten() -> collect(p|p.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tRespRef'));
		tUCMmap.nodes <- stubObj.outPaths -> flatten() -> collect(op|op.path) -> flatten() -> collect(p|p.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tOrJoin'));
		tUCMmap.nodes <- stubObj.outPaths -> flatten() -> collect(op|op.path) -> flatten() -> collect(p|p.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tAndJoin'));
		tUCMmap.nodes <- stubObj.outPaths -> flatten() -> collect(op|op.path) -> flatten() -> collect(p|p.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tFailPt'));
		tUCMmap.nodes <- stubObj.outPaths -> flatten() -> collect(op|op.path) -> flatten() -> collect(p|p.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tWtPlace'));
		
		thisModule.stubMap <- thisModule.stubMap.including(stubObj, tStub);
		
		thisModule.numberOfterminatingStubNodes <- 0;
		thisModule.outPathNumber <- Sequence{};
		for (outpath in stubObj.outPaths){
				if(outpath.path.pathEnd.oclIsUndefined()){
					--connecting pathnodes after andfork
					thisModule.numberOfterminatingStubNodes <- thisModule.numberOfterminatingStubNodes.inc();
					thisModule.outPathNumber <- thisModule.outPathNumber -> union(Sequence{outpath.index});
				}
		}
		-- collect regular ends
		for(pathend in stubObj.outPaths -> flatten() -> collect(op|op.path) ->  flatten() -> collect(p|p.pathEnd) ){
			if(pathend.oclIsTypeOf(Turn!OrFork)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createOrFork(pathend, tUCMmap));
			}
			if(pathend.oclIsTypeOf(Turn!Timer)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createTimer(pathend, tUCMmap));
			}
			if(pathend.oclIsTypeOf(Turn!Stub)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createStub(pathend, tUCMmap));
				thisModule.createStubOutNodes(pathend, tUCMmap);
			}
			if(pathend.oclIsTypeOf(Turn!AndFork)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createAndFork(pathend, tUCMmap));
			}
			if(pathend.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(tUCMmap.nodes -> any(n|n.name = pathend.regularEnd.name).oclIsUndefined())
					thisModule.createEndPoint(pathend.regularEnd, tUCMmap);
			}
		}
		if(stubObj.outPaths -> isEmpty() and not stubObj.connectingStubBody.oclIsUndefined()){
			tStub.succ <- thisModule.createNodeConns();
			thisModule.outPathNumber <- Sequence{1};
		}
		
		--collecting nodes from connecting stub body
		if(not stubObj.connectingStubBody.oclIsUndefined()){ 
			
			tUCMmap.nodes <- stubObj.connectingStubBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tRespRef'));
			tUCMmap.nodes <- stubObj.connectingStubBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tOrJoin')) ;
			tUCMmap.nodes <- stubObj.connectingStubBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tAndJoin')) ;
			tUCMmap.nodes <- stubObj.connectingStubBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tFailPt')) ;
			tUCMmap.nodes <- stubObj.connectingStubBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tWtPlace')) ;
			
			if(stubObj.connectingStubBody.pathEnd.oclIsTypeOf(Turn!OrFork)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createOrFork(stubObj.connectingStubBody.pathEnd, tUCMmap) );
			}
			if(stubObj.connectingStubBody.pathEnd.oclIsTypeOf(Turn!Stub)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createStub(stubObj.connectingStubBody.pathEnd, tUCMmap));
				thisModule.createStubOutNodes(stubObj.connectingStubBody.pathEnd, tUCMmap);
			}
			if(stubObj.connectingStubBody.pathEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createAndFork(stubObj.connectingStubBody.pathEnd, tUCMmap));
			}
			if(stubObj.connectingStubBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(tUCMmap.nodes -> any(n|n.name = stubObj.connectingStubBody.pathEnd.regularEnd.name).oclIsUndefined()){
					thisModule.createEndPoint(stubObj.connectingStubBody.pathEnd.regularEnd, tUCMmap);
				}
				else{
					thisModule.backLinksToOrFork(stubObj.connectingStubBody.pathEnd.regularEnd, tUCMmap.nodes -> any(n|n.name = stubObj.connectingStubBody.pathEnd.regularEnd.name));
				}
			}
			
			thisModule.nextNode <- '';
			if(thisModule.numberOfterminatingStubNodes > 1){
				thisModule.oj <- thisModule.createOrJoin(tUCMmap);
				thisModule.oj.pred <- tStub.succ -> at(thisModule.outPathNumber -> at(1));
				thisModule.oj.pred <- tStub.succ -> at(thisModule.outPathNumber -> at(2));
				thisModule.nextNode <- thisModule.oj;
				thisModule.outPathNumber <- Sequence{1};
				--thisModule.index <- 1;
			}
			else if(thisModule.numberOfterminatingStubNodes = 1){
				if(not stubObj.connectingStubBody.pathNodes -> first().oclIsUndefined()){
					if(not stubObj.connectingStubBody.pathNodes -> first().oclIsTypeOf(Turn!Connect)){
						if(not stubObj.connectingStubBody.pathNodes -> first().name.oclIsUndefined())
							thisModule.nextNode <- tUCMmap.nodes -> any(n|n.name = stubObj.connectingStubBody.pathNodes -> first());
					}
				}
				else{
					thisModule.nextNode <- tStub;
				}
			} 
			else{
				thisModule.nextNode <- tStub;
			}
			
			if(stubObj.connectingStubBody.pathNodes -> isEmpty()){
				if(stubObj.connectingStubBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){ 
					tUCMmap.nodes -> any(n|stubObj.connectingStubBody.pathEnd.regularEnd.name=n.name).pred <- thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1));
				}
				else if(stubObj.connectingStubBody.pathEnd.oclIsTypeOf(Turn!OrFork)){
					thisModule.orForkMap.get(stubObj.connectingStubBody.pathEnd).pred <- thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1));
				}
				else if(stubObj.connectingStubBody.pathEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.andForkMap.get(stubObj.connectingStubBody.pathEnd).pred <- thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1));
				}
				else if(stubObj.connectingStubBody.pathEnd.oclIsTypeOf(Turn!Stub)){
					thisModule.stubMap.get(stubObj.connectingStubBody.pathEnd).pred <- thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1));
				}
					
				if(not stubObj.connectingStubBody.referencedEnd.oclIsUndefined()){
					
					if(stubObj.connectingStubBody.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
						if(not stubObj.connectingStubBody.pathNodes -> at(thisModule.nodeCounter).oclIsTypeOf(Turn!Connect)){
						if(tUCMmap.nodes -> any(n|stubObj.connectingStubBody.referencedEnd.name=n.name).pred -> collect(s|s.source) -> isEmpty())
							tUCMmap.nodes -> any(n|stubObj.connectingStubBody.referencedEnd.name=n.name).pred <- thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1));
					}}
					else if(stubObj.connectingStubBody.referencedEnd.oclIsTypeOf(Turn!RespRef))
						thisModule.resolveTemp(stubObj.connectingStubBody.referencedEnd, 'tRespRef').pred  <- thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1)); 
					else {
						tUCMmap.nodes -> any(n|stubObj.connectingStubBody.referencedEnd.name=n.name).pred <- thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1));
					}
				}	
				
				else if(not stubObj.connectingStubBody.referencedStub.oclIsUndefined()){
					if(tUCMmap.nodes -> any(n|stubObj.connectingStubBody.referencedStub.name=n.name).pred -> size() >= stubObj.connectingStubBody.index){
						thisModule.firstPred <-  tUCMmap.nodes -> any(n|stubObj.connectingStubBody.referencedStub.name=n.name).pred -> first().source;
						thisModule.oj <- thisModule.createOrJoin(tUCMmap);
						thisModule.oj.pred <- thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1));
						thisModule.oj.pred <- thisModule.firstPred.succ;
						tUCMmap.nodes -> any(n|stubObj.connectingStubBody.referencedStub.name=n.name).pred <- thisModule.oj.succ;
					}
					else{
						tUCMmap.nodes -> any(n|stubObj.connectingStubBody.referencedStub.name=n.name).pred <-  thisModule.nextNode.succ -> at(thisModule.outPathNumber -> at(1));
					}
				}
			}
				
			thisModule.counter <- 1;
			thisModule.connectNodes(stubObj.connectingStubBody, stubObj, tUCMmap, thisModule.nextNode);
			
		}
		--WRITE CODE FOR OUTPATH NODES as outpath has nodes too.
	
		--Using backlinks to connect orForks
		if(not stubObj.pbody.orFork.oclIsUndefined()){
			tStub.pred <- thisModule.orForkMap.get(stubObj.pbody.orFork.orBody.orFork).succ -> at(thisModule.orForkNodeConnCounter);
			if(thisModule.orForkMap.get(stubObj.pbody.orFork.orBody.orFork).succ -> size() = thisModule.orForkNodeConnCounter){
				thisModule.orForkNodeConnCounter <- 1;
			}
			else{
				thisModule.orForkNodeConnCounter <- thisModule.orForkNodeConnCounter.inc();
			}
		}
		thisModule.nodeCollector;
	}
}

rule createStubOutNodes(stubObj:Turn!Stub, tUCMmap:Urn!UCMmap){
	do{
		--create stubInPathCounter also...
		thisModule.stubOutPathCounter <- 1;
		for(outPath in stubObj.outPaths -> flatten()){
			--if no pathNodes exist
			if(stubObj.outPaths -> flatten() -> at(thisModule.stubOutPathCounter).path.pathNodes -> isEmpty()){
				if(not outPath.path.pathEnd.oclIsUndefined()){
					if(outPath.path.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
						tUCMmap.nodes -> any(n|n.name = outPath.path.pathEnd.regularEnd.name).pred <- thisModule.stubMap.get(stubObj).succ -> at(thisModule.stubOutPathCounter);
					}
					else if(outPath.path.pathEnd.oclIsTypeOf(Turn!OrFork)){
						thisModule.connectOrForkNodes(outPath.path.pathEnd, tUCMmap);
						thisModule.orForkMap.get(outPath.path.pathEnd).pred <- thisModule.stubMap.get(stubObj).succ -> at(thisModule.stubOutPathCounter);
					}
					else if(outPath.path.pathEnd.oclIsTypeOf(Turn!AndFork)){
						thisModule.createAndForkNodes(outPath.path.pathEnd, tUCMmap);
						thisModule.andForkMap.get(outPath.path.pathEnd).pred <- thisModule.stubMap.get(stubObj).succ -> at(thisModule.stubOutPathCounter);
					}
					-- ADD MORE CODE BELOW
					else if (not outPath.path.referencedEnd.oclIsUndefined()){
						tUCMmap.nodes -> any(n|n.name = outPath.path.referencedEnd.name).pred <- thisModule.stubMap.get(stubObj).succ -> at(thisModule.stubOutPathCounter);
					}
					else { 
						tUCMmap.nodes -> any(n|n.name = outPath.path.pathEnd.name).pred <- thisModule.stubMap.get(stubObj).succ -> at(thisModule.stubOutPathCounter);
					}
				}
			}
			--if pathNodes exist
			else{
				thisModule.nodeCounter <- 1;
				for(node in outPath.path.pathNodes){
					if(thisModule.nodeCounter = 1){
						if(node.oclIsTypeOf(Turn!RespRef)){
							Urn!Responsibility.allInstances() -> any(n|n.name = node.name).respRefs -> select(r|r.diagram.name = tUCMmap.name) -> flatten() -> any(ref|ref.pred -> isEmpty()).pred <- thisModule.stubMap.get(stubObj).succ -> at(thisModule.stubOutPathCounter);
						}
						else{	
							tUCMmap.nodes -> any(n|n.name = outPath.path.pathNodes -> first().name).pred <- thisModule.stubMap.get(stubObj).succ -> at(thisModule.stubOutPathCounter);
						}
					}
					else if(node.oclIsTypeOf(Turn!RespRef)){
						if(outPath.path.pathNodes -> at(thisModule.nodeCounter-1).oclIsTypeOf(Turn!RespRef)){
							thisModule.resolveTemp(node, 'tRespRef').pred  <- thisModule.resolveTemp(outPath.path.pathNodes -> at(thisModule.nodeCounter-1), 'tRespRef').succ -> any(s|s.target.oclIsUndefined());	
						}
						else{
							thisModule.resolveTemp(node, 'tRespRef').pred <- tUCMmap.nodes -> any(n|outPath.path.pathNodes -> at(thisModule.nodeCounter-1).name=n.name).succ;
						}
					}
					else if(outPath.path.pathNodes -> at(thisModule.nodeCounter-1).oclIsTypeOf(Turn!RespRef)){
						tUCMmap.nodes -> any(n|n.name=node.name).pred <- thisModule.resolveTemp(outPath.path.pathNodes -> at(thisModule.nodeCounter-1), 'tRespRef').succ -> any(s|s.target.oclIsUndefined());
					}
					else{
						tUCMmap.nodes -> any(n|n.name=node.name).pred <- tUCMmap.nodes -> any(n|outPath.path.pathNodes -> at(thisModule.nodeCounter-1).name=n.name).succ;
					}
					
					if(thisModule.nodeCounter = outPath.path.pathNodes -> size()){
						if(outPath.path.pathNodes  -> at(thisModule.nodeCounter).oclIsTypeOf(Turn!RespRef)){
							tUCMmap.nodes  -> any(n|outPath.path.pathEnd.regularEnd.name=n.name).pred <- thisModule.resolveTemp(outPath.path.pathNodes -> at(thisModule.nodeCounter), 'tRespRef').succ -> any(s|s.target.oclIsUndefined());
						}
						else{
							tUCMmap.nodes -> any(n|outPath.path.pathEnd.name=n.name).pred <- tUCMmap.nodes -> any(n|n.name=outPath.path.pathNodes  -> at(thisModule.nodeCounter).name).succ;
						}
					}
					thisModule.nodeCounter <- thisModule.nodeCounter.inc();
				}
			}
		    thisModule.stubOutPathCounter <- thisModule.stubOutPathCounter.inc();
		}	
	}
}

rule createAndFork(obj:Turn!AndFork, tUCMmap: Urn!UCMmap){
	to
		tAndFork: Urn!AndFork (
			id <- thisModule.nextId().toString(),
			name <- obj.turnGetLongestName(),
			diagram <- tUCMmap
		)
	do{
		if(not tAndFork.name.oclIsUndefined()){
			--TODO: I'm not sure this was actually ever entered in the original code. 
			--Name was always set to '' if no valid value was found; would that enter here?
			tAndFork.label <- thisModule.createLabel();
		}
		else{
			tAndFork.name <- 'AndFork' + tAndFork.id;
		}
		
		thisModule.andForkMap <-  thisModule.andForkMap.including(obj,tAndFork);
		
		for(elem in obj.pathbody){
			tAndFork.succ <- thisModule.createAndForkNodeConns(elem, tUCMmap);
		}
		
		if(not obj.boundTo.oclIsUndefined()){
			if(not obj.boundTo.comp.oclIsUndefined()){
				tAndFork.contRef <-  thisModule.resolveTemp(obj.boundTo.comp, 'tCompRef');
			}
			else{
				tAndFork.contRef <-  thisModule.resolveTemp(obj.boundTo.comp2, 'tCompRef');
			}
		}
		
		thisModule.nodeCollector <- Sequence{};
		
		tUCMmap.nodes <- obj.pathbody -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tRespRef'));
		tUCMmap.nodes <- obj.pathbody -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tOrJoin')) ;
		tUCMmap.nodes <- obj.pathbody -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tAndJoin')) ;
		tUCMmap.nodes <- obj.pathbody -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tWtPlace')) ;
		tUCMmap.nodes <- obj.pathbody -> collect(pb|pb.pathNodes) -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tFailPt')) ;
		
		for(pathend in obj.pathbody -> flatten() -> collect(pb|pb.pathEnd) -> flatten()){
			if(pathend.oclIsTypeOf(Turn!OrFork)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createOrFork(pathend, tUCMmap) );
			}
			if(pathend.oclIsTypeOf(Turn!Timer)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createTimer(pathend, tUCMmap));
			}
			if(pathend.oclIsTypeOf(Turn!Stub)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createStub(pathend, tUCMmap));
				thisModule.createStubOutNodes(pathend, tUCMmap);
			}
			if(pathend.oclIsTypeOf(Turn!AndFork)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createAndFork(pathend, tUCMmap));
			}
			if(pathend.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(tUCMmap.nodes -> any(n|n.name = pathend.regularEnd.name).oclIsUndefined()){
					thisModule.createEndPoint(pathend.regularEnd, tUCMmap);
				}
			}
		}
		
		if(not obj.connectingAndBody.oclIsUndefined()){		
			tUCMmap.nodes <- obj.connectingAndBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tRespRef'));
			tUCMmap.nodes <- obj.connectingAndBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tOrJoin')) ;
			tUCMmap.nodes <- obj.connectingAndBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tAndJoin')) ;
			tUCMmap.nodes <- obj.connectingAndBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tFailPt')) ;
			tUCMmap.nodes <- obj.connectingAndBody.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tWtPlace')) ;
				
			thisModule.numberOfterminatingNodes <- 0;
			for (pathbody in obj.pathbody){
				if(pathbody.pathEnd.oclIsUndefined()){
					--connecting pathnodes after andfork
					thisModule.numberOfterminatingNodes <- thisModule.numberOfterminatingNodes.inc();
				}
			}
					
			if(obj.connectingAndBody.pathEnd.oclIsTypeOf(Turn!OrFork)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createOrFork(obj.connectingAndBody.pathEnd, tUCMmap) );
			}
			if(obj.connectingAndBody.pathEnd.oclIsTypeOf(Turn!Stub)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createStub(obj.connectingAndBody.pathEnd, tUCMmap));
				thisModule.createStubOutNodes(obj.connectingAndBody.pathEnd, tUCMmap);
			}
			if(obj.connectingAndBody.pathEnd.oclIsTypeOf(Turn!AndFork)){
				thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createAndFork(obj.connectingAndBody.pathEnd, tUCMmap));
			}
			if(obj.connectingAndBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(tUCMmap.nodes -> any(n|n.name = obj.connectingAndBody.pathEnd.regularEnd.name).oclIsUndefined()){
					thisModule.createEndPoint(obj.connectingAndBody.pathEnd.regularEnd, tUCMmap);
				}
				else{
					thisModule.backLinksToOrFork(obj.connectingAndBody.pathEnd.regularEnd, tUCMmap.nodes -> any(n|n.name = obj.connectingAndBody.pathEnd.regularEnd.name));
				}
			}
					
			thisModule.nextNode <- '';
			if(thisModule.numberOfterminatingNodes = 2){
				thisModule.aj <- thisModule.createAndJoin(tUCMmap);
				thisModule.aj.pred <- tAndFork.succ -> any(s|s.target.oclIsUndefined());
				thisModule.aj.pred <- tAndFork.succ -> any(s|s.target.oclIsUndefined());
				thisModule.nextNode <- thisModule.aj;
			}
			else if(thisModule.numberOfterminatingNodes = 1){
				if(not obj.connectingAndBody.pathNodes -> first().oclIsUndefined()){
					if(not obj.connectingAndBody.pathNodes -> first().oclIsTypeOf(Turn!Connect)){
						if(not obj.connectingAndBody.pathNodes -> first().name.oclIsUndefined()){
							thisModule.nextNode <- tUCMmap.nodes -> any(n|n.name = obj.connectingAndBody.pathNodes -> first());
						}
					}
				}
				else{
					thisModule.nextNode <- tAndFork;
				}
			}
					
			if(obj.connectingAndBody.pathNodes -> isEmpty()){
				--also modify the connecting path body with a respRef (line 1093)
				if(obj.connectingAndBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
					tUCMmap.nodes -> any(n|obj.connectingAndBody.pathEnd.regularEnd.name=n.name).pred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
				}
				else if(obj.connectingAndBody.pathEnd.oclIsTypeOf(Turn!OrFork)){
					thisModule.orForkMap.get(obj.connectingAndBody.pathEnd).pred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
				}
				else if(obj.connectingAndBody.pathEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.andForkMap.get(obj.connectingAndBody.pathEnd).pred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
				}
				else if(obj.connectingAndBody.pathEnd.oclIsTypeOf(Turn!Stub)){
					tUCMmap.nodes -> any(n|obj.connectingAndBody.pathEnd.name=n.name).pred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
				}
				--ADD MORE CODE
				
				if(not obj.connectingAndBody.referencedEnd.oclIsUndefined()){
					if(obj.connectingAndBody.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
						if(not obj.connectingAndBody.pathNodes -> at(thisModule.nodeCounter).oclIsTypeOf(Turn!Connect)){
							if(tUCMmap.nodes -> any(n|obj.connectingAndBody.referencedEnd.name=n.name).pred -> collect(s|s.source) -> isEmpty()){
								tUCMmap.nodes -> any(n|obj.connectingAndBody.referencedEnd.name=n.name).pred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
							}
						}
					}
					else if(obj.connectingAndBody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
						thisModule.resolveTemp(obj.connectingAndBody.referencedEnd, 'tRespRef').pred  <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined()); 
					}
					else {
						tUCMmap.nodes -> any(n|obj.connectingAndBody.referencedEnd.name=n.name).pred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
					}
				}	
					
				else if(not obj.connectingAndBody.referencedStub.oclIsUndefined()){
					if(tUCMmap.nodes -> any(n|obj.connectingAndBody.referencedStub.name=n.name).pred -> size() >= obj.connectingAndBody.index){
						thisModule.firstPred <-  tUCMmap.nodes -> any(n|obj.connectingAndBody.referencedStub.name=n.name).pred -> first().source;
						thisModule.oj <- thisModule.createOrJoin(tUCMmap);
						thisModule.oj.pred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
						thisModule.oj.pred <- thisModule.firstPred.succ;
						tUCMmap.nodes -> any(n|obj.connectingAndBody.referencedStub.name=n.name).pred <- thisModule.oj.succ;
					}
					else{
						tUCMmap.nodes -> any(n|obj.connectingAndBody.referencedStub.name=n.name).pred <-  thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
					}
				}
			}
			thisModule.counter <- 1;
			thisModule.connectNodes(obj.connectingAndBody, obj, tUCMmap, thisModule.nextNode);
					
		}
		
		--Connecting nodes after AndFork
		thisModule.andForkNodeConnCounter <- 1;
		for(pathbody in obj.pathbody){
			if(pathbody.pathNodes -> first().oclIsTypeOf(Turn!RespRef)){
				thisModule.resolveTemp(pathbody.pathNodes -> first(),'tRespRef').pred  <- tAndFork.succ -> at(thisModule.andForkNodeConnCounter);
			}
			thisModule.andForkNodeConnCounter <- thisModule.andForkNodeConnCounter.inc(); 			
		}
		
		--Using backlinks to connect orForks
		if(not obj.pbody.orFork.oclIsUndefined()){
			tAndFork.pred <- thisModule.orForkMap.get(obj.pbody.orFork.orBody.orFork).succ -> at(thisModule.orForkNodeConnCounter);
			if(thisModule.orForkMap.get(obj.pbody.orFork.orBody.orFork).succ -> size() = thisModule.orForkNodeConnCounter){
				thisModule.orForkNodeConnCounter <- 1;
			}
			else{
				thisModule.orForkNodeConnCounter <- thisModule.orForkNodeConnCounter.inc();
			}
		}
		thisModule.nodeCollector;
	}
}

rule createEndPoint(ep: Turn!EndPoint, tUCMmap: Urn!UCMmap){
	to
		tEndPoint: Urn!EndPoint (
			id <- thisModule.nextId().toString(),
			name <- 'EndPoint' + tEndPoint.id,
			diagram <- tUCMmap
		)
	do{
		--TODO: determine why this needs to be created here (as in the original) to match the original output
		-- i.e., why can't it be moved to the "to" block?
		tEndPoint.label <- thisModule.createLabel();
		
		if(ep.oclIsTypeOf(Turn!EndPoint)){
			tEndPoint.postcondition <- ep.condition;
		}
		
		if(not(ep <> OclAny)){
			tEndPoint.succ <- thisModule.createNodeConns();
		}
		else if(not ep.oclIsTypeOf(Turn!OrFork)){
			-- personal TODO: determine why name here isn't EndPoint(some#) (i.e., why we change it)
			tEndPoint.name <- ep.turnGetLongestName();
			
			thisModule.endPointMap <- thisModule.endPointMap.including(ep,tEndPoint);
			--component bindings
			if(not ep.boundTo.oclIsUndefined()){
				if(not ep.boundTo.comp.oclIsUndefined()){
					tEndPoint.contRef <-  thisModule.resolveTemp(ep.boundTo.comp, 'tCompRef');
				}
				else{
					tEndPoint.contRef <-  thisModule.resolveTemp(ep.boundTo.comp2, 'tCompRef');
				}
			}
			
			--Using backlinks to connect orFork
			if(ep.epConnect.pbody.pathNodes -> isEmpty()){
				thisModule.currentOrFork <- ep.epConnect.pbody.orFork;
				if(not thisModule.currentOrFork.oclIsUndefined()){
					thisModule.condExpression <- thisModule.joinStringSequence(thisModule.currentOrFork.condition.expression, '');
					tEndPoint.pred <- thisModule.orForkMap.get(thisModule.currentOrFork.orBody.orFork).succ -> any(s|s.condition.expression = thisModule.condExpression);
				}
				--Using backlinks to connect andFork
				thisModule.currentAndFork <- ep.epConnect.pbody.andFork;
				if(not thisModule.currentAndFork.oclIsUndefined()){
					tEndPoint.pred <- thisModule.andForkMap.get(thisModule.currentAndFork).succ -> any(s|s.target = OclUndefined);
				}
			}
		}
		
		thisModule.epNodeCollector <- Sequence{tEndPoint};
		thisModule.epNodeCollector;
	}
}

rule createTimer(timerObj: Turn!Timer, tUCMmap: Urn!UCMmap){
	to
		tTimer: Urn!Timer (
			id <- thisModule.nextId().toString(),
			name <- timerObj.turnGetLongestName(),
			succ <- tNodeConn,
			diagram <- tUCMmap,
			label <- tNodeLabel,
			waitType <- timerObj.kind.toString().capitalize()
		),
		tNodeConn: Urn!NodeConnection(
			condition <- timerObj.condition
		),
		tNodeLabel: Urn!NodeLabel()
	do{
		if(not timerObj.boundTo.oclIsUndefined()){
				if(not timerObj.boundTo.comp.oclIsUndefined()){
					tTimer.contRef <-  thisModule.resolveTemp(timerObj.boundTo.comp, 'tCompRef');
				}
				else{
					tTimer.contRef <-  thisModule.resolveTemp(timerObj.boundTo.comp2, 'tCompRef');
				}
		}
		
		thisModule.nodeCollector <- Sequence{};
		--timer out path
			if(not timerObj.timeoutPath.oclIsUndefined()){
				tTimer.succ <- thisModule.createNodeConns();
				if(not timerObj.timeoutCondition.oclIsUndefined()){
					tTimer.succ -> at(2).condition <- thisModule.createCondition(timerObj.timeoutCondition.expression.content -> at(1));
				}
				
				tUCMmap.nodes <- timerObj.timeoutPath.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tRespRef'));
				tUCMmap.nodes <- timerObj.timeoutPath.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tOrJoin')) ;
				tUCMmap.nodes <- timerObj.timeoutPath.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tAndJoin')) ;
				tUCMmap.nodes <- timerObj.timeoutPath.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tWtPlace')) ;
				tUCMmap.nodes <- timerObj.timeoutPath.pathNodes -> flatten() ->  collect(r|thisModule.resolveTemp(r,'tFailPt')) ;
				
				--timer ends
				if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!OrFork)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createOrFork(timerObj.timeoutPath.pathEnd, tUCMmap));
				}
				if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!Timer)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createTimer(timerObj.timeoutPath.pathEnd, tUCMmap));
				}
				if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!Stub)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createStub(timerObj.timeoutPath.pathEnd, tUCMmap));
					thisModule.createStubOutNodes(timerObj.timeoutPath.pathEnd, tUCMmap);
				}
				if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
					if(tUCMmap.nodes -> any(n|n.name = timerObj.timeoutPath.pathEnd.regularEnd.name).oclIsUndefined())
						thisModule.createEndPoint(timerObj.timeoutPath.pathEnd.regularEnd, tUCMmap);
				}
				if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.createAndFork(timerObj.timeoutPath.pathEnd, tUCMmap));
				}
				
				if(timerObj.timeoutPath.pathNodes -> isEmpty()){
				--also modify the connecting path body with a respRef (line 1093)
					if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
						tUCMmap.nodes -> any(n|timerObj.timeoutPath.pathEnd.regularEnd.name=n.name).pred <- tTimer.succ -> at(2);
					}
					else if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!OrFork)){
						thisModule.orForkMap.get(timerObj.timeoutPath.pathEnd).pred <- tTimer.succ -> at(2);
					}
					else if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!AndFork)){
						thisModule.andForkMap.get(timerObj.timeoutPath.pathEnd).pred <- tTimer.succ -> at(2);
					}
					else if(timerObj.timeoutPath.pathEnd.oclIsTypeOf(Turn!Stub)){
						tUCMmap.nodes -> any(n|timerObj.timeoutPath.pathEnd.name=n.name).pred <- tTimer.succ -> at(2);
					}
					--ADD MORE CODE

					if(not timerObj.timeoutPath.referencedEnd.oclIsUndefined()){
				
						if(timerObj.timeoutPath.referencedEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
							if(not timerObj.timeoutPath.pathNodes -> at(thisModule.nodeCounter).oclIsTypeOf(Turn!Connect)){
							if(tUCMmap.nodes -> any(n|timerObj.timeoutPath.referencedEnd.name=n.name).pred -> collect(s|s.source) -> isEmpty())
								tUCMmap.nodes -> any(n|timerObj.timeoutPath.referencedEnd.name=n.name).pred <- tTimer.succ -> at(2);
						}}
						else if(timerObj.timeoutPath.referencedEnd.oclIsTypeOf(Turn!RespRef))
							thisModule.resolveTemp(timerObj.timeoutPath.referencedEnd, 'tRespRef').pred  <- tTimer.succ -> at(2); 
						else {
							tUCMmap.nodes -> any(n|timerObj.timeoutPath.referencedEnd.name=n.name).pred <- tTimer.succ -> at(2);
						}
					}	
				
				else if(not timerObj.timeoutPath.referencedStub.oclIsUndefined()){
					if(tUCMmap.nodes -> any(n|timerObj.timeoutPath.referencedStub.name=n.name).pred -> size() >= timerObj.timeoutPath.index){
						thisModule.firstPred <-  tUCMmap.nodes -> any(n|timerObj.timeoutPath.referencedStub.name=n.name).pred -> first().source;
						thisModule.oj <- thisModule.createOrJoin(tUCMmap);
						thisModule.oj.pred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
						thisModule.oj.pred <- thisModule.firstPred.succ;
						tUCMmap.nodes -> any(n|timerObj.timeoutPath.referencedStub.name=n.name).pred <- thisModule.oj.succ;
					}
					else{
						tUCMmap.nodes -> any(n|timerObj.timeoutPath.referencedStub.name=n.name).pred <-  thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
					}
				}
			}
			}
		thisModule.timerMap <- thisModule.timerMap.including(timerObj, tTimer);
		thisModule.nodeCollector;
	}
}

rule createEmptyPt(tUCMmap: Urn!UCMmap, node: Turn!PathBodyNode, asynch: Boolean){
	to
		tEmptyPt: Urn!EmptyPoint(
			id <- thisModule.nextId().toString(),
			diagram <- tUCMmap
		)
	do{
		if (node <> OclAny){
			if(asynch){
				tEmptyPt.name <- 'AsynchConnectTimer#'+node.name;
				tEmptyPt.succ <- thisModule.createNodeConns();
			}
			else
				tEmptyPt.name <- 'SynchConnectTimer#'+node.name;
		}
		else{
			tEmptyPt.name <- 'EmptyPoint'+tEmptyPt.id;
			tEmptyPt.succ <- thisModule.createNodeConns();
			-- TODO: determine why this is called twice; is it intentional?
			tEmptyPt.succ <- thisModule.createNodeConns();
		}
		tEmptyPt;	
	}
}

---------------------final mapping rules------------------------------------

rule IntElements2IntElements{
	from 
		s: Turn!IntentionalElement (s.type.toString() <> 'belief')
	to 
		tIntElemRef: Urn!IntentionalElementRef (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			def <- tIntElem,
			succ <- s.linksSrc -> collect(c|thisModule.resolveTemp(c,'tLinkRef'))
		),
		tIntElem: Urn!IntentionalElement (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			linksSrc <- s.linksSrc
		)
		
	 do{
	 	if(not (Turn!Decomposition -> allInstances() -> select(d|d.dest=s)) -> isEmpty()){
			tIntElem.decompositionType <-Turn!Decomposition -> allInstances() -> select(d|d.dest=s) -> collect(a|a.decompositionType.toString().capitalize())-> first();
		}
		
		tIntElem.type <- s.type.toString().capitalize();
		 
		 --Added because the default value in enum is considered always.
		if(s.importance.toString().toLower().equals('none')){
			tIntElem.importanceQuantitative <- s.importanceQuantitative;
		}
		else{
			tIntElem.importance <- s.importance.toString().capitalize();
		}
		
	 	tIntElem.metadata <- thisModule.createMetadata('TURN-URN-NAME', s.name);
	}
}

rule Actor2Actor{
	from 
		s: Turn!Actor
	to 
		tActor: Urn!Actor (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			importanceQuantitative <- s.importanceQuantitative
		),
		tActorRef: Urn!ActorRef (
			id <- thisModule.nextId().toString(),
			name <- 'ActorRef' + tActorRef.id,
			contDef <- tActor,
			nodes <- s.elems -> collect(e|thisModule.resolveTemp(e,'tIntElemRef')),
			nodes <- s.elems -> collect(e|thisModule.resolveTemp(e,'tBelief')),
			label <- tCompLabel
		),
		tCompLabel: Urn!ComponentLabel()
}

rule Belief2Belief {
	from
		s: Turn!IntentionalElement(s.type.toString() = 'belief')
    to 
     	tBelief: Urn!Belief(
     		id <- thisModule.nextId().toString(),
     		name <- s.name,
			description <- s.name,
			succ <- tBeliefLink
     	),
		tBeliefLink: Urn!BeliefLink(
			target <- s.linksSrc -> collect(l|l.dest) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tIntElemRef')) -> first()
		)
}

rule Contribution2Contribution{
	from 
		s: Turn!Contribution (not (s.link.type.toString() = 'belief'))
	to 
		tCont: Urn!Contribution (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
		    dest <- s.dest,
			refs <- tLinkRef,
	        correlation <- s.correlation
		),
		tLinkRef: Urn!LinkRef (
			link <- tCont,
			target <- thisModule.resolveTemp(s.dest,'tIntElemRef')
		)
	do{
		--Added because the default value in enum is considered always.
		if(s.contribution.toString().equals('undefined')){
			tCont.quantitativeContribution <- s.quantitativeContribution;
			tCont.contribution <- thisModule.contributionNumberToKeyword(s.quantitativeContribution);
		}
		else{
			tCont.contribution <- s.contribution.toString().capitalize();
		}
	}
}
	
rule Decomposition2Decomposition{
	from 
		s: Turn!Decomposition (not (s.link.type.toString() = 'belief'))
	to 
		tDecomp: Urn!Decomposition (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
		    dest <- s.dest,
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef (
			link <- tDecomp,
			target <- thisModule.resolveTemp(s.dest,'tIntElemRef')
		)
}

rule Dependency2Dependency{
	from 
		s: Turn!Dependency (not (s.link.type.toString() = 'belief'))
	to 
		tDep: Urn!Dependency (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
		    dest <- s.dest,
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef (
			link <- tDep,
			target <- thisModule.resolveTemp(s.dest,'tIntElemRef')
		)
}

rule Strategies2Strategies{
	from
		s: Turn!EvaluationStrategy
	to
		tStrategies: Urn!EvaluationStrategy (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			author <- s.info.author,
			evaluations <- s.evaluations,
			includedStrategies <- s.includedStrategies
		)
}

rule StrategiesGroup2StrategiesGroup{
	from
		s: Turn!StrategiesGroup
	to
		tStrategiesGroup: Urn!StrategiesGroup (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			strategies <- s.evalStrategy,
			strategies <- s.evalStrategies
		)
}

rule Evaluation2Evaluation {
	from
		s: Turn!Evaluation
   	to 
	    tEval : Urn!Evaluation (
	     	exceeds <- s.exceeds,
	     	intElement <- s.intElement,
			evaluation <- s.evaluation,
			qualitativeEvaluation <- s.qualitativeEvaluation.toString().capitalize()
	    )
	do {
		if(not s.conversion.oclIsUndefined()){
			if(s.conversion.oclIsTypeOf(Turn!QualToQMappings))
				tEval.kpiEvalValueSet <- thisModule.createQMapKpiEvalValueSet(s.conversion);
			else{
				tEval.kpiEvalValueSet <- thisModule.createKpiEvalValueSet(s.conversion);}
		}
	}
}

rule ContributionContext2ContributionContext{
	from
		s: Turn!ContributionContext
	to
		tContContext: Urn!ContributionContext (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			changes <- s.changes,
			includedContexts <- s.includedContexts
		)
}

rule ContributionChange2ContributionChange{
	from
		s: Turn!ContributionChange
	to
		t: Urn!ContributionChange (
			contribution <- s.contribution,
			newQuantitativeContribution <- s.newQuantitativeContribution
		)
	do{
		if(not s.newContribution.toString().equals('undefined')){
			t.newContribution <- s.newContribution.toString().capitalize();
		}
	}
}

rule ContributionContextGroup2ContributionContextGroup{
	from
		s: Turn!ContributionContextGroup
	to
		tContribGroups: Urn!ContributionContextGroup (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			contribs <- s.contrib,
			contribs <- s.contribs
		)
}

rule QMapping2QMapping {
	from 
		s: Turn!QualToQMapping
	to
		tQMapping: Urn!QualitativeMapping (
			realWorldLabel <- s.realWorldLabel,
			exceeds	<- s.exceeds,
			evaluation <- s.evaluation,
			qualitativeEvaluation <- s.qualitativeEvaluation.toString().capitalize()
		)
}

rule QMappings2QMappings {
	from
		s: Turn!QualToQMappings
	to
		tQMappings: Urn!QualitativeMappings (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			mapping <- s.mappings
		)
}

rule Concern2Concern{
	from 
		s: Turn!Concern
	to 
		tConcern: Urn!Concern (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
		    elements <- s.elements,
			condition <- s.condition,
			metadata <- s.metadata
		)
}

rule URNlink2URNlink{
	from 
		s: Turn!URNlink
	to 
		tCon: Urn!URNlink (
			type <- s.type,
		    fromElem <- s.fromElem,
			toElem <- s.toElem
		)
}

rule Component2Component{
	from 
		s:Turn!ComponentRef 
	to
		tCompRef: Urn!ComponentRef(
			id <- thisModule.nextId().toString(),
			name <- 'ComponentRef' + tCompRef.id,
			label <- tCompLabel,
			diagram <- s.map
		),
		tCompLabel: Urn!ComponentLabel
	do{
		if(Urn!Component.allInstances() -> any(c|c.name = s.name).oclIsUndefined()){
			thisModule.comp <- thisModule.createComponent(s);
			tCompRef.contDef <- thisModule.comp;	
		}
		else {
			tCompRef.contDef <- Urn!Component.allInstances() -> any(c|c.name = s.name);	
		}

		if(s.kind.toString() <> 'parent'){
			if(not s.kind.oclIsUndefined()){
				tCompRef.contDef.kind <- s.kind.toString().capitalize();
			}
			else{
				tCompRef.contDef.kind <- 'Team';
			}
		}
		
		tCompRef.contDef.protected <- s.protected;
		
		if(not s.boundTo.oclIsUndefined()){
			if(not s.boundTo.comp.oclIsUndefined()){
				tCompRef.parent <-  thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
			}
			else{
				tCompRef.parent <-  thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
			}
		}
		
		if(s.element.oclIsTypeOf(Turn!LongBoundElement)){
			tCompRef.metadata <- thisModule.createMetadata('from',s.element.from);
			tCompRef.metadata <- thisModule.createMetadata('to',s.element.to);
		}
		
		if(not (s.elements -> isEmpty())){
			for(elem in s.elements){
				if(elem.oclIsTypeOf(Turn!LongBoundElement)){
					tCompRef.metadata <- thisModule.createMetadata('from',elem.from);
					tCompRef.metadata <- thisModule.createMetadata('to',elem.to);
				}
			}
		}
	}
}

rule Responsibility2Responsibility{
	from
		s: Turn!RespRef 
	to
		tRespRef: Urn!RespRef (
			succ <- tNodeConn,
			label <- tNodeLabel
		),
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel
	do{
		--TODO: Should this be called "existingResponsibilities" instead? i.e., can we have multiple retrieved by this in any case?
		thisModule.existingResponsibility <- Urn!Responsibility.allInstances() -> any(r|r.name = s.turnGetLongestName());
		
		if(thisModule.existingResponsibility.oclIsUndefined()){
			tRespRef.respDef <- thisModule.createResponsibility(s);
		}
		else{
			tRespRef.respDef  <- thisModule.existingResponsibility;
		}
		
		--component bindings added
		if (not s.boundTo.oclIsUndefined()){
			if (not s.boundTo.comp.oclIsUndefined())
				tRespRef.contRef <- thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
			else
				tRespRef.contRef <- thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
		}
		
		tRespRef.id <- thisModule.nextId().toString();
		tRespRef.name <- 'RespRef' + tRespRef.id;
	}
}

rule WaitingPlace2WaitingPlace{
	from		
		s: Turn!WaitingPlace
	to
		tWtPlace: Urn!WaitingPlace (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel,
			waitType <- s.kind.toString().capitalize()
		),
		tNodeConn: Urn!NodeConnection (
			condition <- s.condition
		),
		tNodeLabel: Urn!NodeLabel()
}

rule FailurePoint2FailurePoint{
	from		
		s: Turn!FailurePoint
	to
		tFailPt: Urn!FailurePoint (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel
		),
		tNodeConn: Urn!NodeConnection (
			condition <- s.condition
		),
		tNodeLabel: Urn!NodeLabel()
	do{
		if(not s.failLabel.oclIsUndefined()){
			tFailPt.expression <- s.failLabel.failure;
		}
	}
}

rule URNspec2URNspec{
	from 
		sURNspec: Turn!URNspec
	to
		tURNspec: Urn!URNspec(
			name <- sURNspec.name,
			metadata <- sURNspec.metadata,
			grlspec <- tGRLSpec,
			ucmspec <- tUcmspec,
			urnLinks <- sURNspec.urnlinks,
			urndef <- tURNdef
		),
		tURNdef: Urn!URNdefinition(
			specDiagrams <- tGRLSpecDiag,
			specDiagrams <- sURNspec.ucmMaps -> collect(m|thisModule.resolveTemp(m,'tUCMmap')),
			concerns <- sURNspec.concerns,
			components <- Urn!Component.allInstances(),
			responsibilities <- Urn!Responsibility.allInstances()
		),
		tGRLSpec: Urn!GRLspec(
			actors <- sURNspec.actors,
			intElements <- sURNspec.getActorElements() -> select(e|e.type.toString() <> 'belief'),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tCont')),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tDecomp')),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tDep')),
			groups <- sURNspec.stratGroups,
			strategies <- sURNspec.strategies,
			contributionGroups <- sURNspec.contribContextGroups,
			contributionContexts <- sURNspec.contribContexts,
			KPIConversion <- sURNspec.indConversions -> select(c|c.oclIsTypeOf(Turn!QualToQMappings))
		),
		tGRLSpecDiag: Urn!GRLGraph(
		  	nodes <- sURNspec.getActorElements() -> collect(e| thisModule.resolveTemp(e, 'tIntElemRef')),
			nodes <- Urn!Belief.allInstances(),
			contRefs <- sURNspec.actors -> collect(a| thisModule.resolveTemp(a, 'tActorRef')),
		    connections <- sURNspec.getActorElements() ->  collect(l|l.linksSrc) -> flatten() -> collect(m| thisModule.resolveTemp(m,'tLinkRef')),  
	    	connections <- sURNspec.getActorElements() ->  collect(m| thisModule.resolveTemp(m,'tBeliefLink')) 
		),
		tUcmspec: Urn!UCMspec
	do{
		if(sURNspec.metadata -> select(m| m.name.indexOf('TURN-URN') <> -1 ) -> notEmpty()){
	 		if (sURNspec.metadata -> select(m|m.name.indexOf('nextGlobalID') <> -1 ) -> notEmpty()){
	 			thisModule.id <- sURNspec.metadata -> any(m|m.name = 'TURN-URN-nextGlobalID').value.toInteger();
	 		}
		}
		
		if (not sURNspec.info.oclIsUndefined()){
			tURNspec.description <- sURNspec.info.description;
			tURNspec.author <- sURNspec.info.author;
			tURNspec.created <- sURNspec.info.created;
			tURNspec.modified <- sURNspec.info.modified;
			tURNspec.specVersion <- sURNspec.info.specVersion;
			tURNspec.urnVersion <- sURNspec.info.urnVersion; 
		}
		
		tURNspec.nextGlobalID <- thisModule.id.toString();
	}
}

rule Metadata2Metadata{
	from 
		sourceMetadata: Turn!Metadata
	to 
		targetMetadata: Urn!Metadata(
			name <- sourceMetadata.name
		)
}

rule StartPoint2StartPoint{
	from
		s: Turn!StartPoint
	to
		tStartPoint: Urn!StartPoint (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel,
			diagram <- s.path.map,
			precondition <- s.precondition
		),
		tNodeConn: Urn!NodeConnection(),
		tNodeLabel: Urn!NodeLabel()
	do{
		if(not s.boundTo.oclIsUndefined()){
			if (not s.boundTo.comp.oclIsUndefined()){
				tStartPoint.contRef <-  thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
			}
			else{
				tStartPoint.contRef <-  thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
			}
		}
		
		if(not s.failKind.oclIsUndefined()){
			tStartPoint.failureKind <- s.failKind.toString().capitalize();
		}
	}
}

rule Condition2Condition{
	from 
		s: Turn!Condition
	to 
		tCondition: Urn!Condition(
			expression <- thisModule.joinStringSequence(s.expression, '')
		)
}

rule OrJoin2OrJoin{
	from 	
		s: Turn!OrJoin
	to
		tOrJoin: Urn!OrJoin(
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel
		),
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel
	do{
		if(not s.boundTo.oclIsUndefined()){
			if(not s.boundTo.comp.oclIsUndefined()){
				tOrJoin.contRef <-  thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
			}
			else{
				tOrJoin.contRef <-  thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
			}
		}
		
	}
}

rule AndJoin2AndJoin{
	from 	
		s: Turn!AndJoin
	to
		tAndJoin: Urn!AndJoin(
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel
		),
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel
	do{
		if(not s.boundTo.oclIsUndefined()){
			if(not s.boundTo.comp.oclIsUndefined())
				tAndJoin.contRef <-  thisModule.resolveTemp(s.boundTo.comp, 'tCompRef');
			else
				tAndJoin.contRef <- thisModule.resolveTemp(s.boundTo.comp2, 'tCompRef');
		}
	}
}

rule PluginBinding2PluginBinding{
	from 
		s:Turn!PluginBinding	
	to
		tPluginBinding: Urn!PluginBinding (
			plugin <- thisModule.resolveTemp(s.map, 'tUCMmap'),
			--This could be other way round, binding could be inBinding or OutBinding and vice-versa.
			in <- thisModule.resolveTemp(s.binding,'tInBinding'),
			in <- s.bindings -> collect(b|thisModule.resolveTemp(b,'tInBinding')),
			out <- thisModule.resolveTemp(s.binding,'tOutBinding'),
			out <- s.bindings -> collect(b|thisModule.resolveTemp(b,'tOutBinding')),
			precondition <- thisModule.resolveTemp(s.condition, 'tCondition'),
			replicationFactor <- s.replication
		)
}

rule InBinding2InBinding{
	from
		s:Turn!InBinding
	to
		tInBinding: Urn!InBinding(
			startPoint <- thisModule.resolveTemp(s.mapStart,'tStartPoint')
		)
	do{
		if(not s.binding.oclIsUndefined()){
			if(not s.binding.stubParam.stubDec.oclIsUndefined()){
				tInBinding.stubEntry <- thisModule.stubMap.get(s.binding.stubParam.stubDec.stub).pred -> at(s.index);
			}
			else{
				tInBinding.stubEntry <- thisModule.stubMap.get(s.binding.stubParam.stub).pred -> at(s.index);
			}
		}
		else if(not s.bindings.oclIsUndefined()){
			if(not s.bindings.stubParam.stubDec.oclIsUndefined()){
				tInBinding.stubEntry <- thisModule.stubMap.get(s.bindings.stubParam.stubDec.stub).pred -> at(s.index);
			}
			else{
				tInBinding.stubEntry <- thisModule.stubMap.get(s.bindings.stubParam.stub).pred -> at(s.index);
			}
		}
	}
}

rule OutBinding2OutBinding{
	from
		s:Turn!OutBinding
	to
		tOutBinding: Urn!OutBinding(
			endPoint <- thisModule.endPointMap.get(s.mapEnd)
		)
	do{ 
		if(not s.bindings.oclIsUndefined()){
			if(not s.bindings.stubParam.stubDec.oclIsUndefined()){
				tOutBinding.stubExit <- thisModule.stubMap.get(s.bindings.stubParam.stubDec.stub).pred -> at(s.index);
			}
			else{
				tOutBinding.stubExit <- thisModule.stubMap.get(s.bindings.stubParam.stub).succ -> at(s.index);
			}
		}
		else if(not s.binding.oclIsUndefined()){
			if(not s.binding.stubParam.stubDec.oclIsUndefined()){
				tOutBinding.stubExit <- thisModule.stubMap.get(s.binding.stubParam.stubDec.stub).pred -> at(s.index);
			}
			else {
				tOutBinding.stubExit <- thisModule.stubMap.get(s.binding.stubParam.stub).succ -> at(s.index);
			}
		}
	}
}

rule UCMmap2UCMmap{
	from
		sUCMmap: Turn!UCMmap
	to
		tUCMmap: Urn!UCMmap (
			contRefs <- sUCMmap.components -> collect(c|thisModule.resolveTemp(c,'tCompRef')),
			nodes <-  sUCMmap.paths -> flatten() -> collect(p|p.startPoint) -> flatten() -> collect(p|thisModule.resolveTemp(p,'tStartPoint')),
			connections <- sUCMmap.paths -> flatten() -> collect(p|p.startPoint) -> flatten() -> collect(p|thisModule.resolveTemp(p,'tNodeConn'))
		)
	do{
		--Referenced ends
		tUCMmap.nodes <- sUCMmap.getPathNodes() ->  collect(r|thisModule.resolveTemp(r,'tRespRef'));
		tUCMmap.nodes <- sUCMmap.getPathNodes() ->  collect(r|thisModule.resolveTemp(r,'tAndJoin'));
		tUCMmap.nodes <- sUCMmap.getPathNodes() ->  collect(r|thisModule.resolveTemp(r,'tOrJoin'));
		tUCMmap.nodes <- sUCMmap.getPathNodes() ->  collect(r|thisModule.resolveTemp(r,'tWtPlace'));
		tUCMmap.nodes <- sUCMmap.getPathNodes() ->  collect(r|thisModule.resolveTemp(r,'tFailPt'));
		
		--Regular ends
		--ADD CODE HERE
		for(path in sUCMmap.paths){
			if(path.pathBody.pathEnd.oclIsTypeOf(Turn!OrFork)) {
				tUCMmap.nodes <- thisModule.createOrFork(path.pathBody.pathEnd, tUCMmap);
				thisModule.connectOrForkNodes(path.pathBody.pathEnd, tUCMmap);
			}
			if(path.pathBody.pathEnd.oclIsTypeOf(Turn!AndFork)) {
				tUCMmap.nodes <- thisModule.createAndFork(path.pathBody.pathEnd, tUCMmap);
				thisModule.connectAndForkNodes(path.pathBody.pathEnd, tUCMmap);
			}
			if(path.pathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)) {
				if(tUCMmap.nodes -> any(n|n.name = path.pathBody.pathEnd.regularEnd.name).oclIsUndefined()){
					thisModule.createEndPoint(path.pathBody.pathEnd.regularEnd, tUCMmap);
				}
			}
			if(path.pathBody.pathEnd.oclIsTypeOf(Turn!Stub)) {
				tUCMmap.nodes <- thisModule.createStub(path.pathBody.pathEnd, tUCMmap);
				thisModule.createStubOutNodes(path.pathBody.pathEnd, tUCMmap);
			}
		
			--connect nodes in a map
			thisModule.startPointName <- path.startPoint.turnGetLongestName();
			
			if(not path.startPoint.connect.oclIsUndefined() and tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> size() <> 0){
				tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ept|ept.succ -> includes(thisModule.connectMap.get(path.startPoint.connect).pred -> first())).pred <- tUCMmap.nodes -> any(n|thisModule.startPointName=n.name).succ -> any(s|s.target.oclIsUndefined());
			}--if no pathnodes exist
			if(not path.pathBody.pathEnd.oclIsUndefined() and  path.pathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect) and path.pathBody.pathNodes -> isEmpty()){
				thisModule.endPointName <- path.pathBody.pathEnd.regularEnd.turnGetLongestName();
				
				if(not path.pathBody.pathEnd.connect.oclIsUndefined()){
					--create succ for the connecting endpoint
					tUCMmap.nodes -> any(n|thisModule.endPointName=n.name).succ <- thisModule.createNodeConns();
					thisModule.connect <- thisModule.createConnect(tUCMmap);
					thisModule.connect.pred <- tUCMmap.nodes -> any(n|thisModule.endPointName=n.name).succ;
					thisModule.connectMap <-  thisModule.connectMap.including(path.pathBody.pathEnd.connect,thisModule.connect);
					if(not path.pathBody.pathEnd.connect.connectsTo.oclIsTypeOf(Turn!Timer)){
						tUCMmap.nodes -> any(n|n.name = path.pathBody.pathEnd.connect.connectsTo.name).pred <- thisModule.connect.succ;
					}
					else{
						thisModule.createdEmptyPt <- thisModule.createEmptyPt(tUCMmap, path.pathBody.pathEnd.connect.connectsTo, false);
						thisModule.createdEmptyPt.pred <-  thisModule.connect.succ;
					}
				}
				else if(not path.startPoint.connect.oclIsUndefined() and tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> size() <> 0){
					tUCMmap.nodes -> any(n|thisModule.endPointName=n.name).pred <- tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!EmptyPoint)) -> any(ept|ept.succ -> includes(thisModule.connectMap.get(path.startPoint.connect).pred -> first())).succ -> any(s|s.target.oclIsUndefined());
				} 
				tUCMmap.nodes -> any(n|thisModule.endPointName=n.name).pred <- tUCMmap.nodes -> any(n|thisModule.startPointName=n.name).succ -> any(s|s.target.oclIsUndefined());
			}--added code for stub....
			else if (not path.pathBody.pathEnd.oclIsUndefined() and path.pathBody.pathNodes -> isEmpty() ){
				if(path.pathBody.pathEnd.oclIsTypeOf(Turn!OrFork)){
					thisModule.orForkMap.get(path.pathBody.pathEnd).pred <- tUCMmap.nodes -> any(n|thisModule.startPointName=n.name).succ;
				}
				else if(path.pathBody.pathEnd.oclIsTypeOf(Turn!AndFork)){
					thisModule.andForkMap.get(path.pathBody.pathEnd).pred <- tUCMmap.nodes -> any(n|thisModule.startPointName=n.name).succ;
				}
				else if(path.pathBody.pathEnd.oclIsTypeOf(Turn!Stub)){
					thisModule.stubMap.get(path.pathBody.pathEnd).pred <- tUCMmap.nodes -> any(n|thisModule.startPointName=n.name).succ;
				}
			}
			--if pathnodes exist
			else{
				thisModule.counter <- 1;
				thisModule.connectNodes(path.pathBody, path, tUCMmap, OclAny);
			}
			
			if(path.pathBody.pathNodes -> isEmpty() and (not path.pathBody.referencedEnd.oclIsUndefined())){
				if(path.pathBody.referencedEnd.oclIsTypeOf(Turn!RespRef)){
					thisModule.resolveTemp(path.pathBody.referencedEnd,'tRespRef').pred  <- tUCMmap.nodes -> any(n|path.startPoint.name=n.name).succ; 
				}
				else{
					thisModule.nodeName <- path.pathBody.referencedEnd.turnGetLongestName();
					tUCMmap.nodes -> any(n|n.name=thisModule.nodeName).pred <- tUCMmap.nodes -> any(n|path.startPoint.name=n.name).succ; 
				}
			}
			else if (path.pathBody.pathNodes -> isEmpty() and (not path.pathBody.referencedStub.oclIsUndefined())){
				if (tUCMmap.nodes -> any(n|path.pathBody.referencedStub.name=n.name).pred -> size() >= path.pathBody.index){
					thisModule.firstPred <-  tUCMmap.nodes -> any(n|path.pathBody.referencedStub.name=n.name).pred -> first().source;
					thisModule.oj <- thisModule.createOrJoin(tUCMmap);
					thisModule.oj.pred <- tUCMmap.nodes -> any(n|path.startPoint.name=n.name).succ;
					thisModule.oj.pred <- thisModule.firstPred.succ;
					tUCMmap.nodes -> any(n|path.pathBody.referencedStub.name=n.name).pred <- thisModule.oj.succ;
				}
				else{
					tUCMmap.nodes -> any(n|path.pathBody.referencedStub.name=n.name).pred <- tUCMmap.nodes -> any(n|path.startPoint.name=n.name).succ; 
				}
			}
		}
		--Node connections
		tUCMmap.connections <- tUCMmap.nodes ->   flatten() -> collect(of|of.succ) -> flatten();
		
		tUCMmap.id <- thisModule.nextId().toString();
		tUCMmap.name <- sUCMmap.turnGetLongestName();
	}
}