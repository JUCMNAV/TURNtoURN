module Turn2Urn;
-- paths to metamodels for content assist
--@path Turn=/ATLProject/Metamodels/Turn.ecore
--@path Urn=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

create OUT : Urn from IN : Turn;

--This helper initializes the value of id
-- CONTEXT: thisModule
-- RETURN: Integer

uses ConnectNodes;

helper def: id : Integer = 0;

-- This helper creates an increment method for id
-- CONTEXT: Integer
-- RETURN: Integer
helper context Integer def : inc() : Integer = self + 1;

-- This helper checks if metadata already exists for a given parameter
-- CONTEXT: Turn!URNmodelElement
-- RETURN: Boolean
helper context Turn!URNmodelElement def: metadataExists(param : String) : Boolean = 
	self.metadata -> select(m| m.name.indexOf(param) <> -1 ) -> notEmpty();

helper def: nodeCollector : Sequence(OclAny) = Sequence(OclAny) ;

helper def: counter : Integer = 1;

helper def: nodeCounter : Integer = 1;

helper def: orForkMap : Map(Turn!OrFork, Urn!OrFork) = Map{};

helper def: connectMap : Map(Turn!Connect, Urn!Connect) = Map{};

helper def: orForkNodeConnCounter : Integer = 1;

helper def: andForkMap : Map(Turn!OrFork, Urn!OrFork) = Map{};

helper def: endPointMap : Map(Turn!EndPoint, Urn!EndPoint) = Map{};

helper def: timerMap : Map(Turn!Timer, Urn!Timer) = Map{};

helper def: stubMap : Map(Turn!Stub, Urn!Stub) = Map{};

helper def: andForkNodeConnCounter : Integer = 1;

helper context Turn!URNspec def: getActorElements() : Sequence(OclAny) = 
	self.actors -> collect(actor|actor.elems) -> flatten();

rule URNspec2URNspec{
	from 
		sURNspec: Turn!URNspec
	to
		tURNspec: Urn!URNspec (
			name <- sURNspec.name,
			metadata <- sURNspec.metadata,
			grlspec <- tGRLSpec,
			ucmspec <- tUcmspec,
			urnLinks <- sURNspec.urnlinks,
			urndef <- tURNdef
		),
		tURNdef: Urn!URNdefinition (
			specDiagrams <- tGRLSpecDiag,
			specDiagrams <- sURNspec.ucmMaps -> collect(m|thisModule.resolveTemp(m,'tUCMmap')),
			concerns <- sURNspec.concerns
		),
		tGRLSpec: Urn!GRLspec (
			actors <- sURNspec.actors,
			intElements <- sURNspec.getActorElements() -> select(e|e.type.toString() <> 'belief'),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tCont')),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tDecomp')),
			links <- sURNspec.getActorElements() -> collect(e|e.linksSrc) -> flatten() -> collect(l|thisModule.resolveTemp(l,'tDep')),
			groups <- sURNspec.stratGroups,
			strategies <- sURNspec.strategies,
			contributionGroups <- sURNspec.contribContextGroups,
			contributionContexts <- sURNspec.contribContexts,
			KPIConversion <- sURNspec.indConversions -> select(c|c.oclIsTypeOf(Turn!QualToQMappings))
		),
		tGRLSpecDiag: Urn!GRLGraph (
		  	nodes <- sURNspec.getActorElements() -> collect(e| thisModule.resolveTemp(e, 'tIntElemRef')),
			nodes <- Urn!Belief.allInstances(),
			contRefs <- sURNspec.actors -> collect(a| thisModule.resolveTemp(a, 'tActorRef')),
		    connections <- sURNspec.getActorElements() ->  collect(l|l.linksSrc) -> flatten() -> collect(m| thisModule.resolveTemp(m,'tLinkRef')),  
	    	connections <- sURNspec.getActorElements() ->  collect(m| thisModule.resolveTemp(m,'tBeliefLink')) 
		),
		tUcmspec: Urn!UCMspec (
		
		)
	do{
		if(sURNspec.metadata -> select(m| (m.name.indexOf('TURN-URN') <> -1 and m.name.indexOf('nextGlobalID') <> -1)) -> notEmpty()){
	 		thisModule.id <- sURNspec.metadata -> any(m|m.name = 'TURN-URN-nextGlobalID').value.toInteger();
		}
		
		
		tURNdef.components <- Urn!Component.allInstances();
		tURNdef.responsibilities <- Urn!Responsibility.allInstances();
		
		if (not sURNspec.info.oclIsUndefined()){
			tURNspec.description <- sURNspec.info.description;
			tURNspec.author <- sURNspec.info.author;
			tURNspec.created <- sURNspec.info.created;
			tURNspec.modified <- sURNspec.info.modified;
			tURNspec.specVersion <- sURNspec.info.specVersion;
			tURNspec.urnVersion <- sURNspec.info.urnVersion; 
		}
		
		tURNspec.nextGlobalID <- thisModule.id.toString();
	}
}

rule IntElements2IntElements{
	from 
		s: Turn!IntentionalElement (s.type.toString() <> 'belief')
	to 
		tIntElem: Urn!IntentionalElement (
		   linksSrc <- s.linksSrc
		),
		tIntElemRef: Urn!IntentionalElementRef (
			def <- tIntElem,
			succ <- s.linksSrc -> collect(c|thisModule.resolveTemp(c,'tLinkRef'))
			
		)
	 do{
		 thisModule.id <- thisModule.id.inc();
		 tIntElemRef.id <- thisModule.id.toString();
		 tIntElemRef.name <- 'IntentionalElementRef'+tIntElemRef.id;
		 
		 if(not s.longName.longname.oclIsUndefined())
			tIntElemRef.name <- s.longName.longname;
		 else
			tIntElemRef.name <- s.name;
		 
		 if(Turn!Decomposition -> allInstances() -> select(d|d.dest=s) -> size() > 0)
		 	tIntElem.decompositionType <-Turn!Decomposition -> allInstances() -> select(d|d.dest=s) -> collect(a|a.decompositionType.toString().substring(1,1).toUpper()+a.decompositionType.toString().substring(2,a.decompositionType.toString().size()))-> first();
		 
		 tIntElem.type <- s.type.toString().substring(1,1).toUpper()+s.type.toString().substring(2,s.type.toString().size());
		 
		 --Added because the default value in enum is considered always.
		 if(s.importance.toString().equals('none'))
			tIntElem.importanceQuantitative <- s.importanceQuantitative;
		else
			tIntElem.importance <- s.importance.toString().substring(1,1).toUpper()+s.importance.toString().substring(2,s.importance.toString().size());
		
	 	 	if(not s.longName.longname.oclIsUndefined())
				tIntElem.name <- s.longName.longname;
			else
				tIntElem.name <- s.name;
	 	 	
		 	thisModule.id <- thisModule.id.inc();
		 	tIntElem.id <- thisModule.id.toString();
		 	tIntElem.metadata <- thisModule.addMetadata(s.name);
	}
}

rule Actor2Actor{
	from 
		s: Turn!Actor
	to 
		tActor: Urn!Actor (
			importanceQuantitative <- s.importanceQuantitative
		),
		tActorRef: Urn!ActorRef (
			contDef <- tActor,
			nodes <- s.elems -> collect(e|thisModule.resolveTemp(e,'tIntElemRef')),
			nodes <- s.elems -> collect(e|thisModule.resolveTemp(e,'tBelief')),
			label <- tCompLabel
		),
		tCompLabel: Urn!ComponentLabel()
	 do{
	 	if(not s.longName.longname.oclIsUndefined())
			tActor.name <- s.longName.longname;
		else
			tActor.name <- s.name;
	 	
	 	thisModule.id <- thisModule.id.inc();
	    tActor.id <- thisModule.id.toString();
	    
	 	thisModule.id <- thisModule.id.inc();
	    tActorRef.id <- thisModule.id.toString();
	    tActorRef.name <- 'ActorRef'+tActorRef.id;
	 }	
}


