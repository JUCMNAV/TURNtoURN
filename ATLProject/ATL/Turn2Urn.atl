module Turn2Urn;
-- paths to metamodels for content assist
--@path Turn=/ATLProject/Metamodels/Turn.ecore
--@path Urn=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

create OUT : Urn from IN : Turn;

uses Connect;
uses Create;
uses Process;

-- Contents:
--	 1/5 GLOBAL VARIABLES
--	 2/5 HELPERS
--	 3/5 CALLED RULES
--	 4/5 MATCHED RULES WITHOUT DO BLOCKS
--	 5/5 MATCHED RULES WITH DO BLOCKS

---------1/5 GLOBAL VARIABLES-----------------

helper def: id : Integer = 0;

helper def: connectMap : Map(Turn!Connect, Urn!Connect) = Map{};

helper def: endPointMap : Map(Turn!EndPoint, Urn!EndPoint) = Map{};

helper def: orForkNodeConnCounter : Integer = 1;

helper def: tUCMmap : Urn!UCMmap = OclUndefined;

--------------2/5 HELPERS---------------------

helper context Turn!Text def : asString() : String =
	self.content -> iterate(item; condition : String = '' | condition.concat(item));

helper context String def : capitalize(): String = 
	self.substring(1,1).toUpper() + self.substring(2, self.size());

helper context Integer def : inc() : Integer = self + 1;

helper context Urn!UCMmap def : getNode(turnNodeName: String) : OclAny = 
	self.nodes -> any(n|n.name=turnNodeName);

--This should only be called on TURN objects; I haven't been able to determine how to express that restriction using OCL, though.
helper context OclAny def : turnGetLongestName() : String = 
	if(not self.longName.oclIsUndefined()) then
		if(not self.longName.longname.oclIsUndefined()) then
			self.longName.longname
		else
			self.name	
		endif
	else
		self.name	
	endif;

helper context Turn!OrFork def : getPathBodies() : Turn!PathBody =
	self.body.regularBody -> collect(pb|pb.pathBody) -> flatten();

helper context Urn!UCMmap def : allRespDefsMatching(turnNodeName: String) : OclAny =
	self.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> select(r|r.respDef.name=turnNodeName) -> flatten();

helper context OclAny def : firstUnconnectedSucc() : OclAny =
	self.succ -> any(s|s.target.oclIsUndefined());

-----------------------3/5 CALLED RULES-----------------------------
------------(sorry, spirit of declarative programming)--------------

rule nextId(){
	do{
		thisModule.id <- thisModule.id.inc();
		thisModule.id;
	}
}

rule addPred(node: Turn!PathNode, predecessor: OclAny){
	do{
		if(predecessor.oclIsKindOf(Sequence(OclAny))){
			node.pred <- node.pred.union(predecessor);
		}
		else{
			node.pred <- node.pred.including(predecessor);	
		}
	}
}

rule addSucc(node: Turn!PathNode, successor: OclAny){
	do{
		if(successor.oclIsKindOf(Sequence(OclAny))){
			node.succ <- node.succ.union(successor);
		}
		else{
			node.succ <- node.succ.including(successor);	
		}
	}
}

rule contributionNumberToKeyword(quantitativeContribution: Integer){
	using{
		vContribution :	String = OclUndefined;
	}
	do{
		-- Dictionary. Had to use called rule as elseif is not supported in helpers
		
		if(quantitativeContribution <= -1)
			vContribution <- 'Hurt';
		else if(quantitativeContribution < -49)
			vContribution <- 'SomeNegative';
		else if(quantitativeContribution = -100)
			vContribution <- 'Break';
		else if(quantitativeContribution = 0)
			vContribution <- 'Unknown';
		else if(quantitativeContribution < 50)
			vContribution <- 'Help';
		else if(quantitativeContribution <= 99)
			vContribution <- 'SomePositive';
		else if(quantitativeContribution = 100)
			vContribution <- 'Make';
		else
			vContribution <- OclUndefined;
		
		vContribution;
	}
}

rule collectReferencedEnds(pathNodes: Sequence(Turn!PathNode)){
	do{
		pathNodes <- pathNodes -> flatten();
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.union(pathNodes -> collect(r|thisModule.resolveTemp(r, 'tRespRef')));
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.union(pathNodes -> collect(r|thisModule.resolveTemp(r, 'tOrJoin')));
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.union(pathNodes -> collect(r|thisModule.resolveTemp(r, 'tAndJoin')));
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.union(pathNodes -> collect(r|thisModule.resolveTemp(r, 'tFailPt')));
		thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.union(pathNodes -> collect(r|thisModule.resolveTemp(r, 'tWtPlace')));
	}
}

rule getUrnCompRef(obj: OclAny){
	using{
		vCompRef : Urn!ComponentRef = OclUndefined;
	}
	do{
		if(not obj.boundTo.oclIsUndefined()){
			if(not obj.boundTo.comp.oclIsUndefined()){
				vCompRef <- thisModule.resolveTemp(obj.boundTo.comp, 'tCompRef');
			}
			else{
				vCompRef <- thisModule.resolveTemp(obj.boundTo.comp2, 'tCompRef');
			}
		}
		else{
			vCompRef <- OclUndefined;	
		}
		
		vCompRef;
	}
}

rule getResponsibility(responsibilityName: String){
	do{
		Urn!Responsibility.allInstances() -> any(n|n.name=responsibilityName);	
	}
}

rule retrieveNode(node: Turn!PathNode){
	using{
		vRetrievedNode : Turn!PathNode = OclUndefined;
	}
	do{
		-- This is a rather obtuse approach but was necessary as multiple conditionals in retrieveNode was causing slow build times.
		-- I'm not sure how inefficient this approach is; if the system is running slowly, it may be worth looking at a different
		-- implementation of this rule.
		
		vRetrievedNode <- Sequence{thisModule.resolveTemp(node, 'tWtPlace')};
		vRetrievedNode <- vRetrievedNode.including(thisModule.resolveTemp(node, 'tFailPt'));
		vRetrievedNode <- vRetrievedNode.including(thisModule.resolveTemp(node, 'tRespRef'));
		vRetrievedNode <- vRetrievedNode.including(thisModule.resolveTemp(node, 'tTimer'));
		vRetrievedNode <- vRetrievedNode.including(thisModule.resolveTemp(node, 'tAndFork'));
		vRetrievedNode <- vRetrievedNode.including(thisModule.resolveTemp(node, 'tOrFork'));
		vRetrievedNode <- vRetrievedNode.including(thisModule.resolveTemp(node, 'tStub'));
		vRetrievedNode <- vRetrievedNode.including(thisModule.resolveTemp(node, 'tConnect'));
		vRetrievedNode <- vRetrievedNode -> any(e|not e.oclIsUndefined());
		
		if(vRetrievedNode.oclIsUndefined() and node.oclIsTypeOf(Turn!EndPoint)){
			vRetrievedNode <- thisModule.endPointMap.get(node);	
		}
		if(vRetrievedNode.oclIsUndefined()){
			if(node.oclIsTypeOf(Turn!Connect)){
				vRetrievedNode <- thisModule.connectMap.get(node);	
			}
			else{
				vRetrievedNode <- thisModule.tUCMmap.getNode(node.turnGetLongestName());
			}
		}
		
		if(not vRetrievedNode.oclIsUndefined()){
			if(vRetrievedNode.id='201'){
				--thisModule.debug('Node ' + vRetrievedNode.id + ' retrieved here');
				--thisModule.k.k; --randomly picked error generating case to track where events occur
			}
		}
		
		vRetrievedNode; --returns a single node, not a sequence
	}
}

rule handleForkJoin(fork: Urn!PathNode, connectingBody: Turn!PathBody, numberOfTerminatingNodes: Integer){
	using{
		vFirstPathNode : Turn!PathNode = OclUndefined;
		vNextNode : Turn!PathNode = fork;
		vEmptyPt : Urn!EmptyPoint = OclUndefined;
	}
	do{
		thisModule.collectReferencedEnds(connectingBody.pathNodes);
		thisModule.processPathEnd(connectingBody.pathEnd);
		
		if(numberOfTerminatingNodes = 1){
			vFirstPathNode <- connectingBody.pathNodes -> first();
			
			if(not vFirstPathNode.oclIsUndefined() and not vFirstPathNode.oclIsTypeOf(Turn!Connect)){
				if(not vFirstPathNode.name.oclIsUndefined()){
					vNextNode <- thisModule.retrieveNode(vFirstPathNode);
				}
			}
		}
		else if(numberOfTerminatingNodes = 2){
			if(fork.oclIsTypeOf(Urn!Stub) or fork.oclIsTypeOf(Urn!OrFork)){
				vNextNode <- thisModule.createOrJoin();
			}
			else if(fork.oclIsTypeOf(Urn!AndFork)){
				vNextNode <- thisModule.createAndJoin();
			}
		}
		
		vNextNode;
	}
}

-------------4/5 MATCHED RULES WITHOUT DO BLOCKS------------

rule Actor2Actor{
	from 
		s: Turn!Actor
	to 
		tActor: Urn!Actor (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			importanceQuantitative <- s.importanceQuantitative
		),
		tActorRef: Urn!ActorRef (
			id <- thisModule.nextId().toString(),
			name <- 'ActorRef' + tActorRef.id,
			contDef <- tActor,
			nodes <- s.elems -> collect(e|thisModule.resolveTemp(e, 'tIntElemRef')).union(s.elems -> collect(e|thisModule.resolveTemp(e, 'tBelief'))),
			label <- tCompLabel
		),
		tCompLabel: Urn!ComponentLabel()
}

rule AndFork2AndFork{
	from
		obj: Turn!AndFork
	using{
		vId : String = thisModule.nextId().toString();
		vObjName : String = obj.turnGetLongestName();
		
		vName : String = 
			if(vObjName.oclIsUndefined()) then
				'AndFork' + vId
			else
				vObjName
			endif;
		vLabel : Urn!Label =
			if(vObjName.oclIsUndefined()) then
				OclUndefined
			else
				thisModule.createLabel()
			endif;
	}
	to
		tAndFork: Urn!AndFork (
			id <- vId,
			name <- vName,
			label <- vLabel,
			diagram <- thisModule.tUCMmap,
			contRef <- thisModule.getUrnCompRef(obj)
		)
}

rule AndJoin2AndJoin{
	from 	
		s: Turn!AndJoin
	to
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel,
		tAndJoin: Urn!AndJoin(
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel,
			contRef <- thisModule.getUrnCompRef(s)
		)
}

rule Concern2Concern{
	from 
		s: Turn!Concern
	to 
		tConcern: Urn!Concern (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
		 	elements <- s.elements,
			--QUESTION: Turn!Concern has no property metadata; is this perhaps a logical error?
			--metadata <- s.metadata,
			condition <- s.condition
		)
}

rule Condition2Condition{
	from 
		s: Turn!Condition
	to 
		tCondition: Urn!Condition(
			expression <- s.expression.asString(),
			label <- s.expression.asString()
		)
	
}

rule Contribution2Contribution{
	from 
		s: Turn!Contribution (s.link.type.toString() <> 'belief')
	using{
		vIsQuantitativeContribution : Boolean = s.contribution.toString().equals('undefined');
	
		vContribution : String =
			if(vIsQuantitativeContribution) then
				thisModule.contributionNumberToKeyword(s.quantitativeContribution)
			else
				s.contribution.toString().capitalize()
			endif;

		vQuantitativeContribution : Integer =
			if(vIsQuantitativeContribution) then
				s.quantitativeContribution
			else
				OclUndefined
			endif;
	}
	to 
		tCont: Urn!Contribution (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(s.dest, 'tIntElem'),
			refs <- tLinkRef,
	 		correlation <- s.correlation,
			contribution <- vContribution,
			quantitativeContribution <- vQuantitativeContribution
		),
		tLinkRef: Urn!LinkRef (
			link <- tCont,
			target <- thisModule.resolveTemp(s.dest, 'tIntElemRef')
		)
}

rule ContributionChange2ContributionChange{
	from
		s: Turn!ContributionChange
	using{
		vNewContr : String = 
			if(not s.newContribution.toString().equals('undefined')) then
				s.newContribution.toString().capitalize()
			else
				OclUndefined
			endif;		
	}
	to
		t: Urn!ContributionChange (
			contribution <- s.contribution,
			newQuantitativeContribution <- s.newQuantitativeContribution,
			newContribution <- s.newContribution
		)
}

rule ContributionContext2ContributionContext{
	from
		s: Turn!ContributionContext
	to
		tContContext: Urn!ContributionContext (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			changes <- s.changes,
			includedContexts <- s.includedContexts
		)
}

rule ContributionContextGroup2ContributionContextGroup{
	from
		s: Turn!ContributionContextGroup
	to
		tContribGroups: Urn!ContributionContextGroup (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			contribs <- s.contribs.including(s.contrib)
		)
}
	
rule Decomposition2Decomposition{
	from 
		s: Turn!Decomposition (s.link.type.toString() <> 'belief')
	to 
		tDecomp: Urn!Decomposition (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(s.dest, 'tIntElem'),
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef (
			link <- tDecomp,
			target <- thisModule.resolveTemp(s.dest, 'tIntElemRef')
		)
}

rule Dependency2Dependency{
	from 
		s: Turn!Dependency (s.link.type.toString() <> 'belief')
	to 
		tDep: Urn!Dependency (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
		 	dest <- thisModule.resolveTemp(s.dest, 'tIntElem'),
			refs <- tLinkRef
		),
		tLinkRef: Urn!LinkRef (
			link <- tDep,
			target <- thisModule.resolveTemp(s.dest, 'tIntElemRef')
		)
}

rule Evaluation2Evaluation{
	from
		s: Turn!Evaluation
	using{
		vKpiEvalValueSet : Urn!KPIEvalValueSet =
			if(s.conversion.oclIsTypeOf(Turn!QualToQMappings)) then
				thisModule.createQMapKpiEvalValueSet(s.conversion)
			else
				if(s.conversion.oclIsTypeOf(Turn!LinearConversion)) then
					thisModule.createKpiEvalValueSet(s.conversion)
				else
					OclUndefined
				endif
			endif;
	}
 	to 
		tEval : Urn!Evaluation (
		 	exceeds <- s.exceeds,
		 	intElement <- s.intElement,
			evaluation <- s.evaluation,
			qualitativeEvaluation <- s.qualitativeEvaluation.toString().capitalize(),
			kpiEvalValueSet <- vKpiEvalValueSet
		)
}

rule FailurePoint2FailurePoint{
	from		
		s: Turn!FailurePoint
	using{
		vExpression : String = 
			if(not s.failLabel.oclIsUndefined()) then
				s.failLabel.failure
			else
				OclUndefined
			endif;
	}
	to
		tNodeConn: Urn!NodeConnection (
			condition <- s.condition
		),
		tNodeLabel: Urn!NodeLabel(),
		tFailPt: Urn!FailurePoint (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel,
			expression <- vExpression
		)
}

rule Metadata2Metadata{
	from 
		sourceMetadata: Turn!Metadata
	to 
		targetMetadata: Urn!Metadata(
			name <- sourceMetadata.name
		)
}

rule OrFork2OrFork{
	from
		obj: Turn!OrFork
	using{
		vId : String = thisModule.nextId().toString();
		vObjName : String = obj.turnGetLongestName();
		
		vName : String = 
			if(vObjName.oclIsUndefined()) then
				'OrFork' + vId
			else
				vObjName
			endif;
		vLabel : Urn!Label =
			if(vObjName.oclIsUndefined()) then
				OclUndefined
			else
				thisModule.createLabel()
			endif;		
	}
	to
		tOrFork: Urn!OrFork (
			id <- vId,
			name <- vName,
			label <- vLabel,
			diagram <- thisModule.tUCMmap,
			contRef <- thisModule.getUrnCompRef(obj)
		)
}

rule OrJoin2OrJoin{
	from 	
		s: Turn!OrJoin
	to
		tNodeConn: Urn!NodeConnection,
		tNodeLabel: Urn!NodeLabel,
		tOrJoin: Urn!OrJoin(
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel,
			contRef <- thisModule.getUrnCompRef(s)
		)
}

rule PluginBinding2PluginBinding{
	from 
		s:Turn!PluginBinding	
	to
		tPluginBinding: Urn!PluginBinding (
			-- this could be other way round, binding could be inBinding or OutBinding and vice-versa.
			in <- s.bindings -> collect(b|thisModule.resolveTemp(b, 'tInBinding')).including(thisModule.resolveTemp(s.binding, 'tInBinding')),
			out <- s.bindings -> collect(b|thisModule.resolveTemp(b, 'tOutBinding')).including(thisModule.resolveTemp(s.binding, 'tOutBinding')),
			plugin <- thisModule.resolveTemp(s.map, 'tUCMmap'),
			precondition <- thisModule.resolveTemp(s.condition, 'tCondition'),
			replicationFactor <- s.replication
		)
}

rule StartPoint2StartPoint{
	from
		s: Turn!StartPoint
	using{
		vFailureKind : String =
			if(not s.failKind.oclIsUndefined()) then
				s.failKind.toString().capitalize()
			else
				OclUndefined
			endif;
	}
	to
		tNodeConn: Urn!NodeConnection(),
		tNodeLabel: Urn!NodeLabel(),
		tStartPoint: Urn!StartPoint (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel,
			diagram <- s.path.map,
			precondition <- s.precondition,
			contRef <- thisModule.getUrnCompRef(s),
			failureKind <- vFailureKind
		)
}

rule Strategies2Strategies{
	from
		s: Turn!EvaluationStrategy
	using{
		vAuthor : String =
			if(not s.info.oclIsUndefined()) then
				s.info.author
			else
				OclUndefined
			endif;
	}
	to
		tStrategies: Urn!EvaluationStrategy (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			evaluations <- s.evaluations,
			includedStrategies <- s.includedStrategies,
			author <- vAuthor
		)
}

rule StrategiesGroup2StrategiesGroup{
	from
		s: Turn!StrategiesGroup
	to
		tStrategiesGroup: Urn!StrategiesGroup (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			strategies <- s.evalStrategies.including(s.evalStrategy)
		)
	
}

rule Stub2Stub{
	from
		stubObj: Turn!Stub
	using{
		vBlocking : Boolean = stubObj.stubType.toString() = 'blocking';
		vSynchronization : Boolean = vBlocking or stubObj.stubType.toString() = 'synchronizing';
		vDynamic : Boolean = 
			if(vSynchronization) then
				true
			else
				if(not stubObj.params.oclIsUndefined()) then
					stubObj.params.plugin -> flatten() -> size() >= 2
				else
					OclUndefined
				endif
			endif;
	}
	to
		tStub: Urn!Stub (
			id <- thisModule.nextId().toString(),
			name <- stubObj.turnGetLongestName(),
			diagram <- thisModule.tUCMmap,
			label <- tNodeLabel,
			blocking <- vBlocking,
			synchronization <- vSynchronization,
			contRef <- thisModule.getUrnCompRef(stubObj),
			dynamic <- vDynamic
		),
		tNodeLabel: Urn!NodeLabel()
}

rule QMapping2QMapping{
	from 
		s: Turn!QualToQMapping
	to
		tQMapping: Urn!QualitativeMapping (
			realWorldLabel <- s.realWorldLabel,
			exceeds	<- s.exceeds,
			evaluation <- s.evaluation,
			qualitativeEvaluation <- s.qualitativeEvaluation.toString().capitalize()
		)
}

rule QMappings2QMappings{
	from
		s: Turn!QualToQMappings
	to
		tQMappings: Urn!QualitativeMappings (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			mapping <- s.mappings
		)
}

rule Responsibility2Responsibility{
	from
		s: Turn!RespRef
	using{
		vResponsibility : Urn!Responsibility = 	
			if(thisModule.getResponsibility(s.turnGetLongestName()).oclIsUndefined()) then
				thisModule.createResponsibility(s)
			else
				thisModule.getResponsibility(s.turnGetLongestName())
			endif;
	}
	to
		tRespRef: Urn!RespRef (
			id <- thisModule.nextId().toString(),
			name <- 'RespRef' + tRespRef.id,
			succ <- tNodeConn,
			label <- tNodeLabel,
			respDef <- vResponsibility,
			contRef <- thisModule.getUrnCompRef(s)
		),
		tNodeConn: Urn!NodeConnection(),
		tNodeLabel: Urn!NodeLabel()
}

rule Timer2Timer{
	from
		timerObj: Turn!Timer
	to
		tTimer: Urn!Timer(
			id <- thisModule.nextId().toString(),
			name <- timerObj.turnGetLongestName(),
			succ <- tNodeConn,
			diagram <- thisModule.tUCMmap,
			label <- tNodeLabel,
			waitType <- timerObj.kind.toString().capitalize(),
			contRef <- thisModule.getUrnCompRef(timerObj)
		),
		tNodeConn: Urn!NodeConnection(
			condition <- timerObj.condition
		),
		tNodeLabel: Urn!NodeLabel()
}

rule URNlink2URNlink{
	from 
		s: Turn!URNlink
	to 
		tCon: Urn!URNlink (
			type <- s.type,
			fromElem <- s.fromElem,
			toElem <- s.toElem
		)
}

rule WaitingPlace2WaitingPlace{
	from		
		s: Turn!WaitingPlace
	to
		tNodeConn: Urn!NodeConnection (
			condition <- s.condition
		),
		tNodeLabel: Urn!NodeLabel(),
		tWtPlace: Urn!WaitingPlace (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			succ <- tNodeConn,
			label <- tNodeLabel,
			waitType <- s.kind.toString().capitalize()
		)
}

----------5/5 MATCHED RULES WITH DO BLOCKS----------------

rule Component2Component{
	from 
		s: Turn!ComponentRef(Urn!Component.allInstances() -> any(c|c.name = s.name).oclIsUndefined())
	using{
		vExistingComponent : Urn!Component = Urn!Component.allInstances() -> any(c|c.name=s.name);
		vRetrievedComponent : Urn!Component =
			if(vExistingComponent.oclIsUndefined()) then
				thisModule.createComponent(s)
			else
				vExistingComponent
			endif;
	}
	to
		tCompRef: Urn!ComponentRef(
			id <- thisModule.nextId().toString(),
			name <- 'ComponentRef' + tCompRef.id,
			label <- tCompLabel,
			diagram <- s.map,
			contDef <- vRetrievedComponent,
			parent <- thisModule.getUrnCompRef(s)
		),
		tCompLabel: Urn!ComponentLabel()
	do{
		if(not s.boundTo.oclIsUndefined()){
			if(not s.boundTo.comp.oclIsUndefined()){
				tCompRef.parent <- Urn!Component.allInstances() -> any(n|s.boundTo.comp.name=n.name).contRefs -> any(r|r.diagram = s.map);
			}
			else{
				tCompRef.parent <- Urn!Component.allInstances() -> any(n|s.boundTo.comp2.name=n.name).contRefs -> any(r|r.diagram = s.map);
			}
		}
		
		tCompRef.contDef.protected <- s.protected;
		
		for(elem in (s.elements.including(s.element)) -> select(e|e.oclIsTypeOf(Turn!LongBoundElement))){
			tCompRef.metadata <- tCompRef.metadata.including(thisModule.createMetadata('from', elem.from));
			tCompRef.metadata <- tCompRef.metadata.including(thisModule.createMetadata('to', elem.to));
		}
	}
}

rule IntElements2Belief{
	from
		s: Turn!IntentionalElement(s.type.toString() = 'belief')
	to 
	 	tBelief: Urn!Belief(
	 		id <- thisModule.nextId().toString(),
	 		name <- s.name,
			description <- s.name,
			succ <- tBeliefLink
	 	),
		tBeliefLink: Urn!BeliefLink(
			target <- s.linksSrc -> collect(l|l.dest) -> flatten() -> collect(l|thisModule.resolveTemp(l, 'tIntElemRef')) -> first()
		)
	do{
		for(link in s.linksSrc -> excluding(s.linksSrc -> first())){
			tBelief.succ <- thisModule.createBeliefLink(link);
	 	}	
	}
}

rule IntElements2IntElements{
	from 
		s: Turn!IntentionalElement(s.type.toString() <> 'belief')
	using{
		vDecomp : Turn!Decomposition = Turn!Decomposition -> allInstances() -> any(d|d.dest=s);
		vDecompType : String = 
			if(not vDecomp.oclIsUndefined()) then
				vDecomp.decompositionType.toString().capitalize()
			else
				OclUndefined
			endif;
		vImportance : String =
			if(s.importance.toString().toLower().equals('none')) then
				OclUndefined
			else
				s.importance.toString().capitalize()
			endif;
	}
	to 
		tIntElemRef: Urn!IntentionalElementRef (
			id <- thisModule.nextId().toString(),
			name <- 'IntentionalElementRef'+tIntElemRef.id,
			def <- tIntElem,
			succ <- s.linksSrc -> collect(c|thisModule.resolveTemp(c, 'tLinkRef'))
		),
		tIntElem: Urn!IntentionalElement (
			id <- thisModule.nextId().toString(),
			name <- s.turnGetLongestName(),
			linksSrc <- s.linksSrc,
			decompositionType <- vDecompType,
			importanceQuantitative <- s.importanceQuantitative,
			importance <- vImportance,
			metadata <- thisModule.createMetadata('TURN-URN-NAME', s.name)
		)
	do{
		if(Turn!Decomposition -> allInstances() -> select(d|d.dest=s) -> size() > 0){
			tIntElem.decompositionType <-Turn!Decomposition -> allInstances() -> select(d|d.dest=s) -> collect(a|a.decompositionType.toString().substring(1,1).toUpper()+a.decompositionType.toString().substring(2,a.decompositionType.toString().size()))-> first();
		}
		if(s.type.toString() = 'resource'){
			tIntElem.type <- 'Ressource';
		}
		else{
			tIntElem.type <- s.type.toString().capitalize();
		}
		 
		 --Added because the default value in enum is considered always.
		if(s.importance.toString().equals('high') and s.importanceQuantitative <> 0){
			tIntElem.importanceQuantitative <- s.importanceQuantitative;
		}
		else{
			tIntElem.importance <- s.importance.toString().capitalize();
		}
	}
}

rule UCMmap2UCMmap{
	from
		sUCMmap: Turn!UCMmap
	to
		tUCMmap: Urn!UCMmap (
			id <- thisModule.nextId().toString(),
			name <- sUCMmap.turnGetLongestName(),
			contRefs <- sUCMmap.components -> collect(c|thisModule.resolveTemp(c, 'tCompRef')),
			nodes <- sUCMmap.paths -> flatten() -> collect(p|p.startPoint) -> flatten() -> collect(p|thisModule.resolveTemp(p, 'tStartPoint')),
			connections <- sUCMmap.paths -> flatten() -> collect(p|p.startPoint) -> flatten() -> collect(p|thisModule.resolveTemp(p, 'tNodeConn'))
		)
	do{
		thisModule.processUCMmap(tUCMmap, sUCMmap.paths);
	}
}

rule InBinding2InBinding{
	from
		s: Turn!InBinding
	to
		tInBinding: Urn!InBinding()
	do{
		thisModule.processBinding(s, tInBinding);
		tInBinding.startPoint <- thisModule.resolveTemp(s.mapStart, 'tStartPoint');
	}
}

rule OutBinding2OutBinding{
	from
		s: Turn!OutBinding
	to
		tOutBinding: Urn!OutBinding()
	do{
		thisModule.processBinding(s, tOutBinding);
		tOutBinding.endPoint <- thisModule.retrieveNode(s.mapEnd);
	}
}

rule URNspec2URNspec{
	from 
		sURNspec: Turn!URNspec
	using{
		vElements : Sequence(Turn!IntentionalElement) = sURNspec.actors -> collect(actor|actor.elems) -> flatten();	
		vAllIntElements : Sequence(Turn!IntentionalElement) = vElements -> select(e|e.type.toString() <> 'belief');
		vIntElemRefs : Sequence(Urn!IntentionalElementRef) = vElements -> collect(e| thisModule.resolveTemp(e, 'tIntElemRef'));
		vBeliefs : Sequence(Urn!Belief) = vElements -> select(e|e.type.toString() = 'belief') -> collect(b| thisModule.resolveTemp(b, 'tBelief'));
			
		vLinksSrc : Sequence(Turn!ElementLink) = vElements -> collect(e|e.linksSrc) -> flatten();
		vContributions : Sequence(Urn!Contribution) = vLinksSrc -> collect(l|thisModule.resolveTemp(l, 'tCont'));
		vDecompositions : Sequence(Urn!Decomposition) = vLinksSrc -> collect(l|thisModule.resolveTemp(l, 'tDecomp'));
		vDependencies : Sequence(Urn!Dependency) = vLinksSrc -> collect(l|thisModule.resolveTemp(l, 'tDep'));
		
		vLinkRefs : Sequence(Urn!LinkRef) = vLinksSrc -> collect(m| thisModule.resolveTemp(m, 'tLinkRef'));
	}
	to
		tURNspec: Urn!URNspec(
			name <- sURNspec.name,
			metadata <- sURNspec.metadata,
			grlspec <- tGRLspec,
			ucmspec <- tUCMspec,
			urnLinks <- sURNspec.urnlinks,
			urndef <- tURNdef
		),
		tURNdef: Urn!URNdefinition(
			specDiagrams <- Sequence{tGRLSpecDiag}.union(sURNspec.ucmMaps -> collect(m|thisModule.resolveTemp(m, 'tUCMmap'))),
			concerns <- sURNspec.concerns,
			components <- Urn!Component.allInstances(),
			responsibilities <- Urn!Responsibility.allInstances()
		),
		tGRLspec: Urn!GRLspec(
			actors <- sURNspec.actors,
			intElements <- vAllIntElements -> collect(i|thisModule.resolveTemp(i, 'tIntElem')),
			groups <- sURNspec.stratGroups,
			strategies <- sURNspec.strategies,
			contributionGroups <- sURNspec.contribContextGroups,
			contributionContexts <- sURNspec.contribContexts,
			KPIConversion <- sURNspec.indConversions -> select(c|c.oclIsTypeOf(Turn!QualToQMappings)),
			links <- vContributions.union(vDecompositions).union(vDependencies)
		),
		tGRLSpecDiag: Urn!GRLGraph(
		 	nodes <- vIntElemRefs.union(vBeliefs),
			contRefs <- sURNspec.actors -> collect(a| thisModule.resolveTemp(a, 'tActorRef')),
			connections <- vLinkRefs.union(vBeliefs -> collect(b|b.succ))
		),
		tUCMspec: Urn!UCMspec()
	do{
		if(not sURNspec.info.oclIsUndefined()){
			tURNspec.description <- sURNspec.info.description;
			tURNspec.author <- sURNspec.info.author;
			tURNspec.created <- sURNspec.info.created;
			tURNspec.modified <- sURNspec.info.modified;
			tURNspec.specVersion <- sURNspec.info.specVersion;
			tURNspec.urnVersion <- sURNspec.info.urnVersion; 
		}
		
		if(not sURNspec.metadata -> any(m|m.name='TURN-URN-nextGlobalID').oclIsUndefined()){
	 		thisModule.id <- sURNspec.metadata -> any(m|m.name='TURN-URN-nextGlobalID').value.toInteger();
		}
		
		tURNspec.nextGlobalID <- thisModule.id.toString();
	}
}
