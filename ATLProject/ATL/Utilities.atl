-------------------------------------
-- TURN2URN
-------------------------------------
-- Author: Ruchika Kumar, 2016
-------------------------------------
-- Edited by: Saahil Hamayun, 2019
-------------------------------------

module Utilities;

create OUT : Urn from IN : Turn;

------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------
--	File: Turn2Urn.atl
------------------------------------------------------------------
--	Description:
--		Contains all methods used by the other files that don't
--		neatly fit into their categories. This file contains
--		various dictionaries, helpers, and called rules that
--		are used in the Turn2Urn transformation.
------------------------------------------------------------------
--	Contents
--		1/3 DICTIONARIES
--		2/3 HELPERS
--		3/3 CALLED RULES
------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------

---------------------------1/3 DICTIONARIES---------------------------
-- Dictionaries used to help readability of their calling methods.
----------------------------------------------------------------------

rule dictContributionNumberToKeyword(vQuantitativeContribution: Integer){
	using{
		vContribution :	String = OclUndefined;
	}
	do{
		-- Dictionary. Had to use called rule as elseif is not supported in helpers
		
		if(vQuantitativeContribution <= -1)
			vContribution <- 'Hurt';
		else if(vQuantitativeContribution < -49)
			vContribution <- 'SomeNegative';
		else if(vQuantitativeContribution = -100)
			vContribution <- 'Break';
		else if(vQuantitativeContribution = 0)
			vContribution <- 'Unknown';
		else if(vQuantitativeContribution < 50)
			vContribution <- 'Help';
		else if(vQuantitativeContribution <= 99)
			vContribution <- 'SomePositive';
		else if(vQuantitativeContribution = 100)
			vContribution <- 'Make';
		else
			vContribution <- OclUndefined;
		
		vContribution;
	}
}

rule dictContributionKeywordToNumber(vKeyword: String){
	using{
		vQuantitativeContribution : Integer = OclUndefined;	
	}
	do{
		if(vKeyword.equals('Make'))
			vQuantitativeContribution <- 100;
		else if(vKeyword.equals('Hurt'))
			vQuantitativeContribution <- -25;
		else if(vKeyword.equals('Break'))
			vQuantitativeContribution <- -100;
		else if(vKeyword.equals('SomePositive'))
			vQuantitativeContribution <- 50;
		else if(vKeyword.equals('SomeNegative'))
			vQuantitativeContribution <- -50;
		else if(vKeyword.equals('Help'))
			vQuantitativeContribution <- 25;
		else
			vQuantitativeContribution <- OclUndefined;
		
		vQuantitativeContribution;
	}
}

------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------2/3 HELPERS----------------------------------------
-- Various helper methods that are used to make reading logic in other rules more clear.
-- There are likely ways to improve on these to make the rules even more readable.
-------------------------------------------------------------------------------------------

helper context Turn!Text def : asString() : String =
	self.content -> iterate(item; condition : String = '' | condition.concat(item));

helper context String def : capitalize(): String = 
	self.substring(1,1).toUpper() + self.substring(2, self.size());

helper context Integer def : inc() : Integer = self + 1;

--This should only be called on TURN objects; I'm not sure how to do that using OCL.
helper context OclAny def : turnGetLongestName() : String = 
	if(self.longName.isDefined()) then
		if(self.longName.longname.isDefined()) then
			self.longName.longname
		else
			self.name	
		endif
	else
		self.name	
	endif;

helper context OclAny def : isDefined() : Boolean =
	not self.oclIsUndefined();

helper context Urn!PathNode def : nextFreeConnection() : Urn!NodeConnection =
	self.succ -> any(s|not s.target.isDefined());

helper context Urn!PathNode def : isAlreadyConnectedTo(tPathNode: Urn!PathNode) : Boolean =
	self.succ -> any(s|s.target=tPathNode).isDefined();

helper context Urn!PathNode def : isJoin() : Boolean =
	self.oclIsTypeOf(Urn!OrJoin) or self.oclIsTypeOf(Urn!AndJoin);

helper context Urn!PathNode def : hasSuccessors() : Boolean =
	self.succ -> notEmpty();

helper context Urn!PathNode def : hasPredecessors() : Boolean =
	self.pred -> notEmpty();

helper context Urn!PathNode def : connectionWith(tPathNode: Urn!PathNode) : Urn!NodeConnection =
	self.succ -> any(s|s.target=tPathNode);

helper context Urn!PathNode def : hasFreeConnection() : Boolean =
	self.nextFreeConnection().isDefined();

helper context Turn!Stub def : isBlocking() : Boolean = 
	self.stubType.toString() = 'blocking';

helper context Turn!Stub def : isSynchronizing() : Boolean = 
	self.stubType.toString() = 'blocking' or self.stubType.toString() = 'synchronizing';

helper context Turn!Stub def : isDynamic() : Boolean = 
	if(self.isSynchronizing()) then
		self.isSynchronizing()
	else
		if(self.params.isDefined()) then
			self.params.plugin -> flatten() -> size() >= 2
		else
			false
		endif
	endif;

helper context Turn!ComponentRef def : getKind() : String =
	if(self.kind.toString() = 'parent') then
		OclUndefined
	else
		if(self.kind.isDefined()) then
			 self.kind.toString().capitalize()
		else
			'Team'
		endif
	endif;

helper context Turn!ComponentRef def : getBoundTo() : Urn!Component =
	if(self.boundTo.isDefined()) then
		if(self.boundTo.comp.isDefined()) then
			Urn!Component.allInstances() -> any(n|self.boundTo.comp.name=n.name).contRefs -> any(r|r.diagram = self.map)
		else
			Urn!Component.allInstances() -> any(n|self.boundTo.comp2.name=n.name).contRefs -> any(r|r.diagram = self.map)
		endif
	else
		OclUndefined
	endif;

helper context Turn!StartPoint def : getFailKind() : String =
	if(self.failKind.isDefined()) then
		self.failKind.toString().capitalize()
	else
		OclUndefined
	endif;
	
helper context Turn!FailurePoint def : getFailExpression() : String =
	if(self.failLabel.isDefined()) then
		self.failLabel.failure
	else
		OclUndefined
	endif;

helper context Turn!IntentionalElement def : getDecompositionType() : String =
	if(Turn!Decomposition -> allInstances() -> any(d|d.dest=self).isDefined()) then
		Turn!Decomposition -> allInstances() -> any(d|d.dest=self).decompositionType.toString().capitalize()
	else
		OclUndefined
	endif;

helper context Turn!IntentionalElement def : getImportance() : String =
	if(self.importance.toString().toLower().equals('none')) then
		OclUndefined
	else
		self.importance.toString().capitalize()
	endif;

helper context Turn!IntentionalElement def : getType() : String =
	if(self.type.toString() = 'resource') then
		'Ressource'
	else
		self.type.toString().capitalize()
	endif;

helper context Turn!AndFork def : getPathBodies() : Sequence(Urn!PathBody) = 
	self.pathbody;

helper context Turn!AndFork def : getConnectingBody() : Urn!PathBody = 
	self.connectingAndBody;

helper context Turn!OrFork def : getPathBodies() : Sequence(Urn!PathBody) = 
	if(self.body.isDefined()) then
		if(self.body.elseBody.isDefined()) then
			self.body.regularBody -> collect(rb|rb.pathBody) -> including(self.body.elseBody)
		else
			self.body.regularBody -> collect(rb|rb.pathBody)
		endif
	else
		Sequence {}
	endif;
	
helper context Turn!OrFork def : getConnectingBody() : Urn!PathBody = 
	self.connectingOrBody;

helper context Turn!Stub def : getPathBodies() : Sequence(Urn!PathBody) = 
	self.outPaths -> collect(op|op.path);

helper context Turn!Stub def : getConnectingBody() : Urn!PathBody = 
	self.connectingStubBody;

helper context Turn!Contribution def : getContributionType() : String =
	if(self.contribution.toString() = 'undefined') then
		thisModule.dictContributionNumberToKeyword(self.quantitativeContribution)
	else
		self.contribution.toString().capitalize()
	endif;

helper context Turn!Contribution def : getQuantitativeContribution() : Integer =
	thisModule.dictContributionKeywordToNumber(self.getContributionType());

helper context Turn!ContributionChange def : getNewContribution() : String =
	if(self.newContribution.toString() = 'undefined') then
		OclUndefined
	else
		self.newContribution.toString().capitalize()
	endif;

helper context Urn!PathNode def : getName(sNode: Turn!PathBodyNode) : String =
	if(sNode.turnGetLongestName().isDefined()) then
		sNode.turnGetLongestName()
	else
		self.oclType().name + self.id
	endif;

helper context Urn!GRLNode def : getName(sNode: Turn!URNmodelElement) : String =
	if(sNode.turnGetLongestName().isDefined()) then
		sNode.turnGetLongestName()
	else
		self.oclType().name + self.id
	endif;

helper context Turn!EvaluationStrategy def : getAuthor() : String =
	if(self.info.isDefined()) then
		self.info.author
	else
		OclUndefined
	endif;

helper context Turn!PluginBinding def : getInBindings() : Sequence(Urn!InBinding) =
	self.bindings.including(self.binding) -> collect(b|thisModule.resolveTemp(b, 'tInBinding'));

helper context Turn!PluginBinding def : getOutBindings() : Sequence(Urn!OutBinding) =
	self.bindings.including(self.binding) -> collect(b|thisModule.resolveTemp(b, 'tOutBinding'));

helper context Turn!Binding def : getBinding() : Turn!Binding =
	if(self.bindings.isDefined()) then
		self.bindings
	else
		self.binding
	endif;

helper context Turn!Binding def : getStub() : Urn!Stub =
	if(self.getBinding().stubParam.stub.isDefined()) then
		thisModule.getTargetNode(self.getBinding().stubParam.stub)
	else
		thisModule.getTargetNode(self.getBinding().stubParam.stubDec.stub)
	endif;

helper context Turn!URNspec def : getAuthor() : String =
	if(self.info.isDefined()) then
		self.info.author
	else
		OclUndefined
	endif;

helper context Turn!URNspec def : getElements() : Sequence(Turn!IntentionalElement) =
	self.actors -> collect(actor|actor.elems) -> flatten();

helper context Turn!URNspec def : getLinks() : Sequence(Turn!IntentionalElement) =
	self.getElements() -> collect(e|e.linksSrc) -> flatten();

helper context Turn!URNspec def : getTargetIntentionalElements() : Sequence(Urn!IntentionalElement) =
	self.getElements() -> select(e|e.type.toString() <> 'belief') -> collect(e|thisModule.resolveTemp(e, 'tIntentionalElement'));

helper context Turn!URNspec def : getTargetIntentionalElementRefs() : Sequence(Urn!IntentionalElementRef) =
	self.getElements() -> collect(e|thisModule.resolveTemp(e, 'tIntentionalElementRef'));

helper context Turn!URNspec def : getTargetContributions() : Sequence(Urn!Contribution) =
	self.getLinks() -> collect(l|thisModule.resolveTemp(l, 'tContribution'));

helper context Turn!URNspec def : getTargetDecompositions() : Sequence(Urn!Decomposition) =
	self.getLinks() -> collect(l|thisModule.resolveTemp(l, 'tDecomposition'));

helper context Turn!URNspec def : getTargetDependencies() : Sequence(Urn!Dependency) =
	self.getLinks() -> collect(l|thisModule.resolveTemp(l, 'tDependency'));

helper context Turn!URNspec def : getTargetLinks() : Sequence(Urn!ElementLink) =
	self.getTargetContributions().union(self.getTargetDecompositions()).union(self.getTargetDependencies());

helper context Turn!URNspec def : getTargetLinkRefs() : Sequence(Urn!LinkRef) =
	self.getLinks() -> collect(m| thisModule.resolveTemp(m, 'tLinkRef'));

helper context Turn!URNspec def : getTargetBeliefs() : Sequence(Urn!Belief) =
	self.getElements() -> select(e|e.type.toString() = 'belief') -> collect(b| thisModule.resolveTemp(b, 'tBelief'));

helper context Turn!Actor def : getNodes() : Sequence(Turn!GRLNode) =
	self.elems -> collect(e|thisModule.resolveTemp(e, 'tIntentionalElementRef')).union(self.elems -> collect(e|thisModule.resolveTemp(e, 'tBelief')));

------------------------------------------------------------------------------------------------------------------------------------

------------------3/3 CALLED RULES------------------
-- Called rules used in other parts of the code.
----------------------------------------------------

-- Adds thenode referenced by sBoundElement to the list of nodes for the input ComponentRef.
rule addBoundElementNodeToComponentRef(sBoundElement: Turn!BoundElement, tComponentRef: Urn!ComponentRef){
	using{
		tPathNode : Urn!PathNode = OclUndefined;
	}
	do{
		tPathNode <- thisModule.getTargetNode(sBoundElement.elem);
		
		if(not tPathNode.isDefined()){
			-- Undefined case here means that sElem.elem is a ComponentRef, as getTargetNode doesn't return ComponentRefs.
			-- As such, the node is a ComponentRef, and as it is in the list of elements belonging to sComponentRef, it is a child.
			tPathNode <- thisModule.resolveTemp(sBoundElement.elem, 'tComponentRef');
			tComponentRef.children <- tComponentRef.children.including(tPathNode);
		}
		else if(not tPathNode.contRef.isDefined() or tPathNode.contRef=tComponentRef.parent){
			tComponentRef.nodes <- tComponentRef.nodes.including(tPathNode);
		}
	}
}

-- Handles adding a connection pair to the stub index map. Required to cleanly handle the map as it is rather complex.
rule addConnectionToStubIndexMap(tFromNode: Urn!PathNode, tToNode: Urn!PathNode, vIndex: Integer){
	using{
		tExistingPairsAtIndex : Sequence(Sequence(Urn!PathNode)) =
			if(thisModule.stubIndexMap.get(vIndex).isDefined()) then
				thisModule.stubIndexMap.get(vIndex)
			else
				Sequence{}
			endif;
		tNewPair : Sequence(Urn!PathNode) = Sequence { tFromNode, tToNode };
	}
	do{
		-- Map is of the form Integer -> Sequence{{fromNode1, toNode1},...}
		thisModule.stubIndexMap <- thisModule.stubIndexMap.including(vIndex, tExistingPairsAtIndex.including(tNewPair));
	}
}

-- Adds the path between tFrom to tTo to the list of nodes for the input ComponentRef.
rule addLongBoundElementNodesToComponentRef(sLongBoundElement: Turn!LongBoundElement, tComponentRef: Urn!ComponentRef){
	using{
		tStartNode : Urn!PathNode = thisModule.getTargetNodeByName(sLongBoundElement.from);
		tEndNode : Urn!PathNode = thisModule.getTargetNodeByName(sLongBoundElement.to);
	}
	do{
		if(tStartNode.isDefined() and tEndNode.isDefined()){ -- unidirectional, tFrom must be before tTo
			tComponentRef.nodes <- thisModule.findPathBetweenNodes(tStartNode, tEndNode);
		}
	}
}

-- Collects various nodes and adds them to the node list of the UCMmap currently being processed.
rule collectPathBodyNodesAndEnds(sPathBody: Turn!PathBody){
	using{
		vTypesOfNodeToAdd : Sequence(String) = 
			Sequence { 
				'tRespRef', 'tAndJoin', 'tOrJoin', 
				'tWaitingPlace', 'tFailurePoint' 
			};
		sPathNodes : Sequence(Turn!PathNode) = sPathBody.pathNodes;
	}
	do{
		sPathNodes <- sPathNodes -> flatten();
		
		for(vTypeOfNodeToAdd in vTypesOfNodeToAdd){
			thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.union(sPathNodes -> collect(sPathNode|thisModule.resolveTemp(sPathNode, vTypeOfNodeToAdd)));
		}
		
		if(sPathBody.pathEnd.isDefined()){
			if(sPathBody.pathEnd.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(sPathBody.pathEnd.regularEnd.isDefined()){
					thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(thisModule.getTargetNode(sPathBody.pathEnd));
				}
			}
			else{
				thisModule.tUCMmap.nodes <- thisModule.tUCMmap.nodes.including(thisModule.getTargetNode(sPathBody.pathEnd));
			}
		}
	}
}

-- Connects two or more nodes in the order of the input sequence.
rule chainDirectConnect(tNodesToConnect: Sequence(Urn!PathNode)){
	using{
		tFromNode: Urn!PathNode = OclUndefined;
	}
	do{
		for(tToNode in tNodesToConnect){
			if(tFromNode.isDefined()){
				thisModule.directConnect(tFromNode, tToNode);
			}
			
			tFromNode <- tToNode;
		}
	}
}

-- Connects two nodes, handling the special case where an OrJoin can be used
-- to better represent the behavior being performed.
rule connect(tFromNode: Urn!PathNode, tToNode: Urn!PathNode){
	using{
		tJoin : Urn!OrJoin = OclUndefined;
		tEmptyPoint : Urn!EmptyPoint = OclUndefined;
	}
	do{
		if(tFromNode.isDefined() and tToNode.isDefined()){
			if(tToNode.hasPredecessors() 
					and not tFromNode.oclIsTypeOf(Urn!StartPoint) 
					and not tFromNode.oclIsTypeOf(Urn!Connect) 
					and not tToNode.isJoin()
			){
				-- If two nodes enter the same target, and that target is not a join, then we create an OrJoin
				-- as the target for all these connections and have this OrJoin enter that target instead.
				
				tJoin <- thisModule.joinAllPreds(tToNode);
				thisModule.chainDirectConnect(Sequence { tFromNode, tJoin, tToNode });
			}
			else{
				thisModule.directConnect(tFromNode, tToNode);
			}
		}
	}
}

-- Connect at some index of the set of predecessors of tToNode. If attempting to connect
-- at an index greater than currently available set of preds, just create a new connection.
-- (and so increase size of pred by 1)
rule connectAtTargetIndex(tFromNode: Urn!PathNode, tToNode: Urn!PathNode, vPredIndex: Integer){
	using{
		tOrJoin : Urn!OrJoin = OclUndefined;	
	}
	do{
		if(vPredIndex > tToNode.pred -> size()){
			-- If trying to connect at an index > existing predecessors, just create a new index.
			-- Note that this will not be precise if (vPredIndex > tToNode.pred -> size() + 1) as we are
			-- treating all indexes > currently available as simply 1 greater than the current value.
			
			thisModule.directConnect(tFromNode, tToNode);
		}
		else{
			-- OrJoin with whatever is connected to the current index.
			
			tOrJoin <- thisModule.createOrJoin();
			tToNode.pred -> at(vPredIndex).target <- tOrJoin;
			thisModule.chainDirectConnect(Sequence { tFromNode, tOrJoin, tToNode });
		}	
	}
}

--Connect two nodes, adding an empty point in between them.
rule connectWithEmptyPoint(tFromNode: Urn!PathNode, tToNode: Urn!PathNode){
	using{
		tEmptyPoint : Urn!EmptyPoint = thisModule.createEmptyPoint();
	}
	do{
		thisModule.chainDirectConnect(Sequence { tFromNode, tEmptyPoint, tToNode });
	}
}

-- Connects two nodes, creating a connection with an empty point in between if the connection already exists.
rule directConnect(tFromNode: Urn!PathNode, tToNode: Urn!PathNode){
	do{
		if(tFromNode.isDefined() and tToNode.isDefined()){
			if(tFromNode.connectionWith(tToNode).isDefined()){
				thisModule.connectWithEmptyPoint(tFromNode, tToNode);	
			}
			else{
				if(not tFromNode.hasFreeConnection() and not tFromNode.connectionWith(tToNode).isDefined()){
					thisModule.createNewConnection(tFromNode);
				}
				
				tToNode.pred <- tToNode.pred.including(tFromNode.nextFreeConnection());
			}
		}
	}
}

-- Find and return the path between tStartNode and tEndNode as a sequence of PathNodes.
rule findPathBetweenNodes(tStartNode: Urn!PathNode, tEndNode: Urn!PathNode){
	using{
		tResult : Sequence(Urn!PathNode) = Sequence{};
		tConnect : Urn!Connect = OclUndefined;
	}
	do{
		if(tStartNode=tEndNode){
			tResult <- tResult.including(tStartNode);
		}
		else if(tStartNode.succ -> isEmpty()){
			-- Node not found in this path
		}
		else{
			for(tCurrentNode in tStartNode.succ -> collect(s|s.target)){
				tResult <- tResult.union(thisModule.findPathBetweenNodes(tCurrentNode, tEndNode));
			}
		}
		
		if(tStartNode<>tEndNode and tResult -> notEmpty()){
			tResult <- tResult.including(tStartNode);
			tConnect <- tStartNode.pred -> collect(p|p.source) -> any(s|s.oclIsTypeOf(Urn!Connect));
			
			if(tConnect.isDefined()){
				tResult <- tResult.including(tConnect);
				tResult <- tResult.union(tConnect.pred -> collect(p|p.source));
			}
		}
		
		tResult;
	}
}

-- Gets a responsibility given its name.
rule getResponsibility(vResponsibilityName: String){
	do{
		Urn!Responsibility.allInstances() -> any(n|n.name=vResponsibilityName);
	}
}

-- Gets the Urn counterpart for a Turn node.
rule getTargetNode(sPathNode: Turn!PathNode){
	using{
		vPathNodeTypes : Sequence(String) = 
			Sequence {
				'tWaitingPlace', 'tFailurePoint', 'tRespRef',
				'tTimer', 'tAndFork', 'tOrFork', 'tStub',
				'tAndJoin', 'tOrJoin'
			};
		tRetrievedNode : Urn!PathNode = OclUndefined;
	}
	do{
		if(sPathNode.isDefined()){
			if(sPathNode.oclIsTypeOf(Turn!Stub)){
				if(sPathNode.stubRef.isDefined()){
					-- Stub was created Using a stub declaration, so we need to find that.
					sPathNode <- sPathNode.stubRef;
				}
			}
			else if(sPathNode.oclIsTypeOf(Turn!Connect)){
				sPathNode <- sPathNode.connectsTo;
			}
			else if(sPathNode.oclIsTypeOf(Turn!EndpointWithConnect)){
				if(not sPathNode.regularEnd.isDefined()){
					-- If the regularEnd isn't defined, just get the first EndPoint.
					-- This won't work correctly if there's more than one unnamed EndPoint.
					-- TODO: fix this to make it work more generally.
					-- This will likely require a change in the produced xml input files 
					-- rather than a change in this code.
					
					tRetrievedNode <- thisModule.tUCMmap.nodes -> any(n|n.oclIsTypeOf(Urn!EndPoint));
				}
				
				sPathNode <- sPathNode.regularEnd;
			}
			
			if(sPathNode.oclIsTypeOf(Turn!EndPoint)){
				tRetrievedNode <- thisModule.endPointMap.get(sPathNode);
			}
			else{
				for(vPathNodeType in vPathNodeTypes){
					if(not tRetrievedNode.isDefined()){
						tRetrievedNode <- thisModule.resolveTemp(sPathNode, vPathNodeType);	
					}
				}
			}
			
			if(not tRetrievedNode.isDefined()){
				tRetrievedNode <- thisModule.tUCMmap.nodes -> any(n|n.name=sPathNode.turnGetLongestName());
			}
		}
		
		tRetrievedNode;
	}
}

rule getTargetNodeByName(vName: String){
	using{
		tNode : Urn!PathNode = OclUndefined;	
	}
	do{
		tNode <- thisModule.tUCMmap.nodes -> any(n|n.name=vName);

		if(not tNode.isDefined()){
			tNode <- thisModule.tUCMmap.nodes -> select(n|n.oclIsTypeOf(Urn!RespRef)) -> any(rr|rr.respDef.name=vName);
		}
		
		tNode;
	}
}

-- Join all the preds of tSuccNode using an OrJoin and return the OrJoin.
rule joinAllPreds(tSuccNode: Urn!PathNode){
	using{
		tJoin : Urn!OrJoin = thisModule.createOrJoin();
		
		-- Used to copy preds in case of an or join to iterate over them without causing concurrent modification exception.
		tPreds : Sequence(Urn!NodeConnection) = Sequence{};
	}
	do{
		-- Add all items to be modified to tPreds so that we're not directly iterating over the preds; 
		-- Trying to modify the pred list while iterating on it directly raises an error.
		for(tPred in tSuccNode.pred){
			tPreds <- tPreds.including(tPred);	
		}
		
		for(tPred in tPreds){
			tPred.target <- tJoin;
		}
		
		tJoin;
	}
}

-- Increments and returns the next global id.
rule nextId(){
	do{
		thisModule.id <- thisModule.id.inc();
		thisModule.id;
	}
}
