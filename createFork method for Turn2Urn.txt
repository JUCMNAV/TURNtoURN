FORK1 <- tAndFork;
FORK2 <- tOrFork;

FORKTYPE1 <- 'And';
FORKTYPE2 <- 'Or';

MAP1 <- andForkMap;
MAP2 <- orForkMap;

CONNECTINGBODY1 <- obj.connectingAndBody;
CONNECTINGBODY2 <- obj.connectingOrBody;

COND1 <- true;
COND2 <- not obj.body.oclIsUndefined();

PATHBODY1 <- obj.pathbody;
PATHBODY2 <- obj.body.regularBody -> collect(pb|pb.pathBody) -> flatten();

BODY1 <- obj.pathbody;
BODY2 <- obj.body.regularBody;

================================
rule createNodeConnection(){ -- TODO: Not sure if this method will work as create or fork node connections was called in other places
	to
	 	tNodeConnection: Urn!NodeConnection
	do{
		targetNodeConnection
	}
}

================================

if(FORK.name.oclIsUndefined()){
	FORK.name <- FORKTYPE + 'Fork' + tAndFork.id;
}
else{
	FORK.label <- thisModule.createLabel();
}

if(not obj.boundTo.oclIsUndefined()){
	FORK.contRef <- thisModule.getUrnCompRef(obj);
}

MAP <- MAP.including(obj, FORK); --TODO: determine if this will work; does passing the map in as an argument pass in a copy or reference?

if(COND){
	for(elem in BODY){
		thisModule.newNodeConnection <- createNodeConnection();
		if(FORKTYPE = 'Or' and elem <> OclAny){ -- TODO: determine if elem <> OclAny is equivalent to elem.oclIsUndefined() in this case
			thisModule.newNodeConnection.condition <- thisModule.resolveTemp(elem.condition, 'tCondition');
		}
		FORK.succ <- thisModule.newNodeConnection;
	}
}
else if(not obj.connectingOrBody.oclIsUndefined()){ -- can only be entered in OR fork
	tOrFork.succ <- thisModule.createOrForkNodeConns(obj, tUCMmap);
}

if(FORKTYPE = 'Or'){
	--Connecting nodes before OrFork in case it is a stub
	if(not obj.pbody.parentStub.oclIsUndefined()){
		tOrFork.pred <- tUCMmap.nodes -> any(n|n.name=obj.pbody.parentStub.parentStub.name).succ ;
	}
}

thisModule.nodeCollector <- Sequence{};

if(COND){
	tUCMmap.nodes <- thisModule.collectReferencedEnds(PATHBODY -> flatten() -> collect(pb|pb.pathNodes));
	
	for(pathend in PATHBODY -> flatten() -> collect(pb|pb.pathEnd) -> flatten()){
		thisModule.newNode <- '';
		
		if(FORKTYPE = 'And' and pathend.oclIsTypeOf(Turn!Timer)){ 
			-- TODO: using a call to collectRegularEnds in the And case now; this needs to be updated accordingly
			thisModule.newNode <- thisModule.createTimer(pathend, tUCMmap);
		}
		else{
			thisModule.newNode <- thisModule.processPathEnd(tUCMmap, pathend, (FORKTYPE = 'Or'));
		}
		
		if(not (thisModule.newNode = '')){
			thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.newNode);	
		}
	}
	
	if(FORKTYPE = 'Or'){
		--Orforks with only one pathbody
		if(PATHBODY -> size() = 1){
			--creating a node connection with a negated condition
			thisModule.createdOrForkNodeConnection <- thisModule.createOrForkNodeConns(OclAny, tUCMmap);
			
			thisModule.condition <- '';
			if(PATHBODY.first().pathEnd.oclIsUndefined()){
				thisModule.condition <- thisModule.joinStringSequence(PATHBODY.first().orFork.condition.expression, '');
			}
			thisModule.createdOrForkNodeConnection.condition <- thisModule.createCondition('!'+thisModule.condition);
			
			--creating an empty end point
			if(obj.body.elseBody.oclIsUndefined()){
				thisModule.createdOrForkNodeConnection.target <- thisModule.createEndPoint(obj, tUCMmap) -> first();
			}
			
			tOrFork.succ <- thisModule.createdOrForkNodeConnection;
		}
	}
}
else if(FORKTYPE = 'Or'){
	thisModule.newOrForkConnection <- thisModule.createOrForkNodeConns(OclAny, tUCMmap);
	
	thisModule.condition <- thisModule.joinStringSequence(obj.condition.expression, '');
	thisModule.newOrForkConnection.condition <- thisModule.createCondition('!'+thisModule.condition);
	thisModule.newOrForkConnection.target <- thisModule.createEndPoint(obj, tUCMmap) -> first();
	
	tOrFork.succ <- thisModule.newOrForkConnection;
}

if(not CONNECTINGBODY.oclIsUndefined()){
	tUCMmap.nodes <- thisModule.collectReferencedEnds(CONNECTINGBODY.pathNodes);
	
	thisModule.numberOfTerminatingNodes <- 0;
	
	if(COND){
		thisModule.numberOfTerminatingNodes <- PATHBODY -> select(pb|pb.pathEnd.oclIsUndefined()) -> size();
	}
	
	thisModule.newNode <- thisModule.processPathEnd(tUCMmap, CONNECTINGBODY.pathEnd, true);
	
	if(not (thisModule.newNode = '')){
		thisModule.nodeCollector <- thisModule.nodeCollector -> union(thisModule.newNode);	
	}
	
	thisModule.nextNode <- FORK;
	
	if(thisModule.numberOfTerminatingNodes = 2){
		if(FORKTYPE = 'And'){
			thisModule.nextNode <- thisModule.createAndJoin(tUCMmap, FORK.succ -> any(s|s.target.oclIsUndefined()));
		}
		else if(FORKTYPE = 'Or'){
			thisModule.nextNode <- thisModule.createOrJoin(tUCMmap, FORK.succ -> any(s|s.target.oclIsUndefined()));
		}
		else{
			--this is only entered if forktype is invalid
		}
	}
	else if(thisModule.numberOfTerminatingNodes = 1){
		thisModule.firstPathNode <- CONNECTINGBODY.pathNodes -> first();
		
		if(not thisModule.firstPathNode.oclIsUndefined() and not thisModule.firstPathNode.oclIsTypeOf(Turn!Connect)){
			if(not thisModule.firstPathNode.name.oclIsUndefined()){
				thisModule.nextNode <- tUCMmap.nodes -> any(n|n.name = thisModule.firstPathNode.name);
			}
		}
	}
	
	if(CONNECTINGBODY.pathNodes -> isEmpty()){
		if(FORKTYPE = 'And'){
			thisModule.nextPred <- thisModule.nextNode.succ -> any(s|s.target.oclIsUndefined());
			thisModule.connectPathEndToNextNode(tUCMmap, CONNECTINGBODY.pathEnd, thisModule.nextPred);
			thisModule.connectReferencedEndToNextNode(tUCMmap, CONNECTINGBODY, thisModule.nodeCounter, thisModule.nextPred);
		}
		else if(FORKTYPE = 'Or'){
			if(not obj.body.oclIsUndefined()){
				if(not obj.body.elseBody.oclIsUndefined()){
					thisModule.connectOrForkEndPoints(obj, thisModule.nextNode, tUCMmap, thisModule.createdCondition.expression);
				}
				
				for (pathbody in obj.body.regularBody -> collect(pb|pb.pathBody) -> flatten()){
					thisModule.condition <- '';
					if(pathbody.pathEnd.oclIsUndefined()){
						thisModule.condition <- thisModule.joinStringSequence(pathbody.orFork.condition.expression, '');
					}
					thisModule.connectOrForkEndPoints(obj, thisModule.nextNode, tUCMmap, thisModule.condition);
				}
			}
			else{
				thisModule.condition <- thisModule.joinStringSequence(obj.condition.expression, '');
				thisModule.connectOrForkEndPoints(obj, thisModule.nextNode, tUCMmap, thisModule.condition);
			}
		}
		else{
			--this is only entered if forktype is invalid
		}
	}
	
	thisModule.counter <- 1;
	thisModule.connectNodes(CONNECTINGBODY, obj, tUCMmap, thisModule.nextNode);
}

-- Connecting nodes after fork
if(COND){
	thisModule.count <- 1;
	for(pathbody in PATHBODY){
		if(pathbody.pathNodes -> first().oclIsTypeOf(Turn!RespRef)){
			thisModule.resolveTemp(pathbody.pathNodes -> first(),'tRespRef').pred <- FORK.succ -> at(thisModule.count);
		}
		thisModule.count <- thisModule.count.inc(); 			
	}
}

thisModule.useBacklinksToConnectOrFork(obj.pbody, FORK);

thisModule.nodeCollector;